title;;;authors;;;date;;;source;;;abstract;;;link;;;category
Systematizing the Meta-Analytical Process in Software Engineering;;;['Letizia Jaccheri', 'Zamira Kholmatova', 'Giancarlo Succi'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;The generalization of knowledge is a necessary part of every scientific field. Meta-analysis is already advocated as a tool for generalization in different areas such as medicine, psychology, business, and this process is already standardized for them. Software engineering started using meta-analysis as a tool for aggregating results from families of experiments, but not so long for generalization of results coming from different studies, and for this purpose, the meta-analytical approach is not yet clarified. In this paper, we attempt to systematize the application of meta-analysis as a secondary study to the software engineering field suggesting our preliminary protocol. To see the reliability of the proposed protocol we conducted several studies using it. Following even uniform protocol with these studies, we identified the issues preventing the wide usage of meta-analysis in software engineering and proposed our solutions for them.;;;https://dl.acm.org/doi/10.1145/3501774.3501775;;;Software AND Engineering
Explainable AI for software engineering;;;['Chakkrit (Kla) Tantithamthavorn', 'Jirayus Jiarpakdee'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;The success of software engineering projects largely depends on complex decision-making. For example, which tasks should a developer do first, who should perform this task, is the software of high quality, is a software system reliable and resilient enough to deploy, etc. However, erroneous decision-making for these complex questions is costly in terms of money and reputation. Thus, Artificial Intelligence/Machine Learning (AI/ML) techniques have been widely used in software engineering for developing software analytics tools and techniques to improve decision-making, developer productivity, and software quality. However, the predictions of such AI/ML models for software engineering are still not practical (i.e., coarse-grained), not explainable, and not actionable. These concerns often hinder the adoption of AI/ML models in software engineering practices. In addition, many recent studies still focus on improving the accuracy, while a few of them focus on improving explainability. Are we moving in the right direction? How can we better improve the SE community (both research and education)? In this tutorial, we first provide a concise yet essential introduction to the most important aspects of Explainable AI and a hands-on tutorial of Explainable AI tools and techniques. Then, we introduce the fundamental knowledge of defect prediction (an example application of AI for Software Engineering). Finally, we demonstrate three successful case studies on how Explainable AI techniques can be used to address the aforementioned challenges by making the predictions of software defect prediction models more practical, explainable, and actionable. The materials are available at https://xai4se.github.io.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678580;;;Software AND Engineering
Hazard Analysis Methods for Software Safety Requirements Engineering;;;['Vu Nguyen Tran', 'Long Vu Tran', 'Viet Nguyen Tran', 'Dao Ngoc Vu'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;The rise of software-based system control in safety-critical systems has made software safety a critical part of a system safety program. The risk of catastrophic software system failure increases with the growth of safety-critical technologies in autonomous transportation systems, airplanes, traffic control systems, medical surgery equipment, nuclear power centers, power grids, human-assist robotics, and military weaponry. Developing software control in safety-critical systems is challenging because the control needs to be reliable and safe. High-profile system failures in recent years, such as the crashes of the 737 MAX airliners, are constant reminders of the risk of software failure in safety-critical systems. The software quality assurance approaches used in software development today are insufficient for created for assuring software reliability but not safety. Developing functionally safe software requires incorporating a risk-driven approach that focuses on hazard identification, hazard risk anticipation, and mitigation. Software safety methods adoption in practice and across mainstream computer science and software engineering curriculums is still limited. Heeding the call for more publications on the practice of software safety, we present an integrated approach to software safety requirements engineering (SSRE). Engineering safety requirements for software is one of the most important steps in building safe software. First, we provide an overview of SSRE. Then we describe three hazard analysis methods that can be incorporated into a software requirement engineering process. Finally, discuss how we combine these distinct methods into a single SSRE approach to support safety-critical systems development.;;;https://dl.acm.org/doi/10.1145/3520084.3520087;;;Software AND Engineering
Psychometrics in Behavioral Software Engineering: A Methodological Introduction with Guidelines;;;['Daniel Graziotin', 'Per Lenberg', 'Robert Feldt', 'Stefan Wagner'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;A meaningful and deep understanding of the human aspects of software engineering (SE) requires psychological constructs to be considered. Psychology theory can facilitate the systematic and sound development as well as the adoption of instruments (e.g., psychological tests, questionnaires) to assess these constructs. In particular, to ensure high quality, the psychometric properties of instruments need evaluation. In this article, we provide an introduction to psychometric theory for the evaluation of measurement instruments for SE researchers. We present guidelines that enable using existing instruments and developing new ones adequately. We conducted a comprehensive review of the psychology literature framed by the Standards for Educational and Psychological Testing. We detail activities used when operationalizing new psychological constructs, such as item pooling, item review, pilot testing, item analysis, factor analysis, statistical property of items, reliability, validity, and fairness in testing and test bias. We provide an openly available example of a psychometric evaluation based on our guideline. We hope to encourage a culture change in SE research towards the adoption of established methods from psychology. To improve the quality of behavioral research in SE, studies focusing on introducing, validating, and then using psychometric instruments need to be more common.;;;https://dl.acm.org/doi/10.1145/3469888;;;Software AND Engineering
Decoding grounded theory for software engineering;;;['Rashina Hoda'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Grounded Theory, while becoming increasingly popular in software engineering, is also one of the most misunderstood, misused, and poorly presented and evaluated method in software engineering. When applied well, GT results in dense and valuable explanations of how and why phenomena occur in practice. GT can be applied as a full research method leading to mature theories and also in limited capacity for data analysis within other methods, using its robust open coding and constant comparison procedures. This technical briefing will go through the social origins of GT, present examples of grounded theories developed in SE, discuss the key challenges SE researchers face, and provide a gentle introduction to socio-technical grounded theory, a variant of GT for software engineering research.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00139;;;Software AND Engineering
Inconsistency-tolerating guidance for software engineering processes;;;['Christoph Mayr-Dorn', 'Roland Kretschmer', 'Alexander Egyed', 'Ruben Heradio', 'David Fernandez-Amoros'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Software processes, together with software quality assurance, focus on ensuring and attesting that the engineering processes result in the appropriate software quality. Complex processes and regulations (e.g., in safety-critical systems), time pressure, or coordination needs, often cause engineers to deviate from prescribed processes, producing a cascade of inconsistencies whose repair is typically troublesome. Accordingly, guidance is needed to help engineers to fix the inconsistencies and understand the implications of postponing inconsistency resolution until engineers reach a consensual agreement of the most convenient repair. To this end, we bring together techniques and methods from process engineering, model inconsistency checking, and formal methods. Preliminary evaluations with real industry data have demonstrated the ability of our early prototype to track process inconsistencies across time and the potential for automated repair.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00010;;;Software AND Engineering
A Classification for Managing Software Engineering Knowledge;;;['Angelika Kaplan', 'Maximilian Walter', 'Robert Heinrich'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;This taxonomy paper presents a novel way of knowledge engineering in the software engineering research community. Till now, research papers are organized digitally as documents, mostly in PDF files. Not much effort is spent on effective knowledge classification, retrieval, storage, and representation. In contrast to the current paper-based approach for knowledge documentation, we present a statement-based approach, where each statement is linked to arguments and data of its evidence as well as to related statements. We argue that in this way, knowledge will be easier to retrieve, compare, and evaluate in contrast to current paper-based knowledge engineering in scientific search engines and digital libraries. Therefore, we present as a first step a novel multi-dimensional classification for statements in software engineering research. Statements are classified according to their research object, their kind (e.g., relevance), and their underlying evidence. This classification is validated and extended with a first systematic literature review. Additionally, we provide an example for illustration purpose.;;;https://dl.acm.org/doi/10.1145/3463274.3463357;;;Software AND Engineering
On Implicit Assumptions Underlying Software Engineering Research;;;['Lutz Prechelt'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Background: Software engineering research articles should make precise claims regarding their contribution, so that practitioners can decide when they might be interested and researchers can better recognize (1) whether the given research is valid, (2) which published works to use as stepping stones for their own research (and which not), and (3) where additional research is required. In particular, articles should spell out what assumptions were made at each research step. Question: Can we identify recurring patterns of assumptions that are not spelled out? Method: This is a position paper. It formulates impressions, but does not present concrete evidence. Results: Assumptions that are wrong or assumptions that are risky and not explicit threaten the integrity of the scientific record. There are several recurring types of such assumptions. The frequency of these problems is currently unknown. Conclusion: The software engineering research community should become more conscious and more explicit with respect to the assumptions that underlie individual research works.;;;https://dl.acm.org/doi/10.1145/3463274.3463356;;;Software AND Engineering
Benchmarking as Empirical Standard in Software Engineering Research;;;['Wilhelm Hasselbring'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;In empirical software engineering, benchmarks can be used for comparing different methods, techniques and tools. However, the recent ACM SIGSOFT Empirical Standards for Software Engineering Research do not include an explicit checklist for benchmarking. In this paper, we discuss benchmarks for software performance and scalability evaluation as example research areas in software engineering, relate benchmarks to some other empirical research methods, and discuss the requirements on benchmarks that may constitute the basis for a checklist of a benchmarking standard for empirical software engineering research.;;;https://dl.acm.org/doi/10.1145/3463274.3463361;;;Software AND Engineering
Towards inclusive software engineering through A/B testing: a case-study at windows;;;['Irina Niculescu', 'Huibin Mary Hu', 'Christina Gee', 'Chewy Chong', 'Shivam Dubey', 'Paul Luo Li'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Engineering software to be inclusive of all those that might/could/should use the software is important. However, today, data used to engineer software can have inherent biases (e.g. gender identity) with inclusiveness concerns. While much attention has been given to this topic in the AI/ML space, in this paper, we examine another data-centric software engineering process, A/B testing, for which we have a dearth of understanding today. Using real-world data from the Windows out of box experience (OOBE) feature, we provide a case-study of how inclusiveness concerns can manifest in A/B testing, practical adjustments to A/B testing towards inclusive software engineering, and insights into ongoing challenges. We discuss implications for research and practice.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00027;;;Software AND Engineering
Exploring the role of creativity in software engineering;;;['Wouter Groeneveld', 'Laurens Luyten', 'Joost Vennekens', 'Kris Aerts'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;In order to solve today's complex problems in the world of software development, technical knowledge is no longer enough. Previous studies investigating and identifying nontechnical skills of software engineers show that creative skills also play an important role in tackling difficult problems. However, creativity is typically a very vague concept to which everyone gives their own interpretation. Also, there is little research that focuses specifically on creativity in the field of software engineering. To better understand the role of creativity in this field, we conducted four focus groups, inviting 33 experts from four nationally and internationally renowned companies in total. This resulted in 399 minutes of transcripts, further coded into 39 sub-themes grouped into seven categories: technical knowledge, communication, constraints, critical thinking, curiosity, creative state of mind, and creative techniques. This study identifies the added value of creativity, which creative techniques are used, how creativity can be recognized, the reasons for being creative, and what environment is needed to facilitate creative work. Our ultimate goal is to use these findings to instill and further encourage the creative urge among undergraduate students in higher education.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00009;;;Software AND Engineering
Software engineering meets deep learning: a mapping study;;;['Fabio Ferreira', 'Luciana Lourdes Silva', 'Marco Tulio Valente'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Deep Learning (DL) is being used nowadays in many traditional Software Engineering (SE) problems and tasks. However, since the renaissance of DL techniques is still very recent, we lack works that summarize and condense the most recent and relevant research conducted at the intersection of DL and SE. Therefore, in this paper, we describe the first results of a mapping study covering 81 papers about DL & SE. Our results confirm that DL is gaining momentum among SE researchers over the years and that the top-3 research problems tackled by the analyzed papers are documentation, defect prediction, and testing.;;;https://dl.acm.org/doi/10.1145/3412841.3442029;;;Software AND Engineering
Application of Reverse Engineering in Software Engineering Teaching: Combining case teaching with task driven Teaching;;;['Huaming Liu', 'Xuehui Bi', 'Xiuyou Wang', 'Huaimin Li', 'Ying Yang', 'Zhengyan Liu', 'Kunzhe Liu'];;;May 2021;;;ICDEL '21: Proceedings of the 2021 6th International Conference on Distance Education and Learning;;;In the teaching of software engineering for computer related majors, there is a gap between high-level logic design and implementation, which leads to the students' unreasonable software design, and the implementation code does not follow the design scheme. Therefore, it is necessary to carry out heuristic teaching for students, starting from the programming students are most familiar with, gradually transition to software design, using reverse thinking teaching mode, so that students can master the transformation relationship between design and implementation. In the implementation of case teaching, it is necessary to restore high-level design or demand analysis through code, realize the conversion from code to document, and effectively improve the theoretical level of students; in terms of practical skills, implement task driven teaching, deepen the understanding of cases and knowledge transfer, and exercise the practical ability of students. Through the performance analysis of 2015 and 2016 students, the reverse engineering case teaching and task driven practice can significantly improve students' practical ability, stimulate students' enthusiasm for software development, and highlight students' software development ability in computer skills competition, college students' innovation training project and graduation design.;;;https://dl.acm.org/doi/10.1145/3474995.3475038;;;Software AND Engineering
Software techniques for engineering cyber-physical systems;;;['Kostas Kontogiannis', 'Daniel Amyot', 'John Mylopoulos'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Cyber-Physical Systems (CPSs) refer to systems comprising software components, physical components, and social entities which monitor, control, and coordinate processes within a physical environment. CPSs apply to a wide range of mission-critical applications that span from the intelligent management of logistics in complex supply chains, advanced manufacturing systems, and smart contracts, all the way to autonomous systems, and systems that support the smart interactions between humans and machines (M2H), or between machines (M2M). In this respect, the engineering of CPSs goes beyond existing Software Engineering concepts, tools, and techniques because of the very nature of CPSs that spans three realms (cyber, physical, social) and therefore needs to address requirements that span these realms. During the workshop, the participants discussed and debated techniques and directions in six main thematic areas on engineering Cyber-Physical Systems. These thematic areas deal with specification and modeling, DevOps processes for CPSs, data management and analytics, infrastructure and event handling, run-time adaptivity, and finally security, trust, and traceability.;;;https://dl.acm.org/doi/10.5555/3507788.3507844;;;Software AND Engineering
Sustainable Capacity Building in Software Engineering Research in Africa: The Example of the BRIGHT Project;;;['Engineer Bainomugisha', 'Regina Hebig', 'Michel Chaudron'];;;July 2020;;;ACM SIGSOFT Software Engineering Notes;;;The software industry is a key engine of economic growth in Africa, which calls for sustainable and innovative approaches to build capacities in software engineering research and education for the continent. This paper presents the BRIGHT project as an example for a collaboration that aims to build such capacity. The collaboration includes institutions in Sweden and Uganda. The goal of the collaboration is to train faculty in software en- gineering and to build a supporting research environment, which includes the creation of networks with the software engineering community at a global scale as well as connecting academia and the local software industry. So far, the project has resulted in 50 publications, a software engineering research centre, software engineering summer schools, and conferences.;;;https://dl.acm.org/doi/10.1145/3402127.3402135;;;Software AND Engineering
Exponential competence of computer science and software engineering undergraduate students;;;['Orit Hazzan'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;We live in exceptional times in which the entire world is witnessing the exponential spread of a pandemic, which requires to adopt new habits of mind and behaviors. In this paper, I introduce the term exponential competence, which encompasses these cognitive and social skills, and describe a course for computer science and software engineering students in which emphasis is placed on exponential competence. I argue that exponential competence is especially important for computer science and software engineering students, since many of them will, most likely, be required to deal with exponential phenomena in their future professional development.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00020;;;Software AND Engineering
Using Real Worked Examples to Aid Software Engineering Teaching;;;['Simone Tonhão', 'Thelma Colanzi', 'Igor Steinmacher'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Worked examples are instructional devices composed of the description of a problem, steps to solve the problem, and the final result. There is evidence that the use of the worked examples improves the learning process by reducing the learning time, reducing the cognitive load, and facilitating the construction of cognitive schemes. In addition, students who learn from worked examples tend to solve similar problems more quickly and easily. Worked examples are adopted in several areas of knowledge but are not well-explored in Software Engineering (SE) teaching. Thus, the goal of this work was to explore the use of worked examples in SE courses. To do so, we conducted an exploratory study split into two stages. In the first stage, we administered a survey with SE instructors to investigate the use of common examples, worked examples, and the difficulties find this type of material. In the second stage, we applied worked examples in the classroom and collected feedback from students. The second stage was carried out remotely due to the conditions imposed by COVID-19. The results showed that instructors are employing examples in their courses; some of them use worked examples, even when they do not know the definition. In addition, the feedback from the students was positive, which may encourage the use of worked examples in SE teaching.;;;https://dl.acm.org/doi/10.1145/3474624.3476970;;;Software AND Engineering
Applying Bayesian Analysis Guidelines to Empirical Software Engineering Data: The Case of Programming Languages and Code Quality;;;['Carlo A. Furia', 'Richard Torkar', 'Robert Feldt'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Statistical analysis is the tool of choice to turn data into information and then information into empirical knowledge. However, the process that goes from data to knowledge is long, uncertain, and riddled with pitfalls. To be valid, it should be supported by detailed, rigorous guidelines that help ferret out issues with the data or model and lead to qualified results that strike a reasonable balance between generality and practical relevance. Such guidelines are being developed by statisticians to support the latest techniques for Bayesian data analysis. In this article, we frame these guidelines in a way that is apt to empirical research in software engineering.To demonstrate the guidelines in practice, we apply them to reanalyze a GitHub dataset about code quality in different programming languages. The dataset’s original analysis [Ray et al. 55] and a critical reanalysis [Berger et al. 6] have attracted considerable attention—in no small part because they target a topic (the impact of different programming languages) on which strong opinions abound. The goals of our reanalysis are largely orthogonal to this previous work, as we are concerned with demonstrating, on data in an interesting domain, how to build a principled Bayesian data analysis and to showcase its benefits. In the process, we will also shed light on some critical aspects of the analyzed data and of the relationship between programming languages and code quality—such as the impact of project-specific characteristics other than the used programming language.The high-level conclusions of our exercise will be that Bayesian statistical techniques can be applied to analyze software engineering data in a way that is principled, flexible, and leads to convincing results that inform the state-of-the-art while highlighting the boundaries of its validity. The guidelines can support building solid statistical analyses and connecting their results. Thus, they can help buttress continued progress in empirical software engineering research.;;;https://dl.acm.org/doi/10.1145/3490953;;;Software AND Engineering
Towards modal software engineering;;;['Ramy Shahin'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;In this paper we introduce the notion of Modal Software Engineering: automatically turning sequential, deterministic programs into semantically equivalent programs efficiently operating on inputs coming from multiple overlapping worlds. We are drawing an analogy between modal logics, and software application domains where multiple sets of inputs (multiple worlds) need to be processed efficiently. Typically those sets highly overlap, so processing them independently would involve a lot of redundancy, resulting in lower performance, and in many cases intractability. Three application domains are presented: reasoning about feature-based variability of Software Product Lines (SPLs), probabilistic programming, and approximate programming.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00026;;;Software AND Engineering
Software Engineering for Smart Cyber-Physical Systems (SEsCPS 2018) - Workshop Report;;;['Tomas Bures', 'Danny Weyns', 'Bradley Schmerl', 'John Fitzgerald', 'Adina Aniculaesei', 'Christian Berger', 'João Cambeiro', 'Jan Carlson', 'Shafiul Azam Chowdhury', 'Marian Daun', 'Nianyu Li', 'Matthias Markthaler', 'Claudio Menghi', 'Birgit Penzenstadler', 'Aedan Pettit', 'Robert Pettit', 'Luca Sabatucci', 'Christos Tranoris', 'Hans Vangheluwe', 'Sebastian Voss', 'Edith Zavala'];;;October 2019;;;ACM SIGSOFT Software Engineering Notes;;;Smart Cyber-Physical Systems (sCPS) are a novel kind of Cyber- Physical System engineered to take advantage of large-scale cooperation between devices, users and environment to achieve added value in the face of uncertainty and changing environments. Examples of sCPS include modern traffic systems, Industry 4.0 systems, systems for smart buildings, and smart energy grids. The uniting aspect of all these systems is that to achieve their high level of intelligence, adaptivity and ability to optimize and learn, they rely heavily on software. This makes them software-intensive systems, where software becomes their most complex part. Engineering sCPS thus becomes a recognized software engineering discipline, which, due to specifics of sCPS, can only partially rely on the existing body of knowledge in software engineering. In fact, it turns out that many of the traditional approaches to architecture modeling and software development fall short in their ability to cope with the high dynamicity and uncertainty of sCPS. This calls for innovative approaches that jointly reflect and address the specifics of such systems. This paper maps the discussions and results of the Fourth International Workshop on Software Engineering for Smart Cyber-Physical Systems (SEsCPS 2018), which focuses on challenges and promising solutions in the area of software engineering for sCPS.;;;https://dl.acm.org/doi/10.1145/3364452.3364465;;;Software AND Engineering
Gamifying Flipped Classes: An Experience Report in Software Engineering Remote Teaching;;;['Mayara Olivindo', 'Necio Veras', 'Windson Viana', 'Mariela Cortés', 'Lincoln Rocha'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Context. In the COVID-19 pandemic, higher education was one of the most affected in adapting the teaching-learning process to comply with social distance measures. In this context, this research reports how we combined two active methodologies in Software Engineering Emergency Remote Teaching. Objective. Therefore, this study aims to report the experiences obtained from the application of gamified study guides in Software Engineering (SE) between November 2020 and April 2021. Method. We combined flipped classroom, an active methodology already known by them, with Gamification to improve students’ acceptance and engagement. We created six gamified study guides for the SE flipped classes. 51 students participated in the classes, 12 students from the Computer Technician course and 39 students from the Computer Science Bachelor course. Each study guide had a group of checkpoints to organize the content in levels. Results. At the end of the application, we observed 83.6% of the participating students maintained their engagement. According to self-declaration, 85% felt motivated by the approach adopted, with 75.9% considering that the class format presented enhanced their learning. We also observed a positive impact on learning gain in an average of 18.3% in their grades. Final Considerations. We concluded that using Gamification and Flipped Classroom has positive impacts on learning and acceptance, although the COVID-19 pandemic and the ERT negatively affect students’ motivation.;;;https://dl.acm.org/doi/10.1145/3474624.3476971;;;Software AND Engineering
Software Engineering in Australasia;;;['Sherlock A. Licorish', 'Christoph Treude', 'John Grundy', 'Kelly Blincoe', 'Stephen MacDonell', 'Chakkrit Tantithamthavorn', 'Li Li', 'Jean-Guy Schneider'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;Six months ago an important call was made for researchers globally to provide insights into the way Software Engineering is done in their region. Heeding this call, we hereby outline the position Software Engineering in Australasia (New Zealand and Australia). This article first considers the software development methods, practices and tools that are popular in the Australasian software engineering community. We then briefly review the particular strengths of software engineering researchers in Australasia. Finally, we make an open call for collaborators by reflecting on our current position and identifying future opportunities.;;;https://dl.acm.org/doi/10.1145/3448992.3448995;;;Software AND Engineering
Teaching Testing with Modern Technology Stacks in Undergraduate Software Engineering Courses;;;['Scott P. Chow', 'Tanay Komarlu', 'Phillip T. Conrad'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;Students' experience with software testing in undergraduate computing courses is often relatively shallow, as compared to the importance of the topic. This experience report describes introducing industrial-strength testing into CMPSC 156, an upper division course in software engineering at UC Santa Barbara. We describe our efforts to modify our software engineering course to introduce rigorous test-coverage requirements into full-stack web development projects, requirements similar to those the authors had experienced in a professional software development setting. We present student feedback on the course and coverage metrics for the projects. We reflect on what about these changes worked (or didn't), and provide suggestions for other instructors that would like to give their students a deeper experience with software testing in their software engineering courses.;;;https://dl.acm.org/doi/10.1145/3430665.3456352;;;Software AND Engineering
Towards a Methodology for Participant Selection in Software Engineering Experiments: A Vision of the Future;;;['Valentina Lenarduzzi', 'Oscar Dieste', 'Davide Fucci', 'Sira Vegas'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background. Software Engineering (SE) researchers extensively perform experiments with human subjects. Well-defined samples are required to ensure external validity. Samples are selected purposely or by convenience, limiting the generalizability of results. Objective. We aim to depict the current status of participants selection in empirical SE, identifying the main threats and how they are mitigated. We draft a robust approach to participants' selection. Method. We reviewed existing participants' selection guidelines in SE, and performed a preliminary literature review to find out how participants' selection is conducted in SE in practice. Results. We outline a new selection methodology, by 1) defining the characteristics of the desired population, 2) locating possible sources of sampling available for researchers, and 3) identifying and reducing the "distance" between the selected sample and its corresponding population. Conclusion. We propose a roadmap to develop and empirically validate the selection methodology.;;;https://dl.acm.org/doi/10.1145/3475716.3484273;;;Software AND Engineering
The diversity of gamification evaluation in the software engineering education and industry: trends, comparisons and gaps;;;['Rodrigo Henrique Barbosa Monteiro', 'Maurício Ronny de Almeida Souza', 'Sandro Ronaldo Bezerra Oliveira', 'Carlos dos Santos Portela', 'Cesar Elias de Cristo Lobato'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Context: gamification has been used to motivate and engage participants in software engineering education and practice activities. Problem: There is a significant demand for empirical studies for the understanding of the impacts and efficacy of gamification. However, the lack of standard procedures and models for the evaluation of gamification is a challenge for the design, comparison, and report of results related to the assessment of gamification approaches and its effects. Goal: The goal of this study is to identify models and strategies for the evaluation of gamification reported in the literature. Method: To achieve this goal, we conducted a systematic mapping study to investigate strategies for the evaluation of gamification in the context of software engineering. We selected 100 primary studies on gamification in software engineering (from 2011 to 2020). We categorized the studies regarding the presence of evaluation procedures or models for the evaluation of gamification, the purpose of the evaluation, the criteria used, the type of data, instruments, and procedures for data analysis. Results: Our results show that 64 studies report procedures for the evaluation of gamification. However, only three studies actually propose evaluation models for gamification. We observed that the evaluation of gamification focuses on two aspects: the evaluation of the gamification strategy itself, related to the user experience and perceptions; and the evaluation of the outcomes and effects of gamification on its users and context. The most recurring criteria for the evaluation are "engagement", "performance", "satisfaction", and "motivation". Finally, the evaluation of gamification requires a mix of subjective and objective inputs, and qualitative and quantitative data analysis approaches. Depending of the focus of the evaluation (the strategy or the outcomes), there is a predominance of a type of data and analysis.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00025;;;Software AND Engineering
Towards Improving Experimentation in Software Engineering;;;['Edson OliveiraJr', 'Viviane Furtado', 'Henrique Vignando', 'Carlos Luz', 'André Cordeiro', 'Igor Steinmacher', 'Avelino Zorzo'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;[Background:] Experimentation in Software Engineering plays a central role on sharing and verifying scientific findings. As experiments have increased significantly in Software Engineering area, we observe that most of them fail to provide a way to be repeated, replicated or reproduced, thus jeopardizing or delaying the evolution of the Software Engineering area. [Aims:] In this vision paper, we present and discuss techniques and infrastructure to continuously improve experiments towards repeatability, replicability, and reproducibility. [Method:] We define these techniques and infrastructure based on experiences of our research groups and existing literature. Furthermore, we follow Open Science principles. [Results:] We provide incipient results and foresee a central infrastructure composed of two repositories and two recommendation systems to support techniques for: reporting experiments; developing ontologies for experiments and open educational resources; mining and recommending experiments; specifying data management plans, identifying families of experiments; and teaching and learning experimentation. [Conclusions:] Our techniques and infrastructure will prospectively motivate and benefit Software Engineering evolution by improving the conduction and further reproducibility of experiments.;;;https://dl.acm.org/doi/10.1145/3474624.3477073;;;Software AND Engineering
A Systematic Literature Review on the Use of Deep Learning in Software Engineering Research;;;['Cody Watson', 'Nathan Cooper', 'David Nader Palacio', 'Kevin Moran', 'Denys Poshyvanyk'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;An increasingly popular set of techniques adopted by software engineering (SE) researchers to automate development tasks are those rooted in the concept of Deep Learning (DL). The popularity of such techniques largely stems from their automated feature engineering capabilities, which aid in modeling software artifacts. However, due to the rapid pace at which DL techniques have been adopted, it is difficult to distill the current successes, failures, and opportunities of the current research landscape. In an effort to bring clarity to this cross-cutting area of work, from its modern inception to the present, this article presents a systematic literature review of research at the intersection of SE & DL. The review canvasses work appearing in the most prominent SE and DL conferences and journals and spans 128 papers across 23 unique SE tasks. We center our analysis around the components of learning, a set of principles that governs the application of machine learning techniques (ML) to a given problem domain, discussing several aspects of the surveyed work at a granular level. The end result of our analysis is a research roadmap that both delineates the foundations of DL techniques applied to SE research and highlights likely areas of fertile exploration for the future.;;;https://dl.acm.org/doi/10.1145/3485275;;;Software AND Engineering
Identifying Struggling Teams in Software Engineering Courses Through Weekly Surveys;;;['Kai Presler-Marshall', 'Sarah Heckman', 'Kathryn T. Stolee'];;;February 2022;;;SIGCSE 2022: Proceedings of the 53rd ACM Technical Symposium on Computer Science Education - Volume 1;;;Teaming is increasingly a core aspect of professional software engineering and most undergraduate computer science curricula. At NC State University, we teach communication and project-management skills explicitly through a junior-level software engineering course. However, some students may have a dysfunctional team experience that imperils their ability to learn these skills. Identifying these teams during a team project is important so the teaching staff can intervene early and hopefully alleviate the issues.  We propose a weekly reflection survey to help the course teaching staff proactively identify teams that may not be on track to learn the course outcomes. The questions on the survey focus on team communication and collaboration over the previous week. We evaluate our survey on two semesters of the undergraduate software engineering course by comparing teams with poor end-of-project grades or peer evaluations against teams flagged on a weekly basis through the surveys. We find that the survey can identify most teams that later struggled on the project, typically by the half-way mark of the project, and thus may provide instructors with an actionable early-warning about struggling teams. Furthermore, a majority of students (64.4%) found the survey to be a helpful tool for keeping their team on track. Finally, we discuss future work for improving the survey and engaging with student teams.;;;https://dl.acm.org/doi/10.1145/3478431.3499367;;;Software AND Engineering
Supporting real demands in software engineering with a four steps project-based learning approach;;;['Leonardo Humberto Silva', 'Renata Xavier Castro', 'Marice Costa Guimaraes'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Project-based learning (PBL) is a student-centered and learn-by-doing approach that organizes learning around projects. While entrepreneurship and PBL in SE education are thrilling research topics, there seems to be very little work focusing on the pros and cons of involving external stakeholders to support real demands in software engineering education. Working on real projects also supports students to acquire leadership skills, such as communication, project management, and teamwork. This paper describes a case study integrating students from different Software Engineering programs and involving external stakeholders, underpinned by PBL concepts. We present how this study was designed and implemented in a large institution, in four steps, summarized as follows: (I) requirements gathering and design; (II) information system development and implementation; (III) integration tests and deployment process; (IV) support and maintenance activities. The study had the participation of 59 students from a professional technical course in step one, working in teams, and 10 undergraduate students from a Bachelor's program in Information Systems in the following steps, working in pairs. Overall, the feedback from stakeholders and students exceeded expectations, although it increased the workload of teachers. We were able to distill a new set of lessons learned, and we expect that at least some of them will be useful for anyone implementing a similar course. As a consequence of this study, we plan to institutionally formalize the PBL course improvement process by defining specific outcomes and measurements.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00014;;;Software AND Engineering
A Preliminary Guide for Assertive Selection of Active Methodologies in Software Engineering Education;;;['José Lima', 'Fernanda Alencar', 'Wylliams Santos'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The use of Active Methodologies (AMs) in Software Engineering (SE) teaching has provoked scenarios that provide students with more meaningful learning, bringing the academy and the industry closer to stimulate transversal competencies and analytical skills through a humanistic, critical and reflective education. Despite this, the use of AMs in the SE teaching-learning process presents some obstacles, such as the low understanding by professors, the choice of the appropriate type for the teaching context, time and effort required to prepare the classes, and the absence of support tools, making implementation a challenge. In order to mitigate these difficulties, this article aims to present the development of a selection guide that provides professors with a tool to assist them in the assertive choice of the type of active methodology, based on the identifying the student’s learning profile and style. The guide has been developed through the Design Science Research methodology. Its first version was validated through a cycle of focus groups session with a panel composed of experts in the educational context of SE and in the use of AMs. The results showed indications of its usefulness, clarity, ease of use, organization, flexibility, pedagogical appropriateness, visualization and selection of AMs in different teaching contexts. In this sense, these actions can be carried out with a low level of effort by professors with few skills.;;;https://dl.acm.org/doi/10.1145/3474624.3476976;;;Software AND Engineering
Development and Application of Sentiment Analysis Tools in Software Engineering: A Systematic Literature Review;;;['Martin Obaidi', 'Jil Klünder'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Software development is a collaborative task and, hence, involves different persons. Research has shown the relevance of social aspects in the development team for a successful and satisfying project closure. Especially the mood of a team has been proven to be of particular importance. Thus, project managers or project leaders want to be aware of situations in which negative mood is present to allow for interventions. So-called sentiment analysis tools offer a way to determine the mood based on text-based communication. In this paper, we present the results of a systematic literature review of sentiment analysis tools developed for or applied in the context of software engineering. Our results summarize insights from 80 papers with respect to (1) the application domain, (2) the purpose, (3) the used data sets, (4) the approaches for developing sentiment analysis tools and (5) the difficulties researchers face when applying sentiment analysis in the context of software projects. According to our results, sentiment analysis is frequently applied to open-source software projects, and most tools are based on support-vector machines. Despite the frequent use of sentiment analysis in software engineering, there are open issues, e.g., regarding the identification of irony or sarcasm, pointing to future research directions.;;;https://dl.acm.org/doi/10.1145/3463274.3463328;;;Software AND Engineering
Bayesian data analysis for software engineering;;;['Richard Torkar', 'Carlo A. Furia', 'Robert Feldt'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Slowly but surely, statistical practices in the empirical sciences are undergoing a complete makeover. Researchers in empirical software engineering, where too statistics is an essential tool, must become familiar with these new practices to ensure rigor of their research methods and soundness of their research results.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00140;;;Software AND Engineering
PLS-SEM for Software Engineering Research: An Introduction and Survey;;;['Daniel Russo', 'Klaas-Jan Stol'];;;None;;;ACM Computing Surveys;;;Software Engineering (SE) researchers are increasingly paying attention to organizational and human factors. Rather than focusing only on variables that can be directly measured, such as lines of code, SE research studies now also consider unobservable variables, such as organizational culture and trust. To measure such latent variables, SE scholars have adopted Partial Least Squares Structural Equation Modeling (PLS-SEM), which is one member of the larger SEM family of statistical analysis techniques. As the SE field is facing the introduction of new methods such as PLS-SEM, a key issue is that not much is known about how to evaluate such studies. To help SE researchers learn about PLS-SEM, we draw on the latest methodological literature on PLS-SEM to synthesize an introduction. Further, we conducted a survey of PLS-SEM studies in the SE literature and evaluated those based on recommended guidelines.;;;https://dl.acm.org/doi/10.1145/3447580;;;Software AND Engineering
An Online Educational Hackathon to Foster Professional Skills and Intense Collaboration on Software Engineering Students;;;['Caio Steglich', 'Sabrina Marczak', 'Luiz Guerra', 'Cássio Trindade', 'Alessandra Dutra', 'Ana Bacelo'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The global pandemic of COVID19 demanded that professors rethink teaching strategies considering the use of online environments due to the social isolation stipulated to reduce the rate of contagion of the disease. A challenge for software engineering professors is to develop fundamental professional skills in students who are in the process of learning using these virtual environments. The purpose of this study is to identify how an online educational hackathon can support students of a Software Engineering program to develop professional skills. We also seek to understand how intense collaboration takes place between student teams, considering the digital context for the production of a technological solution. We conducted a Case Study on an educational hackathon that took place in the online context, collecting data through questionnaires, interviews, and observations. As some results, the skills that students most considered that this hackathon helped them to develop were communication, initiative, and creativity/innovation, among others. Also, the strategies of collaboration adopted by the students during this competition, considering the remote context. Therefore, the main contribution is the identification of how the realization of this event supported students to develop professional skills and to practice collaboration skills with each other.;;;https://dl.acm.org/doi/10.1145/3474624.3476973;;;Software AND Engineering
Tell me: Am I going to Heaven? A Diagnosis Instrument of Continuous Software Engineering Practices Adoption;;;['Paulo Sérgio dos Santos Júnior', 'Monalessa Perini Barcellos', 'Fabiano Borges Ruy'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Context: Continuous Software Engineering (CSE) involves a set of practices that aims at making software development continuous and integrated to business. However, moving from traditional to integrated, agile and data-driven software development requires changes in the organization´s culture, practices and structure, which may not be easy. Objective: Our focus is to help organizations get an overall view of the CSE practices they perform, identify where they are in the CSE evolutionary path and which areas should be improved. Method: We created a diagnosis instrument, called Zeppelin, to evaluate the adoption of CSE practices and applied it in five Brazilian software organizations. Results: Zeppelin was recognized as a useful tool to help organizations have a more comprehensive view of their CSE practices and envision the evolution and improvement path they can follow. Conclusion: Zeppelin supports software development organizations to get a big picture of CSE practices and identify their position in the CSE evolution path. Moreover, it contributes to identify strategies to advance software development towards a CSE environment.;;;https://dl.acm.org/doi/10.1145/3463274.3463324;;;Software AND Engineering
Variability realization in model-based system engineering using software product line techniques: an industrial perspective;;;['Andreas Schäfer', 'Martin Becker', 'Markus Andres', 'Tim Kistenfeger', 'Florian Rohlf'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;Efficiently handling system variants is rising of importance in industry and challenges the application of model-based systems engineering. This paper reveals the increasing industrial demand of guidance and decision support on how to handle variants and variability within SysML and UML models. While a substantial amount of variability realization approaches has already been published on source code level, there is little guidance for practitioners on system model level. Hence, there is major uncertainty in dealing with system changes or concurrent system modeling of related system. Due to a poor modularization and variability realization these model variants are ending up in interwoven and complex system models. In this paper, we aim to raise awareness of the need for appropriate guidance and decision support, identify important contextual factors of MBSE that influence variability realization, and derive well known variability mechanisms used in software coding for their applicability in system modeling.;;;https://dl.acm.org/doi/10.1145/3461001.3473060;;;Software AND Engineering
On the Reproducibility and Replicability of Deep Learning in Software Engineering;;;['Chao Liu', 'Cuiyun Gao', 'Xin Xia', 'David Lo', 'John Grundy', 'Xiaohu Yang'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Context: Deep learning (DL) techniques have gained significant popularity among software engineering (SE) researchers in recent years. This is because they can often solve many SE challenges without enormous manual feature engineering effort and complex domain knowledge.Objective: Although many DL studies have reported substantial advantages over other state-of-the-art models on effectiveness, they often ignore two factors: (1) reproducibility—whether the reported experimental results can be obtained by other researchers using authors’ artifacts (i.e., source code and datasets) with the same experimental setup; and (2) replicability—whether the reported experimental result can be obtained by other researchers using their re-implemented artifacts with a different experimental setup. We observed that DL studies commonly overlook these two factors and declare them as minor threats or leave them for future work. This is mainly due to high model complexity with many manually set parameters and the time-consuming optimization process, unlike classical supervised machine learning (ML) methods (e.g., random forest). This study aims to investigate the urgency and importance of reproducibility and replicability for DL studies on SE tasks.Method: In this study, we conducted a literature review on 147 DL studies recently published in 20 SE venues and 20 AI (Artificial Intelligence) venues to investigate these issues. We also re-ran four representative DL models in SE to investigate important factors that may strongly affect the reproducibility and replicability of a study.Results: Our statistics show the urgency of investigating these two factors in SE, where only 10.2% of the studies investigate any research question to show that their models can address at least one issue of replicability and/or reproducibility. More than 62.6% of the studies do not even share high-quality source code or complete data to support the reproducibility of their complex models. Meanwhile, our experimental results show the importance of reproducibility and replicability, where the reported performance of a DL model could not be reproduced for an unstable optimization process. Replicability could be substantially compromised if the model training is not convergent, or if performance is sensitive to the size of vocabulary and testing data.Conclusion: It is urgent for the SE community to provide a long-lasting link to a high-quality reproduction package, enhance DL-based solution stability and convergence, and avoid performance sensitivity on different sampled data.;;;https://dl.acm.org/doi/10.1145/3477535;;;Software AND Engineering
Research on the Cultivation of Software Engineering Graduates’ Scientific Research Ability Based on Whole Process Control and Management;;;['Ming Yin', 'Zhixin Song', 'Jiao Hu'];;;December 2021;;;ICETM '21: Proceedings of the 2021 4th International Conference on Education Technology Management;;;The cultivation of graduates’ scientific research ability is not only related to their scientific research and innovation abilities, but also related to the quality of graduate education in China. The cultivation process for the traditional software engineering graduates’ scientific research ability pays more attention to graduates’ capability in engineering application. However, under the background of world First class universities and disciplines construction in China, more emphasis should be placed on cultivating graduates’ scientific research and innovation capabilities. In this paper, the scientific research ability of software engineering graduates has been divided into multiple dimensions, including solid professional foundation, the ability to discover problems, the ability to analyze and solve problems, the ability to express the opinions of scientific research and comprehensive scientific research literacy. We propose a scientific research ability cultivating system for software engineering graduates oriented to whole process control and management, and implement it with seven graduates majoring in software engineering as cases. The results show that compared with the previous graduates’ cultivation, the scientific research ability of graduates in 2020 has been improved faster in all aspects. The system achieves relatively satisfactory results.;;;https://dl.acm.org/doi/10.1145/3510309.3510349;;;Software AND Engineering
The Training Mode of Iterated Software Engineering Talents under the Background of Emerging Engineering Education;;;['Zijiang Zhu', 'Weihuang Dai', 'Yi Hu', 'Junshan Li'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;In order to adapt to the new situation of international competition and the new demand of strategic development, Emerging Engineering Education (3E) is the new direction of China's engineering education reform. Based on the analysis of the characteristics of software engineering major, this paper discusses the current predicament of software engineering talent training, and puts forward the model of iterative software engineering talent training under the background of 3E. This mode is implemented in three stages in teaching arrangement: iterative advancement in teaching objectives, project-centered practice teaching, and curriculum group mode in teaching organization. This mode practices the idea of industry-university cooperation in educating people, supports the natural extension of "integration of the core and master programs" in the mode expansion, and has been widely recognized in the practical talent training.;;;https://dl.acm.org/doi/10.1145/3456887.3456902;;;Software AND Engineering
Requirement Engineering Challenges for Social Sector Software Development: Insights from Multiple Case Studies;;;['Varun Gupta'];;;None;;;Digital Government: Research and Practice;;;Diversity is a great challenge for software engineers in the social sector context. The objective of this paper is to contribute to the identification of the RE processes and associated challenges in releasing the software in the social sector markets for which an exploratory case study is conducted. The outcome of the case study indicates that the diversity limits the ability to involve the representative samples of user populations using the same set of RE tools and techniques as one size fits all solution for all segments. The diverse user base must be partitioned into different segments, with each segment triggered using a suitable set of RE techniques i.e., traditional and crowd-based RE. The diverse perspectives learned as a result of the interaction with each segment, must be merged together into a single perspective about the software meant to be used in the social sector. There is a need for a new RE process specially designed for handling the complexities of the social sector, which this paper terms as Social Sector Requirement Engineering (SSRE). There is an increased need for collaboration between government social sector institutions and software engineers to get access to diverse customers to improve software quality.;;;https://dl.acm.org/doi/10.1145/3479982;;;Software AND Engineering
Authorship attribution of source code: a language-agnostic approach and applicability in software engineering;;;['Egor Bogomolov', 'Vladimir Kovalenko', 'Yurii Rebryk', 'Alberto Bacchelli', 'Timofey Bryksin'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Authorship attribution (i.e., determining who is the author of a piece of source code) is an established research topic. State-of-the-art results for the authorship attribution problem look promising for the software engineering field, where they could be applied to detect plagiarized code and prevent legal issues. With this article, we first introduce a new language-agnostic approach to authorship attribution of source code. Then, we discuss limitations of existing synthetic datasets for authorship attribution, and propose a data collection approach that delivers datasets that better reflect aspects important for potential practical use in software engineering. Finally, we demonstrate that high accuracy of authorship attribution models on existing datasets drastically drops when they are evaluated on more realistic data. We outline next steps for the design and evaluation of authorship attribution models that could bring the research efforts closer to practical use for software engineering.;;;https://dl.acm.org/doi/10.1145/3468264.3468606;;;Software AND Engineering
Identifying Non-Technical Skill Gaps in Software Engineering Education: What Experts Expect But Students Don’t Learn;;;['Wouter Groeneveld', 'Joost Vennekens', 'Kris Aerts'];;;None;;;ACM Transactions on Computing Education;;;As the importance of non-technical skills in the software engineering industry increases, the skill sets of graduates match less and less with industry expectations. A growing body of research exists that attempts to identify this skill gap. However, only few so far explicitly compare opinions of the industry with what is currently being taught in academia. By aggregating data from three previous works, we identify the three biggest non-technical skill gaps between industry and academia for the field of software engineering: devoting oneself to continuous learning, being creative by approaching a problem from different angles, and thinking in a solution-oriented way by favoring outcome over ego. Eight follow-up interviews were conducted to further explore how the industry perceives these skill gaps, yielding 26 sub-themes grouped into six bigger themes: stimulating continuous learning, stimulating creativity, creative techniques, addressing the gap in education, skill requirements in industry, and the industry selection process. With this work, we hope to inspire educators to give the necessary attention to the uncovered skills, further mitigating the gap between the industry and the academic world.;;;https://dl.acm.org/doi/10.1145/3464431;;;Software AND Engineering
Implementing Search-Based Software Engineering Approaches with Nautilus;;;['Thiago do Nascimento Ferreira', 'Silvia Regina Vergilio', 'Marouane Kessentini'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Search-Based Software Engineering (SBSE) approaches adopt search-based techniques to solve Software Engineering (SE) optimization problems. Among these techniques, evolutionary algorithms are the most popular and successfully used, such as multi-objective evolutionary algorithms. However, some challenges still need to be addressed. Firstly, SE problems are complex and commonly impacted by many conflicting factors. In this context, the use of many-objective algorithms is necessary. Secondly, the users very often do not recognise the found solutions as feasible because these solutions are usually not generated considering the users’ needs and preferences. Thus, to deal properly with this situation, preference-based algorithms should be applied. Moreover, there are some practical issues regarding the choice of operators, evaluation of algorithms and visualization of solutions. Existing frameworks do not provide support to address these challenges. To overcome these limitations, we present Nautilus, an open-source Java web-platform tool that works with plugins to ease the addition of new problem instances, implementation of search operators and different multi and many-objective optimization algorithms, guided (or not) by human participation. This paper describes Nautilus-NRP, an extension implemented to address the Next Release Problem (NRP). NRP refers to the selection of requirements to be implemented in the next release of a software and is used to illustrate Nautilus’ main functionalities and how it can be extended to solve a SE problem. Link for the video: https://youtu.be/2dbwslTrvhg.;;;https://dl.acm.org/doi/10.1145/3474624.3476010;;;Software AND Engineering
Towards an Automated Classification Approach for Software Engineering Research;;;['Angelika Kaplan', 'Jan Keim'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;The rapid growth of software engineering research publications forces an amount of scholarly knowledge that needs to be managed, organized and communicated in digital libraries and scientific search engines. Thus, there is a need for classified papers to accomplish these tasks, but the classification process is cumbersome. Moreover, in case of new schemas, one would need to reclassify previously published research. We propose to automate the classification and present different possible techniques for doing so: Using natural language models, a rule-based approach, or an approach based on topic-labeling. In this proposal paper, we initially implemented a prototype for text classification of software engineering research papers.;;;https://dl.acm.org/doi/10.1145/3463274.3463358;;;Software AND Engineering
First International Workshop on Quantum Software Engineering (Q-SE 2020);;;['Rui Abreu', 'Shaukat Ali', 'Tao Yue'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;The First International Workshop on Quantum Software Engineering (Q-SE 2020), co-located with the 42nd International Conference on Software Engineering (ICSE 2020), was held between July 2 and July 3, 2020. The workshop was originally scheduled to be a physical event in May 2020. Due to the SARS-CoV-2, aligned with the main conference, the workshop was held virtually instead. This report summarizes the keynote speeches, the paper presentations in the workshop, and the ensuing discussions. IEEE and ACM publish the proceedings of the workshop as part of the ICSE 2020 Workshops Companion.;;;https://dl.acm.org/doi/10.1145/3448992.3449000;;;Software AND Engineering
Assessing internet software engineering, encouraging competitions;;;['Andrei Sukhov', 'Vivek S. Buzruk'];;;November 2021;;;Communications of the ACM;;;The Communications website, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmAndrei Sukhov considers the potential for reducing international tensions through competitive events, while Vivek S. Buzruk looks at the evolution of teaching Internet software engineering.;;;https://dl.acm.org/doi/10.1145/3484986;;;Software AND Engineering
About the Assessment of Grey Literature in Software Engineering;;;['Guglielmo De Angelis', 'Francesca Lonetti'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;There is an ongoing interest in the Software Engineering field for multivocal literature reviews including grey literature. However, at the same time, the role of the grey literature is still controversial, and the benefits of its inclusion in systematic reviews are object of discussion. Some of these arguments concern the quality assessment methods for grey literature entries, which is often considered a challenging and critical task. On the one hand, apart from a few proposals, there is a lack of an acknowledged methodological support for the inclusion of Software Engineering grey literature in systematic surveys. On the other hand, the unstructured shape of the grey literature contents could lead to bias in the evaluation process impacting on the quality of the surveys. This work leverages an approach on fuzzy Likert scales, and it proposes a methodology for managing the explicit uncertainties emerging during the assessment of entries from the grey literature. The methodology also strengthens the adoption of consensus policies that take into account the individual confidence level expressed for each of the collected scores.;;;https://dl.acm.org/doi/10.1145/3463274.3463362;;;Software AND Engineering
Emerging Software Engineering Research Networks in (East) Africa;;;['Engineer Bainomugisha', 'Regina Hebig', 'Michel R. V. Chaudron'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;Software engineering (SE) researchers and research networks from emerging communities are often not visible in already established Software Engineering venues for a multitude of reasons. This limits the opportunities and mutual bene ts that can arise from collaborations between global and emerging Software Engineer- ing networks. This article focuses on a rst attempt to provide a map of the African software engineering research community with focus on the networks of two big East African Universities. We hope that this very initial mapping e ort will help to raise aware- ness in the international community about the variety of software engineering research in Africa. We formulate some suggestions for making our academic Software Engineering community more inclusive.;;;https://dl.acm.org/doi/10.1145/3448992.3448996;;;Software AND Engineering
Simulation-supported engineering of self-adaptive software systems;;;['Tom Meyer', 'Andreas Ruscheinski', 'Pia Wilsdorf', 'Adelinde M. Uhrmacher'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;Engineering a self-adaptive software system is challenging. During design- as well as run-time, assurance cases are central for ensuring reliable operation of the software. Simulation, in addition to software verification and testing, is a viable means to provide evidence for assurance cases. So far, little attention has been given to the development of underlying simulation models. Here, we argue that a systematic approach to develop simulation models will enhance the overall engineering process and will contribute to seamless integration of simulation and engineering processes. In our approach, we relate an explicit representation of the conceptual model and simulation experiments to artifacts of the engineering process. We will show first steps of applying our approach in a concrete ongoing software project for medical diagnosis, and discuss the role of components of the conceptual model in designing the software as a self-adaptive software system.;;;https://dl.acm.org/doi/10.5555/3522802.3522833;;;Software AND Engineering
Unit Test Smells and Accuracy of Software Engineering Student Test Suites;;;['Kevin Buffardi', 'Juan Aguirre-Ayala'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;With an increasing emphasis on unit testing in computer science curricula, we examined students' work on testing assignments to investigate their adoption of test smells---practices that indicate potential problems in unit tests. We discovered three common causes of test smells in students' unit tests: multiple member function calls, multiple assertions, and conditional logic. We also explored how each might be associated with test inaccuracies. In a quasi-experimental study, we evaluated the quality of students' unit tests by evaluating test accuracy---tests' reliability in distinguishing between a corpus of acceptable production code and a separate corpus containing faults. Correlational and comparative analyses revealed that unit tests with calls to multiple member functions and/or conditional logic were associated with worse test accuracy. However, no relationship was found between test accuracy and whether or not unit tests contained multiple assertions.;;;https://dl.acm.org/doi/10.1145/3430665.3456328;;;Software AND Engineering
The Language of Engineering: Training a Domain-Specific Word Embedding Model for Engineering;;;['DANIEL BRAUN', 'OLEKSANDRA KLYMENKO', 'TIM SCHOPF', 'YUSUF KAAN AKAN', 'FLORIAN MATTHES'];;;April 2021;;;MSIE '21: Proceedings of the 2021 3rd International Conference on Management Science and Industrial Engineering;;;Since the introduction of Word2Vec in 2013, so-called word embeddings, dense vector representation of words that are supposed to capture their semantic meaning, have become a universally applied technique in a wide range of Natural Language Processing (NLP) tasks and domains. The vector representations they provide are learned on huge corpora of unlabeled text data. Due to the large amount of data and computing power that is necessary to train such embedding models, very often, pre-trained models are applied which have been trained on domain unspecific data like newspaper articles or Wikipedia entries. In this paper, we present a domain-specific embedding model that is trained exclusively on texts from the domain of engineering. We will show that such a domain-specific embeddings model performs better in different NLP tasks and can therefore help to improve NLP-based AI in the domain of Engineering.;;;https://dl.acm.org/doi/10.1145/3460824.3460826;;;Software AND Engineering
The Connection between the Sustainability Impacts of Software Products and the Role of Software Engineers;;;['Dominic Lammert'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Context: It is impossible to imagine our everyday and professional lives without software. Consequently, software products, especially socio-technical systems, have more or less obvious impacts on almost all areas of our society. For this purpose, a group of scientists worldwide has developed the Sustainability Awareness Framework (SusAF) which examines the impacts on five interrelated dimensions: social, individual, environmental, economic, and technical. According to this framework, we should design software to maintain or improve the Sustainability Impacts. Designing for sustainability is a major challenge that can profoundly change the field of activity – particular for Software Engineers.  Objectives: The aim of the thesis work is to analyze the current role of Software Engineers and relate it to Sustainability Impacts of Software Products in order to contribute to this paradigm shift. This should provide a basis for follow-up works. The question in which direction exactly the Software Engineer should develop and how exactly this path can be followed is still owed by the scientific community. Perhaps universities will have to adapt the curriculum in the training of Software Engineers, politics could possibly initiate support programs in the field of sustainability for software companies, or maybe software sustainability certifications could emerge. In any case, Software Engineers must adapt to the times and acquire the necessary knowledge, the skills and the competencies.  Results: The results of the dissertation are a better understanding of the needed paradigm shift of Software Engineers and complement the SusAF that to better support sustainability design. The extended SusAF is intended for both training and corporate use.;;;https://dl.acm.org/doi/10.1145/3463274.3463346;;;Software AND Engineering
Investigating the potential impact of values on requirements and software engineering;;;['Alistair Sutcliffe', 'Pete Sawyer', 'Wei Liu', 'Nelly Bencomo'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;This paper describes an investigation into value-based software engineering and proposes a comprehensive value taxonomy with interpretation of design feature implications. The value taxonomy is used to assess the design of Covid-19 symptom tracker applications, contrasting the UK's NHS phase 1 and 2 designs which adopted centralized, then decentralized, architectures. The value/feature analysis is also applied to the King's/Zoe Covid app which does not detect proximity, instead relying on user self-reporting. Value analysis illuminated design choices but was insufficient to account for download acceptance of the apps. We argue that motivational cost-benefit analysis needs to complement a values-based approach.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00013;;;Software AND Engineering
Trust in Collaborative Automation in High Stakes Software Engineering Work: A Case Study at NASA;;;['David Gray Widder', 'Laura Dabbish', 'James D. Herbsleb', 'Alexandra Holloway', 'Scott Davidoff'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;The amount of autonomy in software engineering tools is increasing as developers build increasingly complex systems. We study factors influencing software engineers’ trust in an autonomous tool situated in a high stakes workplace, because research in other contexts shows that too much or too little trust in autonomous tools can have negative consequences. We present the results of a ten week ethnographic case study of engineers collaborating with an autonomous tool to write control software at the National Aeronautics and Space Administration to support high stakes missions. We find that trust in an autonomous software engineering tool in this setting was influenced by four main factors: the tool’s transparency, usability, its social context, and the organization’s associated processes. Our observations lead us to frame trust as a quality the operator places in their collaboration with the automated system, and we outline implications of this framing and other results for researchers studying trust in autonomous systems, designers of software engineering tools, and organizations conducting high stakes work with these tools.;;;https://dl.acm.org/doi/10.1145/3411764.3445650;;;Software AND Engineering
Engineering Model-Based Software Testing of WIMP Interactive Applications: A Process based on Formal Models and the SQUAMATA Tool;;;['Alexandre Canny', 'Célia Martinie', 'David Navarre', 'Philippe Palanque', 'Eric Barboni', 'Christine Gris'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;The goal of software testing is to detect defects with the objective of removing them at a later stage in the development process. Interactive software development follows the User Centered Design approach that promotes continuous involvement of users both at design and evaluation phases. This process is meant to produce usable interactive software by gathering functional and non-functional requirements related to both user needs and context of use. However, taking into account these potentially very-complex-to-implement requirements increases the complexity of the software that is likely, without appropriate methods and tools, to encompass a large number of defects. One of the limitations of UCD approaches is that it provides no guidance on the engineering of the interactive application, which thus usually embeds numerous defects resulting in failures at the origin of user frustrations and performance drops. Even though a classification of interactive application defects has been proposed, interactive application testers remain only superficially supported in detecting them. This paper defines a model-based approach to engineer the testing activity for interactive applications. It proposes a process that bridges the gap between UCD artefacts and interactive software implementation by the production of a dedicated formal model exploited for testing purposes only. The application of the process is demonstrated on an interactive cockpit WIMP application. Finally, threats to validity (capability of the approach to detect defects and to ensure an acceptable coverage testing of the interactive application) are addressed by a longitudinal study on 61 variants of a simple application developed by 61 different developers. ?;;;https://dl.acm.org/doi/10.1145/3461729;;;Software AND Engineering
Domain adaptation for an automated classification of deontic modalities in software engineering contracts;;;['Vivek Joshi', 'Preethu Rose Anish', 'Smita Ghaisas'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Contracts are agreements between parties engaging in economic transactions. They specify deontic modalities that the signatories should be held responsible for and state the penalties or actions to be taken if the stated agreements are not met. Additionally, contracts have also been known to be source of Software Engineering (SE) requirements. Identifying the deontic modalities in contracts can therefore add value to the Requirements Engineering (RE) phase of SE. The complex and ambiguous language of contracts make it difficult and time-consuming to identify the deontic modalities (obligations, permissions, prohibitions), embedded in the text. State-of-art neural network models are effective for text classification; however, they require substantial amounts of training data. The availability of contracts data is sparse owing to the confidentiality concerns of customers. In this paper, we leverage the linguistic and taxonomical similarities between regulations (available abundantly in the public domain) and contracts to demonstrate that it is possible to use regulations as training data for classifying deontic modalities in real-life contracts. We discuss the results of a range of experiments from the use of rule-based approach to Bidirectional Encoder Representations from Transformers (BERT) for automating the classification of deontic modalities. With BERT, we obtained an average precision and recall of 90% and 89.66% respectively.;;;https://dl.acm.org/doi/10.1145/3468264.3473921;;;Software AND Engineering
An interview study of how developers use execution logs in embedded software engineering;;;['Nan Yang', 'Pieter Cuijpers', 'Ramon Schiffelers', 'Johan Lukkien', 'Alexander Serebrenik'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Execution logs capture the run-time behavior of software systems. To assist developers in their maintenance tasks, many studies have proposed tools to analyze execution information from logs. However, it is as yet unknown how industry developers analyze logs in embedded software engineering. In order to bridge the gap, we study how developers analyze logs by interviewing 25 software developers from ASML, which is a leading company in developing lithography machines. In particular, we explore the type of logs developers analyze, the purposes for which developers analyze logs, the information developers need from logs and their expectation on tool support. As the main contribution, we observed that the lack of domain knowledge, lack of familiarity with code base and software design, and presence of concurrency, raise major challenges in log analysis for such complex and multidisciplinary systems. Particularly, we observed that inspecting execution information at different levels of abstraction is useful to develop comprehension of such complex systems. However, obtaining the abstraction is difficult with current tools. Our study has several implications. The empirical evidence provided by our study implies the need to support log inspection and comparison with multiple levels of abstraction, categorize log differences, and recover links between different types of logs.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00015;;;Software AND Engineering
Evaluation of the application of gamification in the discipline of Software Engineering in times of pandemic;;;['Vitor Castro', 'Adam Santos'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The new coronavirus pandemic promoted structural changes in society due to the need to elevate social isolation to the extreme. In this context, the majority of educational institutions have chosen to continue their activities remotely. One of the strategies used to engage students with academic activities is the use of gamification. Due to the new scenario, driven by the pandemic, this study aims to present and evaluate the application of gamification by comparing its use in the remote and in-person contexts, as well as the necessary adaptations for the new scenario. The comparison took place between two Software Engineering classes, one being in-person and the other in remote format. As initial results, a positive evaluation related to the application of the game was achieved, greater than 80% for the two teaching formats.;;;https://dl.acm.org/doi/10.1145/3474624.3476975;;;Software AND Engineering
Pains and Gains of Peer-Reviewing in Software Engineering (5);;;['Jacopo Soldani'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;ACM SIGSOFT SEN's column on "Pains and Gains of Peer-Reviewing in Software Engineering" aims at fostering an open, constructive, and lively discussion on the peer-reviewing currently adopted by SE venues, e.g., how to further enhance them and make them sustainable on the long run. This fifth editorial introduces a new contribution to the column, which provides a journal-centric perspective on the topic.;;;https://dl.acm.org/doi/10.1145/3468744.3468747;;;Software AND Engineering
Inclusion and Exclusion Criteria in Software Engineering Tertiary Studies: A Systematic Mapping and Emerging Framework;;;['Dolors Costal', 'Carles Farré', 'Xavier Franch', 'Carme Quer'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Context: Tertiary studies in software engineering (TS@SE) are widely used to synthesise evidence on a research topic systematically. As part of their protocol, TS@SE define inclusion and exclusion criteria (IC/EC) aimed at selecting those secondary studies (SS) to be included in the analysis. Aims: To provide a state of the art on the definition and application of IC/EC in TS@SE, and from the results of this analysis, we outline an emerging framework, TSICEC, to be used by SE researchers. Method: To provide the state of the art, we conducted a systematic mapping (SM) combining automatic search and snowballing over the body of SE scientific literature, which led to 50 papers after application of our own IC/EC. The extracted data was synthesised using content analysis. The results were used to define a first version of TSICEC. Results: The SM resulted in a coding schema, and a thorough analysis of the selected papers on the basis of this coding. Our TSICEC framework includes guidelines for the definition of IC/EC in TS@SE. Conclusion: This paper is a step forward establishing a foundation for researchers in two ways. As authors, understanding the different possibilities to define IC/EC and apply them to select SS. As readers, having an instrument to understand the methodological rigor upon which TS@SE may claim their findings.;;;https://dl.acm.org/doi/10.1145/3475716.3484190;;;Software AND Engineering
Delivering Round-the-Clock Help to Software Engineering Students Using Discord: An Experience Report;;;['Kathryn Bridson', 'Jeffrey Atkinson', 'Scott D. Fleming'];;;February 2022;;;SIGCSE 2022: Proceedings of the 53rd ACM Technical Symposium on Computer Science Education - Volume 1;;;This experience report describes the delivery of round-the-clock help to students using Discord (a popular messaging and voice/video calling platform) in a remote software engineering course. Students in the course learn full-stack web development using Ruby on Rails and PostgreSQL, and work in teams to develop web applications. Our central goal in offering round-the-clock help using Discord was to increase the amount of help that students receive from teachers (i.e., teaching assistants and the instructor). Indeed, we found that our 24/7-Discord approach led to a considerable increase in the amount of student-teacher interaction versus the approach used previously, which emphasized in-person office hours and a question-and-answer forum in Piazza. Moreover, students from underrepresented groups in computer science interacted with teachers at a rate comparable to other students, and we received consistently positive feedback from students regarding the approach. We also made several key observations about when students tended to seek help, including that they sought help the most between 7:00 p.m. and midnight, that help seeking spiked right before deadlines, that students posted the fewest help messages on weekends, and that students posted significantly more messages during the first half of the course, which emphasized skills assignments, versus the second half, which focused on team project work.;;;https://dl.acm.org/doi/10.1145/3478431.3499385;;;Software AND Engineering
Software Engineering Education for the Next Generation SEENG 2021 Workshop Report;;;['Cécile Péraire', 'Stephan Krusche'];;;January 2022;;;ACM SIGSOFT Software Engineering Notes;;;The 3rd International Workshop on Software Engineering Education for the Next Generation was held remotely on May 24, 2021. The workshop was an integral component of the Joint Track on Software Engineering Education and Training at the 43rd International Conference on Software Engineering. It specifically supported the general theme of "Educating the Next Generation of Software Engineers". Building on its predecessors, the workshop used a highly interactive format, structured around eight short paper presentations to generate discussion topics, an activity to select the most interesting topics, and structured breakout sessions to allow participants to discuss those topics in detail. Participants presented the results of the breakout sessions using mind maps.;;;https://dl.acm.org/doi/10.1145/3502771.3502778;;;Software AND Engineering
Pains and Gains of Peer Reviewing in Software Engineering: A Journal-Centric Perspective;;;['Nenad Medvidović'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;A young software engineering researcher is invited to be an associate editor (AE) of a major journal in our field. The researcher is very excited. By this point, she has amassed a nice career track-record. She has also been recognized via a number of invitations to serve on our conferences' program committees. But this somehow feels different and more important: there are multiple conferences each year, and all of them have PCs staffed with dozens of members (not uncommonly over 100 in recent years), while there are comparatively fewer journals and, at any point in time, the sizes of their editorial boards are a fraction of a typical conference PC. This is a major additional sign of recognition of the young researcher's expertise and stature in the community. So, the researcher quickly and enthusiastically accepts the invitation.;;;https://dl.acm.org/doi/10.1145/3468744.3468748;;;Software AND Engineering
Recognition Of Learners’ Personality Traits For Software Engineering Education;;;['Bin Xu', 'Qiaoqiao Zhang', 'Kening Gao', 'Ge Yu', 'Zhaowu Zhang', 'Yidi Du'];;;July 2021;;;ACM TURC '21: Proceedings of the ACM Turing Award Celebration Conference - China;;;It is vital for educators to teach learners in accordance with their aptitude, which can be useful to help learners reach their full potential. Educators have been taking the Myers-Briggs Type Indicator (MBTI) as a powerful tool to understand the differences in students’ learning styles, adopting appropriate teaching strategies to accommodate the learning styles of different types of students can effectively prevent students from being tired of studying. It is a problem worthy of research to recognize the students’ personality traits with technological means. Therefore, we propose a method to recognize learners’ MBTI from videos, which can be applied in the course learning and practice stages of software engineering education. We propose a novel approach to recognize the MBTI personality traits of learners from videos. Personality and emotion unconsciously affect facial expression, the speaking style in social contexts. However, in the current literature, there is no publicly available source of images dataset labeled with the MBTI personality scale; nearly all the available data are text. In this paper, we use two datasets: images extracted from ChaLearn First Impressions dataset and the Myer-Briggs Personality Type Dataset from Kaggle for our training tasks. Furthermore, we take plentiful text data labeled with the MBTI personality scale as the source domain and image data as the target domain for borrowing knowledge from the source domain to facilitate the learning task in a target domain. By adopting feature transfer, a bridge is built between the source domain and the target domain. We perform experiments on the transfer task and evaluate the effectiveness of this approach, the results of this study can assist educators in regards to the identification of learners’ MBTI personality types in a new way.;;;https://dl.acm.org/doi/10.1145/3472634.3472636;;;Software AND Engineering
SMartyModeling: an instance of VMTools-RA for Engineering UML-based Software Product Lines;;;['Leandro F. Silva', 'Edson OliveiraJr'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Software Product Line (SPL) life cycle comprises a set of essential activities. Variability Management (VM) is one of its most important activities to the success of an SPL, especially those based on UML, as the solution space encompasses different diagrams and perspectives on variability. However, the lack of tools to support UML-based SPLs reflects difficulties in adopting this approach. This scenario motivated the development of SMartyModeling, an environment for engineering UML-based SPL. The SMartyModeling architecture was instantiated based on VMTools-RA, an existing reference architecture for software variability tools. VMTools-RA describes architectural requirements, elements and views on software variability, which aid one to instantiate variability tool architectures. The instantiation process started from the identification of requirements, selection of elements, modules, and visions of VMTools-RA, planning and design of the architectural solutions, implementation of modules and organization of features. We then analyzed the feasibility of adopting VMTools-RA for instantiating an specific tool architecture. In this sense, such instantiation is part of the development process of SMartyModeling, which includes the main activities related to VM. We also empirically evaluated SMartyModeling in three ways: (i) a field study to analyze the instantiation process and the decisions taken; (ii) a comparative experiment analyzing efficiency and effectiveness of SMartyModeling in relation to a general purpose UML tool; and (iii) an evaluation of aspects related to perceived ease of use and perceived usability. The results of such evaluations provide initial evidence VMTools-RA is feasible to instantiate specific architectures and SMartyModeling is feasible to support to VM for UML-based SPLs.;;;https://dl.acm.org/doi/10.1145/3493244.3493274;;;Software AND Engineering
Research on the Curriculum System of Software Engineering Specialty in Engineering Colleges in the Process of Transformation of New and Old Kinetic Energy;;;['Qihong Qin', 'Yutong Li'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;The transformation of old and new kinetic energy emphasizes that Chinese universities should actively set up and develop a number of new engineering majors on the one hand, and promote the reform and innovation of existing engineering majors on the other hand. The transformation of new and old kinetic energy is essentially the innovation and transformation of talent training mode. Software engineering is a course offered by most colleges and universities. However, each school's talent training program, specific implementation process and final training effect are different. Starting from the teaching practice of software engineering education, based on the analysis of international software engineering professional norms and teaching practice, this paper gives the curriculum system of software engineering major in engineering colleges, focuses on setting up the teaching concept of software engineering and cultivating the ability of software system construction, and discusses the innovative setting scheme of software engineering courses in detail, which can provide reference for international and domestic software engineering teaching plan designers.;;;https://dl.acm.org/doi/10.1145/3482632.3487547;;;Software AND Engineering
Vision for an Artefact-based Approach to Regulatory Requirements Engineering;;;['Oleksandr Kosenkov', 'Michael Unterkalmsteiner', 'Daniel Mendez', 'Davide Fucci'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Nowadays, regulatory requirements engineering (regulatory RE) faces challenges of interdisciplinary nature that cannot be tackled due to existing research gaps. Aims: We envision an approach to solve some of the challenges related to the nature and complexity of regulatory requirements, the necessity for domain knowledge, and the involvement of legal experts in regulatory RE. Method: We suggest the qualitative analysis of regulatory texts combined with the further case study to develop an empirical foundation for our research. Results: We outline our vision for the application of extended artefact-based modeling for regulatory RE. Conclusions: Empirical methodology is an essential instrument to address interdisciplinarity and complexity in regulatory RE. Artefact-based modeling supported by empirical results can solve a particular set of problems while not limiting the application of other methods and tools and facilitating the interaction between different fields of practice and research.;;;https://dl.acm.org/doi/10.1145/3475716.3484191;;;Software AND Engineering
Qualifying software engineers undergraduates in DevOps - challenges of introducing technical and non-technical concepts in a project-oriented course;;;['Isaque Alves', 'Carla Rocha'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;The constant changes in the software industry, practices, and methodologies impose challenges to teaching and learning current software engineering concepts and skills. DevOps is particularly challenging because it covers technical concepts, such as pipeline automation, and non-technical ones, such as team roles and project management. The present study investigates a course setup to introduce these concepts to software engineering undergraduates. We designed the course by employing coding to associate DevOps concepts to Agile, Lean, and Open source practices and tools. We present the main aspects of this project-oriented DevOps course, with 240 students enrolled it since its first offering in 2016. We conducted an empirical study, with both a quantitative and qualitative analysis, to evaluate this project-oriented course setup. We collected the data from the projects repository and students' perceptions from a questionnaire. We mined 148 repositories (corresponding to 72 projects) and obtained 86 valid responses to the questionnaire. We also mapped the concepts which are more challenging to students learn from experience. The results evidence that first-hand experience facilitates the comprehension of DevOps concepts and enriches classes discussions. we present a set of lessons learned, which may help professors better design and conduct project-oriented courses to cover DevOps concepts.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00024;;;Software AND Engineering
Software Engineering and AI for Data Quality in Cyber- Physical Systems - SEA4DQ'21 Workshop Report;;;['Phu H. Nguyen', 'Sagar Sen', 'Nicolas Jourdan', 'Beatriz Cassoli', 'Per Myrseth', 'Mikel Armendia', 'Odd Myklebust'];;;January 2022;;;ACM SIGSOFT Software Engineering Notes;;;Cyber-physical systems (CPS) have been developed in many industrial sectors and application domains in which the quality requirements of data acquired are a common factor. Data quality in CPS can deteriorate because of several factors such as sensor faults and failures due to operating in harsh and uncertain environments. How can software engineering and artificial intelligence (AI) help manage and tame data quality issues in CPS? This is the question we aimed to investigate in the SEA4DQ workshop. Emerging trends in software engineering need to take data quality management seriously as CPS are increasingly datacentric in their approach to acquiring and processing data along the edge-fog-cloud continuum. This workshop provided researchers and practitioners a forum for exchanging ideas, experiences, understanding of the problems, visions for the future, and promising solutions to the problems in data quality in CPS. Examples of topics include software/hardware architectures and frameworks for data quality management in CPS; software engineering and AI to detect anomalies in CPS data or to repair erroneous CPS data. SEA4DQ 2021, which took place on August 24th, 2021 was a satellite event of the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC / FSE) 2021. The workshop attracted 35 international participants and was exciting with a great keynote, six excellent presentations, and concluded on a high note with a panel discussion. SEA4DQ was motivated by the common research interests from the EU projects for Zero-Defects Manufacturing such as InterQ and Dat4.Zero.;;;https://dl.acm.org/doi/10.1145/3502771.3502781;;;Software AND Engineering
Requirements engineering in the pre-contract stage: exploring the processes and practices used in small and medium-sized software enterprises;;;['Tomas Vera', 'Sergio F. Ochoa', 'Daniel Perovich'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Performing requirements engineering (RE) during the pre-contract stage; i.e., at pre-selling time, is mandatory for software providers to conceive a project proposal and deliver a bid. In bespoke projects, this process requires that providers deal with several constraints that are usually not present in a regular RE process. For instance, the process must be done quickly, under a competition situation, and hopefully involving few resources since its cost is assumed by the provider. These constraints make this process unique, and different to the RE conducted at post-selling; i.e., during a project contract. Few is reported about the RE activities performed in practice by providers, the cost-effectiveness of the process, and the software practices used to support it. This article presents an exploratory study that uses a mixed method approach to gain knowledge on these aspects. The results indicate that providers assume this process as unstructured, context-aware, expert-based and with various possible outcomes. In part, these features are a consequence of the constraints imposed by the project pre-contract scenario. Moreover, the providers use regular RE practices to support this process, which usually ends up having a medium-low cost-effectiveness. These results show the need to perform more empirical research in this domain, and open several opportunities to propose new RE techniques and practices (or adjust the existing ones) to improve the cost-effectiveness of this process.;;;https://dl.acm.org/doi/10.1145/3412841.3442009;;;Software AND Engineering
Application of CAD Drawing Software in Civil Engineering Architectural Design and Structural Design;;;['Nan Li', 'Wenbin Gong'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;With the development of architectural design, people's requirements for building structure are constantly improving. Building structure has not only stayed on practical value, it has also integrated people's pursuit of art, society, and economic factors. The architectural structure is more flexible in design, rich in shapes, complex in structure and diverse in expression. Traditional architectural forms that rely solely on the designer's personal experience and subjective judgments have long been unable to meet the requirements of architectural structural design. Traditional experimental verification and manual analysis and design methods have also become difficult to meet the needs of modern engineering. A series of factors make the architectural structure in the design field, problems such as difficulty in design, low efficiency, and lengthened design and construction period have appeared. Changes in the market have also prompted changes in the field of architectural design. With the advancement of computer technology and its development in the field of architectural structural design, people are paying more and more attention to computer-aided development technology (CAD). CAD can improve the work efficiency of the designer, reduce the work of the designer, and is very helpful to improve the quality of the design. The purpose of this article is to study the application of computer CAD drawing software in civil engineering architectural design and structural design. Based on the application basis of computer-aided architectural design, this article first analyzes the advantages of computer design technology as the basic system structure of the building design graphics platform, and then takes the important position of architectural digital technology in the field of contemporary architecture, and finally realizes the CAD drawing software in civil engineering application of architectural design and structural design.;;;https://dl.acm.org/doi/10.1145/3495018.3495312;;;Software AND Engineering
Report from the 2nd Int. Workshop on Education through Advanced Software Engineering and Artificial Intelligence (EASEAI '20);;;['Benoît Vanderose', 'Julie Henry', 'Benoît Frénay', 'Xavier Devroey'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;In the past years, with the development and widespread of digi- tal technologies, everyday life has been profoundly transformed. The general public, as well as specialized audiences, have to face an ever-increasing amount of knowledge and learn new abilities. The EASEAI workshop series addresses that challenge by look- ing at software engineering, education, and arti cial intelligence research elds to explore how they can be combined. Speci cally, this workshop brings together researchers, teachers, and practi- tioners who use advanced software engineering tools and arti cial intelligence techniques in the education eld and through a trans- generational and transdisciplinary range of students to discuss the current state of the art and practices, and establish new future directions. More information at https://easeai.github.io.;;;https://dl.acm.org/doi/10.1145/3448992.3448999;;;Software AND Engineering
Automatic management analysis of computer software engineering project based on data mining;;;['Yan Wang'];;;December 2021;;;ICASIT 2021: 2021 International Conference on Aviation Safety and Information Technology;;;In recent years, with the continuous development of data technology, especially with the continuous improvement and research and development of software systems, software development has become a very complex system engineering. Because the backward software production method can't meet the increasing demand of computer software, a series of problems have appeared in the development and maintenance of software engineering. Software projects are different from other projects, and the general project management method can't be applied to all software project management. This paper puts forward the application of data mining in software engineering. Data mining is an interdisciplinary subject involving many fields, and it has many mature technologies. The quantitative analysis method of demand evolution influence based on data mining clusters the new demand and the existing demand of software projects, and puts forward corresponding strategies to solve them, thus improving the automation management level of computer software engineering.;;;https://dl.acm.org/doi/10.1145/3510858.3511421;;;Software AND Engineering
Research on Programming Technology of Computer Software Engineering Database Based on Multi-platform;;;['Jiaxiang Zheng'];;;December 2021;;;ICASIT 2021: 2021 International Conference on Aviation Safety and Information Technology;;;For computer software engineering, the important technical means of database programming should run through the whole process of safe operation of software engineering, aiming at using professional programming technology principles to edit database running programs, and then achieving the goal of ensuring the integrity and safety of database storage information. With the development of mobile computing technology, it appears or shows wide applications in many fields. Such as public information publishing, location-related query, mobile commerce, etc., all depend on the support of mobile database system. In order to improve the efficiency of computer software development and reduce the probability of software vulnerabilities and running errors, technicians are required to take necessary test methods in the process of development and design to realize the summary analysis of computer software information data. This paper expounds the existence value of computer database, analyzes the process of establishing computer database, and studies the database programming technology of computer software engineering based on multi-platform testing.;;;https://dl.acm.org/doi/10.1145/3510858.3511339;;;Software AND Engineering
On Ethically-Sensitive User Story Engineering;;;['Pankaj Kamthan', 'Nazlie Shahmir'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;The increasingly anthropomorphic, at times even autocratic, nature of software, exhibited during routine activities such as decision-making, question-answering, or recommending, has only contributed to the enduring issue of software ethics. This paper, after providing an understanding of the unique nature of software and that of ethicality, models ethicality as a meta-quality attribute and proposes an ethically-sensitive, standards-based, technology-and-tool-independent, applicable to software-as-a-product-or-service, semi-formal framework, comprising interrelated conceptual meta-models that provide an understanding of ethicality, user story environment, and user story process. It describes an approach of integrating ethicality naturally and systematically in the user story process, illustrates this approach by means of representative examples from a variety of application domains, and highlights the associated challenges in doing so. It also presents the results of a preliminary survey of students and professionals on their knowledge and experience of ethics in (agile) software projects. Finally, it outlines directions of research, and provides recommendations for those in academia and industry, which have broad implications for ethically-sensitive (agile) requirements engineering education and (agile) software testing.;;;https://dl.acm.org/doi/10.1145/3494885.3494899;;;Software AND Engineering
Report from the 3rd Int. Workshop on Education through Advanced Software Engineering and Artificial Intelligence (EASEAI '21);;;['Julie Henry', 'Upsorn Praphamontripong', 'Camelia Serban', 'Andreea Vescan'];;;January 2022;;;ACM SIGSOFT Software Engineering Notes;;;With the development and widespread of digital technologies, ev- eryday life has been profoundly transformed. The general public, as well as specialized audiences, have to face an ever-increasing amount of knowledge and learn new abilities. The EASEAI work- shop series addresses that challenge by looking at software en- gineering, education, and arti cial intelligence research elds to explore how they can be combined. Speci cally, this workshop brings together researchers, teachers, and practitioners who use advanced software engineering tools and arti cial intelligence tech- niques in the education eld and through a transgenerational and transdisciplinary range of students to discuss the current state of the art and practices, and establish new future directions. More information at https://easeai.github.io.;;;https://dl.acm.org/doi/10.1145/3502771.350279;;;Software AND Engineering
Teaching Design and Practice of Software Engineering Series Courses Based on OBE;;;['Linlin Tian', 'Yue Yang', 'Zhimin Han', 'Ke Yang', 'Lifang Shen'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;Taking the software engineering series courses of Shenyang Institute of technology as an example, this paper designs and practices the teaching process design, course teaching methods, curriculum evaluation methods and other elements. It emphasizes that the good teaching design, which is close to the needs of enterprises and centered on the development of students, can improve the classroom teaching and classroom quality from the perspective of training objectives, close to the needs of enterprises. This mechanism can be extended to other curriculum construction, cultivate high-quality and high-capacity applied talents, and make more contributions to regional economic development.;;;https://dl.acm.org/doi/10.1145/3456887.3457040;;;Software AND Engineering
Assessing Obsolescence of Software Engineers;;;['Alessandro Santos', 'Bruno Rocha', 'César França'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Unlike other professions, where knowledge and skills become obsolete more slowly, it is estimated that an IT professional will become obsolete in two years. Thus, the accurate assessment of technical skills can help software engineers to take the necessary actions to mitigate the risk of professional obsolescence. This work proposes a method to assess the degree of professional obsolescence, based on the concept of Participatory Sensing Network. To evaluate the proposed method, we collected data from 50 software engineers, and presented it to 9 professional recruiters to reach a measure of their actual employability. Then, we compared these data against the calculations of our algorithm. The results showed no significant difference between the traditional recruitment process and the proposed algorithm, which means that the algorithm can be an accurate surrogate for such employability assessment.;;;https://dl.acm.org/doi/10.1145/3474624.3477059;;;Software AND Engineering
SoK: Human, Organizational, and Technological Dimensions of Developers’ Challenges in Engineering Secure Software;;;['Azadeh Mokhberi', 'Konstantin Beznosov'];;;October 2021;;;EuroUSEC '21: Proceedings of the 2021 European Symposium on Usable Security;;;Despite all attempts to improve software security, vulnerabilities are still propagated within software. A growing body of research is looking into why developers are unable to develop secure software from the beginning. However, despite this attention, research efforts on developer challenges lack a coherent framework. We present a systematization of existing knowledge on the factors that make secure software development challenging for developers. We evaluated 126 papers to develop a framework of challenges that includes 17 areas of challenges in three dimensions of Human, Organizational, and Technological. These areas appear to influence each other directly and indirectly. Our work highlights the interplay of these areas and their consequences for secure software development. We discussed lessons learned from the framework, shed light on its role in assisting practitioners, and proposed directions for future research.;;;https://dl.acm.org/doi/10.1145/3481357.3481522;;;Software AND Engineering
Language Family Engineering with Product Lines of Multi-level Models;;;['Juan de Lara', 'Esther Guerra'];;;None;;;Formal Aspects of Computing;;;AbstractModelling is an essential activity in software engineering. It
typically involves two meta-levels: one includes meta-models that
describe modelling languages, and the other contains models built by
instantiating those meta-models.  Multi-level modelling generalizes this approach by allowing models to span an arbitrary
number of meta-levels. A scenario that profits from multi-level
modelling is the definition of language families that can be
specialized (e.g., for different domains) by successive refinements
at subsequent meta-levels, hence promoting language reuse. This
enables an  open set of variability options given by all
possible specializations of the language family. However,
multi-level modelling lacks the ability to express closed variability regarding the availability of language primitives or the
possibility to opt between alternative primitive realizations. This
limits the reuse opportunities of a language family. To improve this
situation, we propose a novel combination of product lines with
multi-level modelling to cover both open and closed variability. Our
proposal is backed by a formal theory that guarantees correctness,
enables top-down and bottom-up language variability design, and is
implemented atop the MetaDepth multi-level modelling tool.;;;https://dl.acm.org/doi/10.1007/s00165-021-00554-3;;;Software AND Engineering
The daily life of software engineers during the COVID-19 pandemic;;;['Daniel Russo', 'Paul H. P. Hanel', 'Seraphina Altnickel', 'Niels van Berkel'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Following the onset of the COVID-19 pandemic and subsequent lockdowns, software engineers' daily life was disrupted and abruptly forced into remote working from home. This change deeply impacted typical working routines, affecting both well-being and productivity. Moreover, this pandemic will have long-lasting effects in the software industry, with several tech companies allowing their employees to work from home indefinitely if they wish to do so. Therefore, it is crucial to analyze and understand how a typical working day looks like when working from home and how individual activities affect software developers' well-being and productivity. We performed a two-wave longitudinal study involving almost 200 globally carefully selected software professionals, inferring daily activities with perceived well-being, productivity, and other relevant psychological and social variables. Results suggest that the time software engineers spent doing specific activities from home was similar when working in the office. However, we also found some significant mean differences. The amount of time developers spent on each activity was unrelated to their well-being, perceived productivity, and other variables. We conclude that working remotely is not per se a challenge for organizations or developers.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00048;;;Software AND Engineering
Engineering Multi-Agent Systems: State of Affairs and the Road Ahead;;;['Viviana Mascardi', 'Danny Weyns', 'Alessandro Ricci'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;The continuous integration of software-intensive systems together with the ever-increasing computing power offer a breeding ground for intelligent agents and multi-agent systems (MAS) more than ever before. Over the past two decades, a wide variety of languages, models, techniques and methodologies have been proposed to engineer agents and MAS. Despite this substantial body of knowledge and expertise, the systematic engineering of large-scale and open MAS still poses many challenges. Researchers and engineers still face fundamental questions regarding theories, architectures, languages, processes, and platforms for designing, implementing, running, maintaining, and evolving MAS. This paper reports on the results of the 6th International Workshop on Engineering Multi-Agent Systems (EMAS 2018, 14th-15th of July, 2018, Stockholm, Sweden), where participants discussed the issues above focusing on the state of affairs and the road ahead for researchers and engineers in this area.;;;https://dl.acm.org/doi/10.1145/3310013.3310035;;;Software AND Engineering
On the Application of Computer CAD Drawing Software in Civil Engineering Architectural Design and Structural Design;;;['Xu Yao'];;;August 2021;;;ICIMTECH 21: <italic toggle='yes'>Retracted on September 15, 2021</italic>The Sixth International Conference on Information Management and Technology;;;NOTICE OF RETRACTION: While investigating potential publication-related misconduct in connection with the ICIMTech 2021 Conference Proceedings, serious concerns were raised that cast doubt on the integrity of the peer-review process and all papers published in the Proceedings of this Conference. The integrity of the entire Conference has been called into question. As a result, of its investigation, ACM has decided to retract the Entire Conference Proceedings and all related papers from the ACM Digital Library.None of the papers from this Proceeding should be cited in the literature because of the questionable integrity of the peer review process for this Conference.;;;https://dl.acm.org/doi/10.1145/3465631.3465816;;;Software AND Engineering
Natural Language Processing for Requirements Engineering: A Systematic Mapping Study;;;['Liping Zhao', 'Waad Alhoshan', 'Alessio Ferrari', 'Keletso J. Letsholo', 'Muideen A. Ajagbe', 'Erol-Valeriu Chioasca', 'Riza T. Batista-Navarro'];;;None;;;ACM Computing Surveys;;;Natural Language Processing for Requirements Engineering (NLP4RE) is an area of research and development that seeks to apply natural language processing (NLP) techniques, tools, and resources to the requirements engineering (RE) process, to support human analysts to carry out various linguistic analysis tasks on textual requirements documents, such as detecting language issues, identifying key domain concepts, and establishing requirements traceability links. This article reports on a mapping study that surveys the landscape of NLP4RE research to provide a holistic understanding of the field. Following the guidance of systematic review, the mapping study is directed by five research questions, cutting across five aspects of NLP4RE research, concerning the state of the literature, the state of empirical research, the research focus, the state of tool development, and the usage of NLP technologies. Our main results are as follows: (i) we identify a total of 404 primary studies relevant to NLP4RE, which were published over the past 36 years and from 170 different venues; (ii) most of these studies (67.08%) are solution proposals, assessed by a laboratory experiment or an example application, while only a small percentage (7%) are assessed in industrial settings; (iii) a large proportion of the studies (42.70%) focus on the requirements analysis phase, with quality defect detection as their central task and requirements specification as their commonly processed document type; (iv) 130 NLP4RE tools (i.e., RE specific NLP tools) are extracted from these studies, but only 17 of them (13.08%) are available for download; (v) 231 different NLP technologies are also identified, comprising 140 NLP techniques, 66 NLP tools, and 25 NLP resources, but most of them—particularly those novel NLP techniques and specialized tools—are used infrequently; by contrast, commonly used NLP technologies are traditional analysis techniques (e.g., POS tagging and tokenization), general-purpose tools (e.g., Stanford CoreNLP and GATE) and generic language lexicons (WordNet and British National Corpus). The mapping study not only provides a collection of the literature in NLP4RE but also, more importantly, establishes a structure to frame the existing literature through categorization, synthesis and conceptualization of the main theoretical concepts and relationships that encompass both RE and NLP aspects. Our work thus produces a conceptual framework of NLP4RE. The framework is used to identify research gaps and directions, highlight technology transfer needs, and encourage more synergies between the RE community, the NLP one, and the software and systems practitioners. Our results can be used as a starting point to frame future studies according to a well-defined terminology and can be expanded as new technologies and novel solutions emerge.;;;https://dl.acm.org/doi/10.1145/3444689;;;Software AND Engineering
LabelUX! Guidelines to support software engineers to design data labeling systems;;;['Leticia Carvalho Passos', 'Lucas Viana', 'Edson Oliveira', 'Tayana Conte'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;The demand for systems using artificial intelligence has substantially boosted in recent times, especially with Machine Learning (ML) techniques. Systems that use ML supervision techniques need representative and correctly categorized data to ensure its quality. In this context, a data labeling step plays a fundamental role during the development of such systems. The labeling is performed by users specialized in the data domain and aims to generate a database to enable a supervised ML model. However, labeling is exhausting for users, which can compromise the quality of the ML system, especially if the labeling is being done on systems that were not designed to assist the user in this activity. On the one hand, it can be difficult for a software engineer to design these kinds of systems. Depending on the type of data to be labeled, the interface needs different graphics and strategies to present and request user feedback. Aiming to help software engineers develop these kinds of systems, this work proposes the LabelUX guidelines. These guidelines aim to support software engineers in designing data labeling systems, defining a design with quality that provides a better user experience during the labeling task. We developed these guidelines from studies carried out in the literature and industry. We selected software engineers working on ML projects to participate in a feasibility study to evaluate the use of guidelines. The qualitative results obtained through the interview improved that the LabelUX guidelines supported a better design of textual type data labeling systems.;;;https://dl.acm.org/doi/10.1145/3493244.3493252;;;Software AND Engineering
Towards supporting SPL engineering in low-code platforms using a DSL approach;;;['Alexandre Bragança', 'Isabel Azevedo', 'Nuno Bettencourt', 'Carlos Morais', 'Diogo Teixeira', 'David Caetano'];;;October 2021;;;GPCE 2021: Proceedings of the 20th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;;;Low-code application platforms enable citizen developers to autonomously build complete applications, such as web applications or mobile applications. Some of these platforms also offer support for reuse to facilitate the development of similar applications. The offered mechanisms are usually elementary, they allow module reuse or building a new application from a template. However, they are insufficient to achieve the industrial level reuse necessary for software product lines (SPL). In fact, these platforms were conceived to help build standalone applications, not software families and even fewer software product lines. In this paper, we argue that the major limitation is that these platforms seldom provide access to their metamodel, the access to applications’ models and code is also limited and, therefore, makes it harder to analyze commonality and variability and construct models based on it. An approach is proposed to surpass these limitations: firstly, a metamodel of the applications built with the platform is obtained, and then, based on the metamodel, a domain-specific language (DSL) that can express the models of the applications, including variability, is constructed. With this DSL, users can combine and reuse models from different applications to explore and build similar applications. The solution is illustrated with an industrial case study. A discussion of the results is presented as well as its limitations and related work. The authors hope that this work provides inspiration and some ideas that the community can explore to facilitate the adoption and implementation of SPLs in the context, and supported by, low-code platforms.;;;https://dl.acm.org/doi/10.1145/3486609.3487196;;;Software AND Engineering
Team-oriented consistency checking of heterogeneous engineering artifacts;;;['Michael Alexander Tröls', 'Atif Mashkoor', 'Alexander Egyed'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Consistency checking of interdependent heterogeneous engineering artifacts, such as requirements, specifications, and code, is a challenging task in large-scale engineering projects. The lack of team-oriented solutions allowing a multitude of project stakeholders to collaborate in a consistent manner is thus becoming a critical problem. In this context, this work proposes an approach for team-oriented consistency checking of collaboratively developed heterogeneous engineering artifacts.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00116;;;Software AND Engineering
Teaching model-based requirements engineering to industry professionals: an experience report;;;['Marian Daun', 'Jennifer Brings', 'Marcel Goger', 'Walter Koch', 'Thorsten Weyer'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;The use of conceptual models to foster requirements engineering has been proposed and evaluated as beneficial for several decades. For instance, goal-oriented requirements engineering or the specification of scenarios are commonly done using conceptual models. Bringing such model-based requirements engineering approaches into industrial practice typically requires industrial training. In this paper, we report lessons learned from a training program for teaching industry professionals modelbased requirements engineering. Particularly, we as educators and learners report experiences from designing the training program, conducting the actual training, and applying the instructed material in our day-to-day work. From these findings we provide guidelines for educators designing requirements engineering courses for industry professionals.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00013;;;Software AND Engineering
Model analysis in Computer Technology in Engineering Management;;;['Yuling Huang', 'Chaoqun Leng', 'Liping Zhan'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;At present, computer technology is also changing in various fields have been widely developed and applied. The application of computer technology software in engineering management is also improving and developing, and computer technology makes the effectiveness and professionalism of engineering data management improve rapidly. Computer data and software processing ability can quickly improve the quality of engineering management, among which computer simulation technology helps improve the application level of engineering management technology. Computer simulation technology has become an important means of system analysis and design in many fields. Computer simulation refers to the computer as the main tool, with a real system or the default system on the basis of the simulation model, by running the simulation model and the analysis of the computer output information, realize the actual system running state and the change law of the comprehensive evaluation and prediction, and then realize the real system design and the structure of the improvement or optimization.;;;https://dl.acm.org/doi/10.1145/3501409.3501635;;;Software AND Engineering
Data analytics and machine learning methods, techniques and tool for model-driven engineering of smart IoT services;;;['Armin Moin'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This doctoral dissertation proposes a novel approach to enhance the development of smart services for the Internet of Things (IoT) and smart Cyber-Physical Systems (CPS). The proposed approach offers abstraction and automation to the software engineering processes, as well as the Data Analytics (DA) and Machine Learning (ML) practices. This is realized in an integrated and seamless manner. We implement and validate the proposed approach by extending an open source modeling tool, called ThingML. ThingML is a domain-specific language and modeling tool with code generation for the IoT/CPS domain. Neither ThingML nor any other IoT/CPS modeling tool supports DA/ML at the modeling level. Therefore, as the primary contribution of the doctoral dissertation, we add the necessary syntax and semantics concerning DA/ML methods and techniques to the modeling language of ThingML. Moreover, we support the APIs of several ML libraries and frameworks for the automated generation of the source code of the target software in Python and Java. Our approach enables platform-independent, as well as platform-specific models. Further, we assist in carrying out semi-automated DA/ML tasks by offering Automated ML (AutoML), in the background (in expert mode), and through model-checking constraints and hints at design-time. Finally, we consider three use case scenarios from the domains of network security, smart energy systems and energy exchange markets.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00130;;;Software AND Engineering
NLP for requirements engineering: tasks, techniques, tools, and technologies;;;['Alessio Ferrari', 'Liping Zhao', 'Waad Alhoshan'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Requirements engineering (RE) is one of the most natural language-intensive fields within the software engineering area. Therefore, several works have been developed across the years to automate the analysis of natural language artifacts that are relevant for RE, including requirements documents, but also app reviews, privacy policies, and social media content related to software products. Furthermore, the recent diffusion of game-changing natural language processing (NLP) techniques and platforms has also boosted the interest of RE researchers. However, a reference framework to provide a holistic understanding of the field of NLP for RE is currently missing. Based on the results of a recent systematic mapping study, and stemming from a previous ICSE tutorial by one of the authors, this technical briefing gives an overview of NLP for RE tasks, available techniques, supporting tools and NLP technologies. It is oriented to both researchers and practitioners, and will gently guide the audience towards a clearer view of how NLP can empower RE, providing pointers to representative works and specialised tools.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00137;;;Software AND Engineering
Extractive multi product-line engineering;;;['Kamil Rosiak'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Cloning is a general approach to create new functionality within variants as well as new system variants. It is a fast, flexible, intuitive, and economical approach to evolve systems in the short run. However, in the long run, the maintenance effort increases. A common solution to this problem is the extraction of a product line from a set of cloned variants. This process requires a detailed analysis of variants to extract variability information. However, clones within a variant are usually not considered in the process, but are also a cause for unsustainable software. This thesis proposes an extractive multi product-line engineering approach to re-establish the sustainable development of software variants. We propose an approach to re-engineer intra-system and inter-system clones into reusable, configurable components stored in an integrated platform and synthesize a matching multilayer feature model.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00122;;;Software AND Engineering
IoT Learning for Electrical Engineering;;;['Hezron Hezron', 'Virginia Lalujan', 'Ghandy Ghandy'];;;May 2021;;;APCORISE '21: Proceedings of the 4th Asia Pacific Conference on Research in Industrial and Systems Engineering;;;Abstract—The primary aim of this Paper is to outline results and to summarize research findings on IoT learning that increase learning opportunities and give more positive impact to Electrical Engineering education especially on machines and sensor in physical object communicating with each other. IoT learning tries to enhance the learning patterns variety or how the ways people access and manage information to acquire knowledge by using smart technology which in our case is a NodeMCU and Arduino. The successful experiences build confidence to open wider subject of innovations in education 4.0 as it is discussed in the paper. It is expected that the current results motivate and support the running electronics and telematics education to be optimized in reliability and effectiveness by using more structure and direct approach in digital learning technology.;;;https://dl.acm.org/doi/10.1145/3468013.3468671;;;Software AND Engineering
Towards an understanding of benefits and challenges in the use of design thinking in requirements engineering;;;['Lauriane Pereira', 'Rafael Parizi', 'Matheus Prestes', 'Sabrina Marczak', 'Tayana Conte'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Agile approaches arose as a way of addressing some of the main challenges in software development. Some of the challenges are changing requirements, lack of understanding about the system's scope, and out-of-sync between code, requirements, and documentation. Software companies' professionals have adopted Design Thinking (DT) to support software development to understand better what customers want, fostering the creation of features and products. Due to the importance of requirement engineering to software development success, this study aimed to characterize what DT benefits and challenges were perceived in requirements engineering by the Brazilian software development community. The current study used mixed methods combining two qualitative methods, a focus group to collect and understand the professionals' DT usage opinions and a survey to confirm the professionals' challenges and benefits. This study identified that DT has helped the professionals improve the requirements gathering and specification, reflecting on better users' real needs understanding and building fittable solutions to support them. The results serve to understand better DT potential, perceived by software industry professionals, to anticipate and support these issues with other professionals.;;;https://dl.acm.org/doi/10.1145/3412841.3442008;;;Software AND Engineering
Multivariate Data Fusion Method Based on 3DGIS and its Application in Engineering Management;;;['Chengkun Liu', 'Rui Ma', 'Binbin Hu', 'Qingsong Fan'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;In the life-cycle engineering management of a project, a large amount of diversified and heterogeneous data is involved. How to efficiently manage and visualize various data sources is the basis for realizing the refined management of project construction. Based on the concept of data fusion, this article sorts out the multiple data involved in project engineering management, analyses the data fusion method and process of multivariate structured data and geospatial data. By combining 3DGIS in data integration, management and visualization, data fusion and expression in a three-dimensional environment can be realized. Taking the engineering management system of the bank slope of Song Gang Area as an example, it verifies the validity of the multivariate data fusion method based on 3DGIS in this paper.;;;https://dl.acm.org/doi/10.1145/3501409.3501656;;;Software AND Engineering
Quantum Computing: A New Software Engineering Golden Age;;;['Mario Piattini', 'Guido Peterssen', 'Ricardo Pérez-Castillo'];;;July 2020;;;ACM SIGSOFT Software Engineering Notes;;;Quantum computing, and to an even greater extent quantum technology, is changing the world. Quantum computing is not an evolution of classical computer science; it is actually a revolution that completely changes the computing paradigm. Quantum computers are based on the principles of quantum mechanics, such as superposition and entanglement, and they seek to boost computational power exponentially. Many problems that have until now been impossible to solve, in practical terms, might very well be able to be addressed by means of quantum computing. The fact is that at the present time quantum computing is influencing most business sectors and research fields, due to its various promising applications. To make such applications become reality, quantum algorithms must be specially coded for these extremely different computers. Although some well-known quantum algorithms already exist, the need for quantum software will increase dramatically in the next years. In that context, quantum software has to be produced in a more industrial and controlled way, i.e., aspects such as quality, delivery, project management, or evolution of quantum software must be addressed. We are sure that quantum computing will be the main driver for a new software engineering golden age during the present decade of the 2020s.;;;https://dl.acm.org/doi/10.1145/3402127.3402131;;;Software AND Engineering
Teaching Reform of Engineering Graphics Course Based on Engineering Certification under Big Data;;;['Ying Chen'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;Engineering Graphics is an important core course and an introductory course for mechanical majors. Only when students master the relevant knowledge of mechanical drawing course can they learn the follow-up courses better. This paper mainly studies the teaching reform of engineering graphics course based on engineering certification under the background of big data. Through oriented engineering education professional certification of professional reform and practice, improve the quality of the talent training and professional recognition, in preparation for the smoothly through professional certification, and to the local undergraduate colleges and universities for students majoring in mechanical and other positive effects to the cultivation of the students of engineering specialty, the improvement of international competitiveness for Chinese engineering education support.;;;https://dl.acm.org/doi/10.1145/3482632.3483107;;;Software AND Engineering
The Application of Computer Electronic Information Technology in Engineering Management;;;['Yuling Huang', 'Chaoqun Leng', 'Liping Zhan'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;In today's era, the rapid development of network information technology has had a huge impact on people's lives. Various industries have widely used computer electronic information technology, and has had a positive impact, changed people's traditional way of life, and also greatly improved work efficiency. As a complex work, engineering management will make reasonable use of computer electronic information technology, and then the quality and efficiency of the work will be significantly improved, which can achieve scientific management. Therefore, this paper mainly studies the application of computer electronic information technology in engineering management, understands the significance of its application in engineering management, and improves the application effect of computer electronic information technology in engineering management.;;;https://dl.acm.org/doi/10.1145/3501409.3501427;;;Software AND Engineering
Engineering for Chaos: Lessons Learned from COVID-19;;;['Steven Fraser', 'Dennis Mancl'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;The global COVID-19 pandemic has transformed the way we live, learn, and teach - impacting both "how we learn" and "what we learn." Software system resilience has emerged as a critical concept, a departure from historical system objectives obsessed with high performance. In practice, there are many situations when development focused on efficiency, creates a system that is not very resilient. Fortunately, some technology companies have prioritized stability and availability over efficiency in order to deliver to customers a more consistent experience. Governments also value resilience to reliably serve their communities in the face of crises like cyber hacking and COVID-19. System resilience is a topic often neglected in computer science curricula. This paper reports on a recent virtual ACM SPLASH-E Education Symposium panel session held in November 2020 that discussed resilience, efficiency, and the impact of COVID-19 on computer science education. The panel featured Steven Fraser (panel impresario) and panelists Rebecca Mercuri, Landon Noll, Ales Plsek, and Moshe Vardi.;;;https://dl.acm.org/doi/10.1145/3448992.3448998;;;Software AND Engineering
Reverse engineering for reduction parallelization via semiring polynomials;;;['Akimasa Morihata', 'Shigeyuki Sato'];;;June 2021;;;PLDI 2021: Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation;;;Parallel reduction, which summarizes a given dataset, e.g., the total, average, and maximum, plays a crucial role in parallel programming. This paper presents a new approach, reverse engineering, to automatically discovering nontrivial parallel reductions in sequential programs. The body of the sequential reduction loop is regarded as a black box, and its input-output behaviors are sampled. If the behaviors correspond to a set of linear polynomials over a semiring, a divide-and-conquer parallel reduction is generated. Auxiliary reverse-engineering methods enable a long and nested loop body to be decomposed, which makes our parallelization scheme applicable to various types of reduction loops. This approach is not only simple and efficient but also agnostic to the details of the input program. Its potential is demonstrated through several use case scenarios. A proof-of-concept implementation successfully inferred linear polynomials for nearly all of the 74 benchmarks exhaustively collected from the literature. These characteristics and experimental results demonstrate the promise of the proposed approach, despite its inherent unsoundness.;;;https://dl.acm.org/doi/10.1145/3453483.3454079;;;Software AND Engineering
Towards Binary Diversified Challenges For A Hands-On Reverse Engineering Course;;;['Christopher Stricklan', 'TJ OConnor'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;The balance of a practical hands-on and theoretical approach for reverse engineering coursework offers a strong approach for cybersecurity education. This balance is key to helping students build the skills necessary to contribute to the industry upon graduation. However, the remote learning demands of the current pandemic present a challenge to this approach. Inappropriate collaboration between students poses a threat to the educational benefits of practice-based learning. Specifically, inappropriate collaboration can threaten the development of critical problem skills gained during individual work. Further, relying on instructors to create unique challenges for each student fails to scale. To overcome these challenges, we have implemented a binary diversification system that produces unique reverse engineering challenges per student. In this paper, we present the technical details and lessons learned implementing this approach. We believe that sharing our approach will benefit cybersecurity education instructors looking to overcome the challenges of remote-learning cybersecurity coursework.;;;https://dl.acm.org/doi/10.1145/3430665.3456358;;;Software AND Engineering
Adaptive remote experimentation for engineering students;;;['Nina Slamnik-Kriještorac', 'João Francisco Nunes Pinheiro', 'Thomas Huybrechts', 'Daniel van den Akker', 'Johann M. Marquez-Barja'];;;September 2021;;;GoodIT '21: Proceedings of the Conference on Information Technology for Social Good;;;Due to the dynamic nature of changes in various ICT technologies nowadays, the gaps between industry, research, and academia need to be bridged in order to adequately support STEM students towards their future career paths. With the COVID-19 pandemic, and restrictions on access to university premises, an agile transition of both teaching and experimentation was essential, and adjustments in the curriculum were needed more than ever. Therefore, in this paper we present an adaptive and on-demand education framework for engineering students, thereby enabling remote experimentation and adjustments of exercise content to enhance students' learning experience. We present the two types of practical experimentation environments, i.e., cloud and real-life net-working testbed, for performing remote laboratory exercises, as well as the assessment of students' experience that is used as an input for the dynamic adjustments of the exercise content. Our results show that students consider they significantly improved the baseline skills our courses tend to build and strengthen towards preparing students for their future jobs.;;;https://dl.acm.org/doi/10.1145/3462203.3475931;;;Software AND Engineering
ReverseORC: Reverse Engineering of Resizable User Interface Layouts with OR-Constraints;;;['Yue Jiang', 'Wolfgang Stuerzlinger', 'Christof Lutteroth'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;Reverse engineering (RE) of user interfaces (UIs) plays an important role in software evolution. However, the large diversity of UI technologies and the need for UIs to be resizable make this challenging. We propose ReverseORC, a novel RE approach able to discover diverse layout types and their dynamic resizing behaviours independently of their implementation, and to specify them by using OR constraints. Unlike previous RE approaches, ReverseORC infers flexible layout constraint specifications by sampling UIs at different sizes and analyzing the differences between them. It can create specifications that replicate even some non-standard layout managers with complex dynamic layout behaviours. We demonstrate that ReverseORC works across different platforms with very different layout approaches, e.g., for GUIs as well as for the Web. Furthermore, it can be used to detect and fix problems in legacy UIs, extend UIs with enhanced layout behaviours, and support the creation of flexible UI layouts.;;;https://dl.acm.org/doi/10.1145/3411764.3445043;;;Software AND Engineering
The Management of Risks and Benefits when Engineering Interactive Digital Systems;;;['José Creissac Campos', 'T.C. Nicholas Graham', 'Lucio Davide Spano', 'Jan Van den Bergh'];;;June 2021;;;EICS '21: Companion of the 2021 ACM SIGCHI Symposium on Engineering Interactive Computing Systems;;;Traditionally, most UX designers, computer scientists and software engineers have not had to consider risks to the public from using their systems. However, the current evolution of digital systems in terms of the increasing number of users, their growing complexity and the pervasiveness of Artificial Intelligence techniques allow common HCI designers and engineers to build systems that create risks for the individual, groups of people, or event to the entire society.  In this workshop, we aim at collecting the views and the current practice in the management of the risks and benefits in the engineering of interactive digital systems. Such a view will draw the way for new research, methods, and tools to incorporate the risk analysis into the current engineering and design practices.  The workshop is proposed on behalf of the IFIP Working Groups 2.7/13.4 on User Interface Engineering.;;;https://dl.acm.org/doi/10.1145/3459926.3464760;;;Software AND Engineering
A Survey on Automated Log Analysis for Reliability Engineering;;;['Shilin He', 'Pinjia He', 'Zhuangbin Chen', 'Tianyi Yang', 'Yuxin Su', 'Michael R. Lyu'];;;None;;;ACM Computing Surveys;;;Logs are semi-structured text generated by logging statements in software source code. In recent decades, software logs have become imperative in the reliability assurance mechanism of many software systems, because they are often the only data available that record software runtime information. As modern software is evolving into a large scale, the volume of logs has increased rapidly. To enable effective and efficient usage of modern software logs in reliability engineering, a number of studies have been conducted on automated log analysis. This survey presents a detailed overview of automated log analysis research, including how to automate and assist the writing of logging statements, how to compress logs, how to parse logs into structured event templates, and how to employ logs to detect anomalies, predict failures, and facilitate diagnosis. Additionally, we survey work that releases open-source toolkits and datasets. Based on the discussion of the recent advances, we present several promising future directions toward real-world and next-generation automated log analysis.;;;https://dl.acm.org/doi/10.1145/3460345;;;Software AND Engineering
The development of computer communication technology and its application in electronic information engineering;;;['Feng Han', 'Jianyu Cai', 'Xiaoshuang Wang'];;;July 2021;;;ICICSE 2021: 2021 10th International Conference on Internet Computing for Science and Engineering;;;The rapid development of science and technology and the comprehensive application of information technology have brought electronic information engineering into the fast lane of development, and has also continuously improved the overall level of my country's electronic information engineering. Computer communication technology is an indispensable and important part of electronic information engineering, and there is a close relationship between the two in mutual influence and coordinated development. Strengthening the comprehensive application of computer communication technology in electronic information engineering can significantly improve the stability and efficiency of data and information transmission, and greatly improve people's daily life. It can have a positive meaning for the overall construction and development of society. To this end, it must be set out from a global perspective, consider how to improve the application effect of computer communication technology in electronic information engineering. Based on this, this article briefly analyzes computer communication technology and electronic information engineering, explores the development history, development status and development trend of computer communication technology, and analyzes the application ideas of computer communication technology in electronic information engineering.;;;https://dl.acm.org/doi/10.1145/3485314.3485333;;;Software AND Engineering
New ideas: automated engineering of metamorphic testing environments for domain-specific languages;;;['Pablo C. Cañizares', 'Pablo Gómez-Abajo', 'Alberto Núñez', 'Esther Guerra', 'Juan de Lara'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;Two crucial aspects for the trustworthy utilization of domain-specific languages (DSLs) are their semantic correctness, and proper testing support for their users. Testing is frequently used to verify correctness, but is often done informally -- which may yield unreliable results -- and requires substantial effort for creating suitable test cases and oracles.   To alleviate this situation, we propose an automated technique for building metamorphic testing environments for DSLs. Metamorphic testing identifies expected relationships between the outputs of two consecutive tests, reducing the effort in specifying oracles and creating test cases manually. This new ideas paper presents the overarching concepts, the architecture and a prototype implementation. We illustrate our proposal using a DSL to model and simulate data centres.;;;https://dl.acm.org/doi/10.1145/3486608.3486904;;;Software AND Engineering
Practice makes better: quiz retake software to increase student learning;;;['Kesina Baral', 'Jeff Offutt', 'Paul Ammann', 'Rasika Mohod'];;;August 2021;;;EASEAI 2021: Proceedings of the 3rd International Workshop on Education through Advanced Software Engineering and Artificial Intelligence;;;In the past few years, we have made several pedagogical changes to the way we teach and assess student knowledge in our courses.These courses are undergraduate software engineering courses taken in the third or fourth years, and graduate (non-research) courses taken as part of a master’s degree. They are taken by software engineering majors and computer science majors. This paper focuses on a specific technique–allowing students to retake weekly quizzes.We use weekly quizzes to offer more frequent, yet lower stakes,assessments than the traditional midterm exam. Quizzes are usually given at the beginning of class meetings. We offer students who under-performed or who missed a quiz the chance to try again. A major contribution of this paper is a description of scheduling soft-ware we developed to facilitate the retake process. Retake quizzes are different from the original quizzes, but cover the same material and are of similar difficulty. Our goal is to improve student learning and retention. This paper presents a post-hoc retrospective analysis of student performance on retake quizzes. In such a scenario, only limited conclusions can be drawn. Nonetheless, we see encouraging signs that students not only achieve higher overall scores when retaking quizzes, but that some students perform better on the final exam.;;;https://dl.acm.org/doi/10.1145/3472673.3473965;;;Software AND Engineering
To get good student ratings should you only teach programming courses?: investigation and implications of student evaluations of teaching in a software engineering context;;;['Antti Knutas', 'Timo Hynninen', 'Maija Hujala'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Student evaluations of teaching (SET) are commonly used in universities for assessing teaching quality. However, previous literature shows that in software engineering students tend to rate certain topics higher than others: In particular students tend to value programming and software construction over software design, software engineering models and methods, or soft skills. We hypothesize that these biases also play a role in SET responses collected from students. The objective of this study is to investigate how the topic of a software engineering course affects the SET metrics. We accomplish this by performing multilevel regression analysis on SET data collected in a software engineering programme. We analyzed a total of 1295 student evaluations from 46 university courses in a Finnish university. The results of the analysis verifies that the student course evaluations exhibit similar biases as distinguished by previous software engineering education research. The type of the course can predict a higher SET rating. In our dataset, software construction and programming courses received higher SET ratings compared to courses on software engineering processes, models, and methods.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00035;;;Software AND Engineering
Research on the Application of BIM in Building Engineering Management Based on 3 D Model;;;['Yuanchao Yao', 'Hu Qiongjing'];;;January 2022;;;BIC 2022: 2022 2nd International Conference on Bioinformatics and Intelligent Computing;;;After the 19th CPC National Congress, the state formally implemented the "new infrastructure" strategy, which is mainly the proxy term of new infrastructure construction. One of the very important highlights of the new infrastructure for the construction engineering management industry is that it can use BIM technology to integrate the whole process of design, construction and intelligent operation, so as to realize the real efficiency informatization refinement of the construction industry. BIM is the best fusion data carrier with IoT devices and IOT, CIM, which is the internal visualization of BIM and new infrastructure, the virtual construction simulation logic relationship that requires three-dimensional models and processes. Therefore, by analyzing the application methods and measures of BIM in construction engineering management in the background of new infrastructure strategy, this paper proposes the multidimensional extension of the BIM model for collaborative management.;;;https://dl.acm.org/doi/10.1145/3523286.3524607;;;Software AND Engineering
Summary of the 5th International Workshop on Requirements Engineering and Testing (RET 2018);;;['Michael Unterkalmsteiner', 'Tingting Yu', 'Gregory Gay', 'Elizabeth Bjarnason', 'Markus Borg', 'Michael Felderer'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;The RET (Requirements Engineering and Testing) workshop series provides a meeting point for researchers and practitioners from the two separate elds of Requirements Engineering (RE) and Testing. The goal is to improve the connection and alignment of these two areas through an exchange of ideas, challenges, practices, experiences and results. The long term aim is to build a community and a body of knowledge within the intersection of RE and Testing, i.e. RET. The 5th workshop was held in colocation with ICSE 2018 in Gothenburg, Sweden. The workshop continued in the same interactive vein as the predecessors. We introduced a new format for the presentations in which the paper authors had the opportunity to interact extensively with the audience. Each author was supported by a member of the organization committee to prepare either an extensive demo, collect more data in form of a questionnaire or perform a hands-on tutorial. We named this new format \X-ray session". In order to create an RET knowledge base, this cross-cutting area elicits contributions from both RE and Testing, and from both researchers and practitioners. A range of papers were presented from short positions papers to full research papers that cover connections between the two elds. The workshop attracted 27 participants and the positive feedback on the new format encourages us to organize the workshop the next year again.;;;https://dl.acm.org/doi/10.1145/3310013.3310037;;;Software AND Engineering
A new M&S engineering program with a base in computer engineering;;;['James F. Leathrum', 'Yuzhong Shen', 'Oscar González'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;The reality of the current academic climate, in particular faced with drops in enrollment over the next decade as a result from drops in birth rates, is forcing hard choices for small programs such as the Modeling & Simulation Engineering (M&SE) program at Old Dominion University (ODU). The quality of the program and its benefit to its constituents do not offset the impracticality of continuing such programs. Two primary options for such programs are closure or consolidation. ODU decided on the latter course of action for M&SE. Due to the computational nature of the existing program, a decision was made to place M&SE as a major under the Computer Engineering degree. This paper presents the justification for this decision and the resulting curriculum and the hard decisions made to allow it to fit under computer engineering. A discussion of feedback from constituents such as the industrial advisory board for the existing M&SE program is included.;;;https://dl.acm.org/doi/10.5555/3522802.3523028;;;Software AND Engineering
IKP-CDIO: exploration and practice on teaching framework of embedding ideological education into engineering curriculum;;;['Yuxia Sun', 'Ronghua Fu'];;;November 2021;;;ICEEL '21: Proceedings of the 2021 5th International Conference on Education and E-Learning;;;The concept of “embedding ideological education into curriculum”, briefly called “curriculum ideology”, can be regarded as a new kind of “holistic education” concept. Implementing curriculum ideology in the teaching of engineering courses can simultaneously cultivate the academic and non-academic abilities of engineering college students. At present, such teaching practices are in the exploratory stage, and effective teaching modes and cases are still desired to support embedding ideological education into engineering curriculum. To alleviate the above problem, a new engineering teaching framework called IKP-CDIO is proposed, and a teaching case under the framework and the teaching effects are detailed with a computer major course named "Software Testing".;;;https://dl.acm.org/doi/10.1145/3502434.3502455;;;Software AND Engineering
A Framework for Quantifiable Process Improvement through Method Fragments in Situational Method Engineering;;;['Michael Chima Ogbuachi', 'Itilekha Podder', 'Udo Bub', 'Murad Huseynli'];;;November 2021;;;AISS '21: Proceedings of the 3rd International Conference on Advanced Information Science and System;;;In the field of Business Process Management (BPM), planning and executing precise process tailoring and optimization can be done through different design strategies. Even though Situational Method Engineering (SME) can provide an additional layer of constitutional knowledge, it hasn’t been explored as deeply as other traditional methods. Strategies that rely on a so-called “situational context” make use of the atomic conceptual entities known as method chunks and/or fragments from the field of Situational Method Engineering (SME). BPM, on the other hand, describes processes through representational tools that have been thoroughly used in industry and established as reliable. All of these designs have advantages and disadvantages. We analyzed several designs and proposed a synthesized framework (metamodel) that combines their strong points, while also providing a way to objectively quantify and restructure the performance of a pre-existing process/product (or optimize the creation of an entirely new one). We provide an analysis with a manufacturing organization using BPM concepts for process management/improvement and our proposed method framework, which incorporates Situational Method Engineering metamodelling and the Critical Path Method as a base for process improvement. We show here how using our proposed framework brings a flexible approach to a structured process management, helping enterprises to define, apply, store and retrieve their processes through methods/fragments, while also providing a guideline for systematic tailoring.;;;https://dl.acm.org/doi/10.1145/3503047.3503535;;;Software AND Engineering
Guiding engineers with the passive process engine environment;;;['Christoph Mayr-Dorn', 'Stefan Bichler', 'Felix Keplinger', 'Alexander Egyed'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Research as early as the 90s identified rigid, active process enactment as detrimental to engineers' flexibility. While software engineering processes thus are rarely "executable", engineers would benefit from guidance in safety critical domains where standards, regulations, and processes are often complicated. In this paper, we present the Passive Process Engine Environment (P2E2) that tracks process progress in the background and automatically evaluates quality assurance constraints even in the presence of process deviations. Our approach is engineering artifact agnostic and comes with two exemplary tool connectors to Jira and Jama. Video at: https://youtu.be/kXwU_baVWoQ;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00033;;;Software AND Engineering
If you want better empirical research, value your theory: On the importance of strong theories for progress in empirical software engineering research;;;['Klaus Schmid'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Scientific progress comes from creating sound theories. However, current software engineering still mostly falls short of this goal, although its importance is widely accepted. Thus, in this paper, we discuss the importance of a successful interaction of empirical research with a strong theoretical basis and the ramifications this has. In particular, we will extensively discuss the implications on theory building and the empirical vs. theory interaction, etc. While not everything we will discuss is novel, we present a number of insights, which we at least did not see in software engineering literature. We strongly believe that a careful consideration of the insights discussed in this paper has the potential to lead to a significant improvement in software engineering research.;;;https://dl.acm.org/doi/10.1145/3463274.3463360;;;Software AND Engineering
Coq’s vibrant ecosystem for verification engineering (invited talk);;;['Andrew W. Appel'];;;January 2022;;;CPP 2022: Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs;;;Program verification in the large is not only a matter of mechanizing a program logic to handle the semantics of your programming language. You must reason in the mathematics of your application domain--and there are many application domains, each with their own community of domain experts. So you will need to import mechanized proof theories from many domains, and they must all interoperate. Such an ecosystem is not only a matter of mathematics, it is a matter of software process engineering and social engineering. Coq's ecosystem has been maturing nicely in these senses.;;;https://dl.acm.org/doi/10.1145/3497775.3503951;;;Software AND Engineering
Software Development in Small Software Companies: Exploring the Usage of Procedures, Techniques, Methods and Models in Practice;;;['Micheal Tuape', 'Victoria Hasheela-Mufeti', 'Anna Kayanda', 'Jussi Kasurinen'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;Small software companies have a challenge with utilizing process tools, which affects practice with significant quality-related challenges. This affects the software industry significantly because SSCs dominate the industry, and most of all, over 80 percent of software products are produced by SSCs. This cross-sectional survey was conducted in 3 countries attracting 115 respondents with the primary objective of investigating the software practice concerning the utilization of process tools in SSCs. The study focused on the tools used in requirements engineering and software testing as critical process areas for quality software products. Our findings indicate that the number of personnel intertwines with the complexities arising from lengthy procedures of the tools and processes, aggregating into difficulty in tool usage. Due to the constant evolution of practices, the volatility in processes also causes slow adoption of other tools, for instance, testing that must accompany the main engineering tools during a project. These findings are significant in informing theory and communicating to the practitioners what they should do regarding process tools.;;;https://dl.acm.org/doi/10.1145/3501774.3501779;;;Software AND Engineering
Opinion Mining for Software Development: A Systematic Literature Review;;;['Bin Lin', 'Nathan Cassee', 'Alexander Serebrenik', 'Gabriele Bavota', 'Nicole Novielli', 'Michele Lanza'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Opinion mining, sometimes referred to as sentiment analysis, has gained increasing attention in software engineering (SE) studies. SE researchers have applied opinion mining techniques in various contexts, such as identifying developers’ emotions expressed in code comments and extracting users’ critics toward mobile apps. Given the large amount of relevant studies available, it can take considerable time for researchers and developers to figure out which approaches they can adopt in their own studies and what perils these approaches entail.We conducted a systematic literature review involving 185 papers. More specifically, we present (1) well-defined categories of opinion mining-related software development activities, (2) available opinion mining approaches, whether they are evaluated when adopted in other studies, and how their performance is compared, (3) available datasets for performance evaluation and tool customization, and (4) concerns or limitations SE researchers might need to take into account when applying/customizing these opinion mining techniques. The results of our study serve as references to choose suitable opinion mining tools for software development activities and provide critical insights for the further development of opinion mining techniques in the SE domain.;;;https://dl.acm.org/doi/10.1145/3490388;;;Software AND Engineering
Distance learning of electronic engineering based on Arduino platform;;;['Alipbay Mansur-Matritdinovich Dairbayev', 'Bahytzhan Sergeevich Baikenov', 'Yevgeniya Alexandrovna Daineko', 'Madina Tolegenovna Ipalakova'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;The principles of learning based on the Arduino platform, its features and development prospects are considered. Examples of using distance learning methods based on the Arduino platform, advantages and disadvantages of teaching methods are given. An effective, hybrid method of distance learning of electronic equipment on this platform is proposed. The laboratory work developed according to the proposed method of distance learning is presented.;;;https://dl.acm.org/doi/10.1145/3492547.3492644;;;Software AND Engineering
Model-driven system-performance engineering for cyber-physical systems;;;['Bram van der Sanden', 'Yonghui Li', 'Joris van den Aker', 'Benny Akesson', 'Tjerk Bijlsma', 'Martijn Hendriks', 'Kostas Triantafyllidis', 'Jacques Verriet', 'Jeroen Voeten', 'Twan Basten'];;;September 2021;;;EMSOFT '21: Proceedings of the 2021 International Conference on Embedded Software;;;System-Performance Engineering (SysPE) encompasses modeling formalisms, methods, techniques, and industrial practices to design systems for performance, where performance is taken integrally into account during the whole system life cycle. Industrial SysPE state of practice is generally model-based. Due to the rapidly increasing complexity of systems, there is a need to develop and establish model-driven methods and techniques. To structure the field of SysPE, we identify (1) industrial challenges motivating the importance of SysPE, (2) scientific challenges that need to be addressed to establish model-driven SysPE, (3) important focus areas for SysPE and (4) best practices. We conducted a survey to collect feedback on our views. The responses were used to update and validate the identified challenges, focus areas, and best practices. The final result is presented in this paper. Interesting observations are that industry sees a need for better design-space exploration support, more than for additional performance modeling and analysis techniques. Also tools and integral methods for SysPE need attention. From the identified focus areas, scheduling and supervisory control is seen as lacking established best practices.;;;https://dl.acm.org/doi/10.1145/3477244.3477985;;;Software AND Engineering
Software Development Practice: How Organisation Dynamics Inhibit the Utilization of Process Tools in Small Software Companies;;;['Micheal Tuape', 'Victoria Hasheela-Mufeti', 'Petrus Iiyambo', 'Anna Kayanda', 'Jussi Kasirinen'];;;November 2021;;;ICSIE '21: Proceedings of the 10th International Conference on Software and Information Engineering;;;Low-quality software products are synonymous with small software companies, yet thousands of process tools and methods are available, although unfortunately, they remain unutilized. The utilization of these process tools are said to be very challenging to small software companies with the difficulty of adaptability tagged to the context in which the companies operate since the process tools are not designed to take care of the operational context of the small software companies. This survey study was undertaken to empirically investigate the implication of the organizational dynamics on using process tools in SSCs. A total of 115 respondents from Tanzania, Namibia, and Ghana were reached through a structured questionnaire. Our findings reveal that the ad-hoc behaviors and attitude breed a culture that inhibits procedural and process-intensive practices synonymous with most software engineering process tools. This finding is interesting because this area has been underestimated while looking at software practice, yet it is significant in understanding practice in relation to software process tools, significantly how small software companies can be helped to adopt the different tools and also provide a mechanism to help the designers of process tools make tools that are usable in the context of the practice of SSCs.;;;https://dl.acm.org/doi/10.1145/3512716.3512722;;;Software AND Engineering
Targeting the Weakest Link: Social Engineering Attacks in Ethereum Smart Contracts;;;['Nikolay Ivanov', 'Jianzhi Lou', 'Ting Chen', 'Jin Li', 'Qiben Yan'];;;May 2021;;;ASIA CCS '21: Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security;;;Ethereum holds multiple billions of U.S. dollars in the form of Ether cryptocurrency and ERC-20 tokens, with millions of deployed smart contracts algorithmically operating these funds. Unsurprisingly, the security of Ethereum smart contracts has been under rigorous scrutiny. In recent years, numerous defense tools have been developed to detect different types of smart contract code vulnerabilities. When opportunities for exploiting code vulnerabilities diminish, the attackers start resorting to social engineering attacks, which aim to influence humans - often the weakest link in the system. The only known class of social engineering attacks in Ethereum are honeypots, which plant hidden traps for attackers attempting to exploit existing vulnerabilities, thereby targeting only a small population of potential victims. In this work, we explore the possibility and existence of new social engineering attacks beyond smart contract honeypots. We present two novel classes of Ethereum social engineering attacks - Address Manipulation and Homograph - and develop six zero-day social engineering attacks. To show how the attacks can be used in popular programming patterns, we conduct a case study of five popular smart contracts with combined market capitalization exceeding $29 billion, and integrate our attack patterns in their source codes without altering their existing functionality. Moreover, we show that these attacks remain dormant during the test phase but activate their malicious logic only at the final production deployment. We further analyze 85,656 open-source smart contracts, and discover that 1,027 of them can be used for the proposed social engineering attacks. We conduct a professional opinion survey with experts from seven smart contract auditing firms, corroborating that the exposed social engineering attacks bring a major threat to the smart contract systems.;;;https://dl.acm.org/doi/10.1145/3433210.3453085;;;Software AND Engineering
Engineering capstone project as a service-learning activity: A case study in Geomatics degree;;;['Judit Fernández-Puerto', 'Paula García-Osorio', 'Manuel Rodríguez-Martín', 'Pablo Rodríguez-Gonzálvez'];;;October 2021;;;TEEM'21: Ninth International Conference on Technological Ecosystems for Enhancing Multiculturality (TEEM&apos;21);;;Capstone projects are the culminating experience of engineering students, where they are focused on real-world application, so they will be better prepared for their professional life. In the present communication it is raised an application approach of incorporation of a service-learning methodology into the capstone projects to improve the acquisition of skills, as well as motivation and engagement. The activity is contextualized in the so-called depopulated Spain, which includes towns and villages with a high risk of depopulation and a shortage of investment and resources. The experience was carried out in the capstone project of a Geomatics Engineering degree.;;;https://dl.acm.org/doi/10.1145/3486011.3486477;;;Software AND Engineering
Exploration and Practice of Hierarchical Graduation Project under the Background of Science Collaborative Education and Engineering Education Accreditation;;;['Lilan Gao', 'Yansong Tan', 'Yanfang Sun', 'Linwei Lv', 'Bin Li', 'Qijun Gao', 'Xiaofei Wang', 'Yijiao Zhao'];;;November 2021;;;ICAAI '21: Proceedings of the 5th International Conference on Advances in Artificial Intelligence;;;Graduation project is an important integrated practice segment for undergraduate education, since the quality of undergraduate education can be directly evaluated by the quality of graduation project. Under the background of science collaborative education and engineering education accreditation, it is necessary to explore an intelligent and integrated graduation project system to train students by all sorts of engineering and research projects, thus improve students' practical ability and innovation ability. This paper first analyzed the problems of the graduation project in the major of process equipment and control engineering, then introduced a novel hierarchical graduation project system to adapt to the concept of science collaborative education and engineering education. By putting the novel graduation project system into effect, the quality of graduation project has significantly improved.;;;https://dl.acm.org/doi/10.1145/3505711.3505733;;;Software AND Engineering
Towards an Anatomy of Software Craftsmanship;;;['Anders Sundelin', 'Javier Gonzalez-huerta', 'Krzysztof Wnuk', 'Tony Gorschek'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Context: The concept of software craftsmanship has early roots in computing, and in 2009, the Manifesto for Software Craftsmanship was formulated as a reaction to how the Agile methods were practiced and taught. But software craftsmanship has seldom been studied from a software engineering perspective.Objective: The objective of this article is to systematize an anatomy of software craftsmanship through literature studies and a longitudinal case study.Method: We performed a snowballing literature review based on an initial set of nine papers, resulting in 18 papers and 11 books. We also performed a case study following seven years of software development of a product for the financial market, eliciting qualitative, and quantitative results. We used thematic coding to synthesize the results into categories.Results: The resulting anatomy is centered around four themes, containing 17 principles and 47 hierarchical practices connected to the principles. We present the identified practices based on the experiences gathered from the case study, triangulating with the literature results.Conclusion: We provide our systematically derived anatomy of software craftsmanship with the goal of inspiring more research into the principles and practices of software craftsmanship and how these relate to other principles within software engineering in general.;;;https://dl.acm.org/doi/10.1145/3468504;;;Software AND Engineering
Physical and functional reverse engineering challenges for advanced semiconductor solutions;;;['Bernhard Lippmann', 'Ann-Christin Bette', 'Matthias Ludwig', 'Johannes Mutter', 'Johanna Baehr', 'Alexander Hepp', 'Horst Gieser', 'Nicola Kovač', 'Tobias Zweifel', 'Martin Rasche', 'Oliver Kellermann'];;;March 2022;;;DATE '22: Proceedings of the 2022 Conference &amp; Exhibition on Design, Automation &amp; Test in Europe;;;Motivated by the threats of malicious modification and piracy arising from worldwide distributed supply chains, the goal of RESEC is the creation, verification, and optimization of a complete reverse engineering process for integrated circuits manufactured in technology nodes of 40 nm and below. Building upon the presentation of individual reverse engineering process stages, this paper connects analysis efforts and yields with their impact on hardware security, demonstrated on a design with implemented experimental hardware Trojans. We outline the interim stage of our research activities and present our future targets linking chip design and physical verification processes.;;;https://dl.acm.org/doi/10.5555/3539845.3540035;;;Software AND Engineering
Integrating Multi-Disciplinary Offline and Online Engineering in Industrial Cyber-Physical Systems through DevOps;;;['Iori Mizutani', 'Ganesh Ramanathan', 'Simon Mayer'];;;November 2021;;;IoT '21: Proceedings of the 11th International Conference on the Internet of Things;;;Industry 4.0 is transforming industrial automation systems into increasingly complex cyber-physical systems (CPS). In particular, there is a need to integrate systems across horizontal and vertical layers across industrial and disciplinary domains. The development of industrial CPS requires not only high-level configuration and control at the execution system level, but also offline and online engineering (OOE) work, including mechanical and electrical engineering of the devices, their installation, networking, and documentation. Using DevOps, a collection of modern software lifecycle management tactics, we propose to build an integrated platform to manage the OOE tasks. Continuous Integration/Continuous Delivery (CI/CD) pipelines and Infrastructure as Code, which are key aspects of DevOps, coordinate the building, testing, and deployment of software services. To bring the corresponding benefits of pure software systems to industrial CPS, we integrate engineering tasks using distributed version control and the W3C Web of Things. As a proof of concept, we implemented the concept for a mock system that includes the OOE tasks in a process automation scenario. The DevOps platform provides a structured transfer and exchange of engineering knowledge among stakeholders involved in industrial CPS.;;;https://dl.acm.org/doi/10.1145/3494322.3494328;;;Software AND Engineering
Application of VR technology in architectural decoration engineering technology;;;['Ran Yin'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;With the rapid development of social economy and the increasing complexity of architectural decoration projects, there is an urgent need to introduce new technologies to improve work efficiency and solve practical problems. Nowadays, the emerging VR technology, a computer-aided technology, has been widely used in actual engineering projects and has proven to greatly improve work efficiency. This article will discuss the specific application and operation of VR technology in architectural decoration engineering technology, analyze the application advantages of VR technology and look forward to its application prospects in architectural decoration engineering technology.;;;https://dl.acm.org/doi/10.1145/3495018.3501213;;;Software AND Engineering
Teaching Practice of Technological Integrated Innovation for Professional Degree Postgraduates of Mechanical Engineering: An Engine Case Study;;;['Long Zhou', 'Guoqiang Chen', 'Feng Jiao'];;;May 2021;;;ICMET 2021: 2021 3rd International Conference on Modern Educational Technology;;;There exist two types of models cultivating graduate students, so-called academic and professional degrees. Compared with the academic degree, the aim of the professional degree is to cultivate high-level application-oriented special talents with solid theoretical foundations applicable for the practical work needs of specific industries or occupations. To improve the technological integrated innovation ability of professional degree postgraduates in mechanical engineering and to cultivate professional talents suitable for the needs of enterprise and social development, during class teaching, taking the developed heat transfer, lubrication and friction coupling model of piston ring-liner as an example, based on the relationship between the coupled model and technological integrated innovation, after verifying the correctness of the coupled model using comparisons between the simulated temperature fields of solid components with the tested ones, the impacts of ring pressure constants and lubricant viscosities on the heat transfer, lubrication and friction characteristics of piston ring-liner are studied in detail. The results show that the increase of ring pressure constants efficiently enhances the cooling of combustion chamber components, but reduces the lubrication properties of piston ring-liner; in contrast, increasing the viscosities of lubricant improves the lubrication properties of piston ring-liner, but decreases significantly the transferred heat between the piston ring and liner. The method of technological integrated innovation in this paper can efficiently improve the innovation consciousness of professional degree postgraduates.;;;https://dl.acm.org/doi/10.1145/3468978.3469004;;;Software AND Engineering
Search-based software re-modularization: a case study at Adyen;;;['Casper Schröder', 'Adriaan van der Feltz', 'Annibale Panichella', 'Maurício Aniche'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Deciding what constitutes a single module, what classes belong to which module or the right set of modules for a specific software system has always been a challenging task. The problem is even harder in large-scale software systems composed of thousands of classes and hundreds of modules. Over the years, researchers have been proposing different techniques to support developers in re-modularizing their software systems. In particular, the search-based software re-modularization is an active research topic within the software engineering community for more than 20 years. This paper describes our efforts in applying search-based software re-modularization approaches at Adyen, a large-scale payment company. Adyen's code base has 5.5M+ lines of code, split into around hundreds of modules. We leveraged the existing body of knowledge in the field to devise our own search algorithm and applied it to our code base. Our results show that search-based approaches scale to large code bases as ours. Our algorithm can find solutions that improve the code base according to the metrics we optimize for, and developers see value in the recommendations. Based on our experiences, we then list a set of challenges and opportunities for future researchers, aiming at making search-based software re-modularization more efficient for large-scale software companies.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00017;;;Software AND Engineering
Mixed Teaching Pattern Exploration Integrating Online and Offline Platforms Oriented to Continuous Improvement for Engineering Accreditation: Practice in computer programming course as a presentation case;;;['Wei Zhao'];;;October 2021;;;ICETC '21: Proceedings of the 13th International Conference on Education Technology and Computers;;;None;;;https://dl.acm.org/doi/10.1145/3498765.3498784;;;Software AND Engineering
Hardware Trust and Assurance through Reverse Engineering: A Tutorial and Outlook from Image Analysis and Machine Learning Perspectives;;;['Ulbert J. Botero', 'Ronald Wilson', 'Hangwei Lu', 'Mir Tanjidur Rahman', 'Mukhil A. Mallaiyan', 'Fatemeh Ganji', 'Navid Asadizanjani', 'Mark M. Tehranipoor', 'Damon L. Woodard', 'Domenic Forte'];;;None;;;ACM Journal on Emerging Technologies in Computing Systems;;;In the context of hardware trust and assurance, reverse engineering has been often considered as an illegal action. Generally speaking, reverse engineering aims to retrieve information from a product, i.e., integrated circuits (ICs) and printed circuit boards (PCBs) in hardware security-related scenarios, in the hope of understanding the functionality of the device and determining its constituent components. Hence, it can raise serious issues concerning Intellectual Property (IP) infringement, the (in)effectiveness of security-related measures, and even new opportunities for injecting hardware Trojans. Ironically, reverse engineering can enable IP owners to verify and validate the design. Nevertheless, this cannot be achieved without overcoming numerous obstacles that limit successful outcomes of the reverse engineering process. This article surveys these challenges from two complementary perspectives: image processing and machine learning. These two fields of study form a firm basis for the enhancement of efficiency and accuracy of reverse engineering processes for both PCBs and ICs. In summary, therefore, this article presents a roadmap indicating clearly the actions to be taken to fulfill hardware trust and assurance objectives.;;;https://dl.acm.org/doi/10.1145/3464959;;;Software AND Engineering
A Blockchain Based Research on Comprehensive Quality Evaluation of Emerging Engineering College Students;;;['Qiujing Liu', 'Yu Dai', 'Wenqi Hong'];;;January 2022;;;IC4E '22: Proceedings of the 2022 13th International Conference on E-Education, E-Business, E-Management, and E-Learning;;;In the context of engineering education transformation and education evaluation reform, this research empirically investigates the status quo of comprehensive quality evaluation of T University students in quantitative research methods, and finds that there are some problems in the current evaluation of students' comprehensive quality, such as incomplete evaluation content, incomplete participation of evaluation subjects, imperfect supervision mechanism in the evaluation process, and weak development function of evaluation. Furthermore, this research uses blockchain to build a comprehensive quality evaluation system for students based on a reputation incentive mechanism, forming a more realistic and objective evaluation atmosphere, and helping to further improve the quality of engineering education.;;;https://dl.acm.org/doi/10.1145/3514262.3514319;;;Software AND Engineering
Engineering Trustable and Auditable Choreography-based Systems Using Blockchain;;;['Flavio Corradini', 'Alessandro Marcelletti', 'Andrea Morichetta', 'Andrea Polini', 'Barbara Re', 'Francesco Tiezzi'];;;None;;;ACM Transactions on Management Information Systems;;;A key challenge in engineering distributed systems consists in the integration into their development of a decentralised infrastructure allowing the system participants to trust each other. In this article, we face such a challenge by proposing a model-driven methodology and a related framework to support the engineering of trustable and auditable systems. The approach is based on choreography diagrams specified in the Business Process Model and Notation standard, describing the interactions that should occur among the distributed components of systems. We support the whole lifecycle of choreographies, from their modelling to their distributed execution and auditing. The framework, based on blockchain technology, is named ChorChain. More specifically, ChorChain takes as input a BPMN choreography model and automatically translates it into a Solidity smart contract. The smart contract permits us to enforce the interactions among the cooperating components as prescribed by the choreography model. By leveraging on the auditability of blockchain, ChorChain also supports the activity of auditors continuously. In such a way, ChorChain enables auditors to get some degree of assurance on what happens simultaneously with, or shortly after, information disclosure. We assess the feasibility and effectiveness of the proposed methodology and framework through experiments conducted on the Rinkeby Ethereum Testnet.;;;https://dl.acm.org/doi/10.1145/3505225;;;Software AND Engineering
Engineering Slidable Graphical User Interfaces with Slime;;;['Arthur Sluÿters', 'Jean Vanderdonckt', 'Radu-Daniel Vatavu'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Intra-platform plasticity regularly assumes that the display of a computing platform remains fixed and rigid during interactions with the platform in contrast to reconfigurable displays, which can change form depending on the context of use. In this paper, we present a model-based approach for designing and deploying graphical user interfaces that support intra-platform plasticity for reconfigurable displays. We instantiate the model for E3Screen, a new device that expands a conventional laptop with two slidable, rotatable, and foldable lateral displays, enabling slidable user interfaces. Based on a UML class diagram as a domain model and a SCRUD list as a task model, we define an abstract user interface as interaction units with a corresponding master-detail design pattern. We then map the abstract user interface to a concrete user interface by applying rules for the reconfiguration, concrete interaction, unit allocation, and widget selection and implement it in JavaScript. In a first experiment, we determine display configurations most preferred by users, which we organize in the form of a state-transition diagram. In a second experiment, we address reconfiguration rules and widget selection rules. A third experiment provides insights into the impact of the lateral displays on a visual search task.;;;https://dl.acm.org/doi/10.1145/3457147;;;Software AND Engineering
A Systematic Literature Review on Federated Machine Learning: From a Software Engineering Perspective;;;['Sin Kit Lo', 'Qinghua Lu', 'Chen Wang', 'Hye-Young Paik', 'Liming Zhu'];;;None;;;ACM Computing Surveys;;;Federated learning is an emerging machine learning paradigm where clients train models locally and formulate a global model based on the local model updates. To identify the state-of-the-art in federated learning and explore how to develop federated learning systems, we perform a systematic literature review from a software engineering perspective, based on 231 primary studies. Our data synthesis covers the lifecycle of federated learning system development that includes background understanding, requirement analysis, architecture design, implementation, and evaluation. We highlight and summarise the findings from the results and identify future trends to encourage researchers to advance their current work.;;;https://dl.acm.org/doi/10.1145/3450288;;;Software AND Engineering
Comprehensive Practice Teaching Mode of Core Course Group of Engineering Cost Specialty Based on Big Data Utility Evaluation;;;['Zhang Xiaoxiao', 'Han Qi', 'Wang Guangjun'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;The future work of engineering cost major students is to use budget software for budget and final accounts, engineering calculation, etc., so the practice teaching is very important. At present, teaching evaluation and examination still stay in the stage of teachers giving cases, students giving results and teachers judging. This leads to a heavy workload of evaluation, and students can not master the degree of mastery of the course. This paper first analyzes the training mode of engineering cost professionals and the situation of training engineering cost professionals at home and abroad. Secondly, it analyzes the software architecture mode and network security of the scoring system, and determines the technology needed for the project. Starting from the development cost and reality, the evaluation system of engineering cost practice teaching software based on Delphi is proposed. Finally, in the process of test management, the black box method is used to design the basic test scheme, and then the white box method is used to supplement some schemes. The results show that the system can better meet the business needs, achieve the automatic scoring target, and effectively improve the efficiency of scoring.;;;https://dl.acm.org/doi/10.1145/3456887.3459687;;;Software AND Engineering
Design and Engineering Application of Ultra-Light Steel Truss Support System for Cantilever Beam Cover;;;['Shengliang Xu', 'Mengshan Wu', 'Xiaoyan Yang'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;The new urban expressway viaduct in soft-soil area is faced with some difficulties, such as poor geological conditions, construction site shortage, and rapid increase in the cost of pond dregs and earthwork. Therefore, the temporary support system of ultra-light large-span covered beam with cantilever is designed. The dead load of cantilever-truss is 15 tons, the cantilever is 9.5 meters, and it can bear the temporary load of 480 tons of cover beam construction. The engineering practice shows that the ultra-light large-span covered beam with cantilever reduces the requirements for traditional technology on temporary measures of material input, lifting machinery and operators. The comprehensive cost and operation cycle of this project are only 45% and 60% of full floating rear axle framing, which has significant economic value and social benefits.;;;https://dl.acm.org/doi/10.1145/3495018.3501236;;;Software AND Engineering
Improving Diversity in Engineering: A Data-Driven Approach to Support Resource Mobilization and Participation in Hashtag Activism Campaigns;;;['Habib Karbasian', 'Hemant Purohit', 'Aditya Johri'];;;August 2021;;;HT '21: Proceedings of the 32nd ACM Conference on Hypertext and Social Media;;;A critical barrier facing engineering is inclusiveness of women in the profession. In recent years, engineering diversity advocates have taken to social media platforms to raise awareness of the issue and redress this problem. A recurring challenge for their initiatives though is attracting and mobilizing participants efficiently. For a successful mobilization campaign, organizers need real-time information about their users and also need to understand what messaging works to attract and mobilize them. We hypothesize that participants in any given campaign related to engineering diversity will also be interested in other campaigns related to that issue. Furthermore, since the primary signal for a social media campaign is a hashtag, by using clustering patterns of various co-occurring hashtags along with relevant topics and relatable sentiments, we can better understand participation and also mobilize users for the target campaign. To empirically examine our hypothesis, we study two diversity hashtag activism campaigns on Twitter (#ILookLikeAnEngineer and #WomenInEngineering) using a real-time predictive analytics framework. We design and evaluate the framework with a set of novel features that uses retweetability as an indicator of participation. Our result analysis for topical features found that monetary gain and advertisement-oriented content were less likely to be propagated in the campaigns whereas messaging aligned directly with the issue at hand such as breaking stereotypes in engineering was deemed more retweetable and engaging. In terms of sentiments, informal tone in the messages were considered desirable whereas short-form messaging were not very popular in either movements. These analytical insights can inform activists in effective resource mobilization through message content design, in order to expand the reach of an activism campaign. Our work shows how data-driven techniques can assist in increasing the participation of women in engineering education and the workforce.;;;https://dl.acm.org/doi/10.1145/3465336.3475103;;;Software AND Engineering
Research on Teaching Reform of Mathematics Courses for Computer Majors in Local Colleges under Emerging Engineering Education;;;['Xuehui Bi', 'Huaming Liu', 'Ying Yang', 'Xiuyou Wang'];;;May 2021;;;ICDEL '21: Proceedings of the 2021 6th International Conference on Distance Education and Learning;;;To develop Emerging engineering education talent with a variety of analytical ability, application ability, innovation ability as a starting point, combined with the actual situation of the School of Computer and Information Engineering of Fuyang Normal University, the teaching reform of the mathematics course for computer majors was discussed from five aspects: perfecting curriculum construction, optimizing teaching content, implementing mixed teaching, strengthening practical teaching and fair examination of results. Improve the quality of students and teaching quality, which further improves the quality of students and the quality of teaching.;;;https://dl.acm.org/doi/10.1145/3474995.3475011;;;Software AND Engineering
Bibliometric Analysis of TCM Knowledge Engineering Based on CNKI;;;['Li Liu', 'Xuebo Li'];;;December 2021;;;WI-IAT '21: IEEE/WIC/ACM International Conference on Web Intelligence and Intelligent Agent Technology;;;None;;;https://dl.acm.org/doi/10.1145/3498851.3498941;;;Software AND Engineering
STRIVE: String-Based Force Feedback for Automotive Engineering;;;['Alexander Achberger', 'Fabian Aust', 'Daniel Pohlandt', 'Kresimir Vidackovic', 'Michael Sedlmair'];;;October 2021;;;UIST '21: The 34th Annual ACM Symposium on User Interface Software and Technology;;;The large potential of force feedback devices for interacting in Virtual Reality (VR) has been illustrated in a plethora of research prototypes. Yet, these devices are still rarely used in practice and it remains an open challenge how to move this research into practice. To that end, we contribute a participatory design study on the use of haptic feedback devices in the automotive industry. Based on a 10-month observing process with 13 engineers, we developed STRIVE, a string-based haptic feedback device. In addition to the design of STRIVE, this process led to a set of requirements for introducing haptic devices into industrial settings, which center around a need for flexibility regarding forces, comfort, and mobility. We evaluated STRIVE with 16 engineers in five different day-to-day automotive VR use cases. The main results show an increased level of trust and perceived safety as well as further challenges towards moving haptics research into practice.;;;https://dl.acm.org/doi/10.1145/3472749.3474790;;;Software AND Engineering
Discussion on the Curriculum of Information Resource Management in Medical Colleges under the "New Engineering";;;['Fanfan Zhu', 'Bingke Zhu', 'Ran Su', 'Jingxin Chen'];;;August 2021;;;IMMS '21: Proceedings of the 4th International Conference on Information Management and Management Science;;;The establishment of information resource management major in medical colleges under the background of "new engineering" is a hotspot currently. Taking the construction of information resources major in Hubei University of Medicine as an example, this paper discusses the relative problems of curriculum setting of this major in medical colleges. Combined with talent cultivation needs and college characteristics, it puts forward suggestions on professional curriculum setting, optional course setting, practical teaching and faculty construction. At present, colleges and universities engaging in the construction of information resource management major is in a relatively small number, curriculum irrationality is a quite common problem, improvement measures shall be taken in combination with the characteristics of the discipline and social requirement.;;;https://dl.acm.org/doi/10.1145/3485190.3485241;;;Software AND Engineering
Hybrid Architecture to Achieve Semantic Interoperability for Engineering Oil and Gas Industry Process;;;['Elvismary Molina De Armas', 'Vitor Pinheiro de Almeida', 'Júlio Gonçalves Campos', 'Geiza Maria Hamazaki da Silva', 'Rodrigo Goyannes Gusmão Caiado', 'Hugo Neves', 'Eduardo Thadeu Leite Corseuil', 'Denyson Tomaz de Lima', 'Fernando Rodrigues Gonzalez'];;;November 2021;;;iiWAS2021: The 23rd International Conference on Information Integration and Web Intelligence;;;In the new era of Information & Communication Technologies, the interoperability between systems has been gaining importance in the industry, becoming the key to achieve better information management, production control, decision making, failure control, and risk management, significantly reducing the production costs. Studies to provide interoperability between systems have been focused on computational architectures, including conceptual models and implementations. In this work, a novel proposed architecture is presented. It is based on paradigms like Polystores and Ontology-based Data Access (OBDA), and streaming data processing over micro-services. Also, an implementation of the proposed architecture was developed. Finally, the approach was evaluated over a case study that integrates engineering data from different data sources in the oil and gas industry context.;;;https://dl.acm.org/doi/10.1145/3487664.3487782;;;Software AND Engineering
Developing a Suitability Assessment Criteria for Software Developers: Behavioral Assessment Using Psychometric Test;;;['Jayati Gulati', 'Bharti Suri', 'Luiz Capretz', 'Bimlesh Wadhwa', 'Anu Lather'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;A suitability assessment instrument for software developers was created using a psychometric criteria that identify the impact of behavior on the performance of software engineers. The instrument uses a questionnaire to help both individuals and IT recruiters to identify the psychological factors that affect the working performance of software engineers. Our study identifies the relationship between the behavioral drivers and the programming abilities of the subjects. In order to evaluate the instrument, a total of 100 respondents were compared on the basis of their programming skills and nine behavioral drivers. It was concluded that there is a direct relationship between certain human qualities, such as “Attention to Detail,” and the programming style of the students, while the “Locus of Control” factor was observed to have a negative correlation with performance in programming.;;;https://dl.acm.org/doi/10.1145/3494885.3494898;;;Software AND Engineering
Research on Application of Virtual Simulation Technology in Underground Engineering Construction Based on Information Technology;;;['Wanbo Qu'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;Driven by virtual simulation technology, China's social economy and high-tech science and technology have shown amazing development trends. In real life, virtual simulation technology is widely used in the construction of construction projects. Used in the process of underground engineering construction, virtual simulation technology can effectively help people find problems in construction. Virtual simulation technology can also be applied to some projects that are not convenient for physical testing for virtual testing. This article discusses the significance of using virtual simulation technology in underground engineering construction and how virtual simulation technology is the future application prospects are discussed.;;;https://dl.acm.org/doi/10.1145/3495018.3495368;;;Software AND Engineering
Continuous Software Bug Prediction;;;['Song Wang', 'Junjie Wang', 'Jaechang Nam', 'Nachiappan Nagappan'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Many software bug prediction models have been proposed and evaluated on a set of well-known benchmark datasets. We conducted pilot studies on the widely used benchmark datasets and observed common issues among them. Specifically, most of existing benchmark datasets consist of randomly selected historical versions of software projects, which poses non-trivial threats to the validity of existing bug prediction studies since the real-world software projects often evolve continuously. Yet how to conduct software bug prediction in the real-world continuous software development scenarios is not well studied. Aims: In this paper, to bridge the gap between current software bug prediction practice and real-world continuous software development, we propose new approaches to conduct bug prediction in real-world continuous software development regarding model building, updating, and evaluation. Method: For model building, we propose ConBuild, which leverages distributional characteristics of bug prediction data to guide the training version selection. For model updating, we propose ConUpdate, which leverages the evolution of distributional characteristics of bug prediction data between versions to guide the reuse or update of bug prediction models in continuous software development. For model evaluation, we propose ConEA, which leverages the evolution of buggy probability of files between versions to conduct effort-aware evaluation. Results: Experiments on 120 continuously release versions that span across six large-scale open-source software systems show the practical value of our approaches. Conclusions: This paper provides new insights and guidelines for conducting software bug prediction in the context of continuous software development.;;;https://dl.acm.org/doi/10.1145/3475716.3475790;;;Software AND Engineering
Use of Hands-on and Remote Lab with an Inquiry-Based Approach to Learn Statistics in Engineering;;;['Marcelo Zannin', 'Natércia Lima', 'Carla Pinto'];;;October 2021;;;TEEM'21: Ninth International Conference on Technological Ecosystems for Enhancing Multiculturality (TEEM&apos;21);;;Practical activities are an effective way to contextualize concepts and motivate students. This article reports on an innovative use of hands-on and remote labs in a theoretical course of Statistics for engineering undergraduates. The lecturer used an inquiry-based approach to center learning around students. The problems proposed revolved around basic concepts of circuit theory: how reliable are resistance values and how does a resistor behave in an electric circuit. Students collected data and learned statistics while attempted to address the problems. We report on two implementations done in 2017, at Universidade Federal de Santa Catarina (Brazil), where 68 students concluded the course. We investigated the effects of such strategy, analyzing assessment results, attendance and accesses to the remote lab. We also surveyed the lecturer and students on the methodology and the use of the remote lab. Our results show that students and lecturer had positive views on the experience and suggest that students felt motivated to collaborate and learn statistics. We also found correlation among grades in lab activities and final grades, which shows the hands-on activities had a positive impact on students' academic performance.;;;https://dl.acm.org/doi/10.1145/3486011.3486513;;;Software AND Engineering
Recommender Systems for Software Project Managers;;;['Liang Wei', 'Luiz Fernando Capretz'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;The design of recommendation systems is based on complex information processing and big data interaction. This personalized view has evolved into a hot area in the past decade, where applications might have been proved to help for solving problem in the software development field. Therefore, with the evolvement of Recommendation System in Software Engineering (RSSE), the coordination of software projects with their stakeholders is improving. This experiment examines four open source recommender systems and implemented a customized recommender engine with two industrial-oriented packages: Lenskit and Mahout. Each of the main functions was examined and issues were identified during the experiment.;;;https://dl.acm.org/doi/10.1145/3463274.3463951;;;Software AND Engineering
Research on Reconstruction Technology for Injection Molding Screws Based on Reverse Engineering;;;['Juntao Li', 'Jiazhong Xu'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;The injection molding screw is an important part of the injection molding machine. The screw rotates inside the barrel, which interact to convey, compact, melt, stir and generate pressure on the plastic. As the screw rotates, the plastic creates friction with the barrel wall, the channel bottom, the pushing flight of the screw, and other plastic. In the design and manufacture of injection screws, conventional measuring tools like bit gauges, angle gauges and micrometers are used for surveying and mapping, so it is usually difficult to get a refined model, and the machining quality of injection screws is inspected using conventional measuring tools or using only the naked eye. Conventional technologies result in low precision, low efficiency, and unsystematic methods, while 3D scanning and reverse engineering offers advanced technology, high precision and high efficiency, and it has been more commonly applied to the industrial manufacturing industry in recent years. In this case, many people are increasingly conducting research regarding the application of 3D scanning and reverse engineering in the design and manufacture of injection screws and machining quality inspection. In this paper, a new scanning system named Win3D-M and related design software are employed to perform reverse engineering, surface reconstruction and improvement of the injection screw, with an aim to expand the scope of application of 3D scanning and reverse engineering and serve as a useful reference for the development work of injection molding screws. As compared to traditional theoretical and experimental research, using reverse engineering in injection molding screw design can shorten the design cycle and reduce design costs; the 3D geometric model provides some reference for improving and optimizing the structure of the injection molding screw and CAM machining later on.;;;https://dl.acm.org/doi/10.1145/3495018.3501129;;;Software AND Engineering
Games: The Motivation in Engineering Education;;;['Bertil P. Marques', 'Rosa Reis', 'Marílio Cardoso'];;;October 2021;;;TEEM'21: Ninth International Conference on Technological Ecosystems for Enhancing Multiculturality (TEEM&apos;21);;;The increased use of educational games as educational tools in classes is mainly explained by the motivational power that is attributed to games. In general, and by the need to change methodologies for emergency education. This article investigates the role of different motivational forms in educational games and the influence of the game context in teaching in motivating students to engage in the game. Based on self-determination theory and a mixed-method case study approach, seven educational games were studied in a graduate-level engineering course in two consecutive years. The authors reveal through the research that different motivational forms can coexist when students play games and that the interaction between the attractiveness of the game, learning and its operability can explain the emergence of motivational forms leading to the academic success of the subject in question.;;;https://dl.acm.org/doi/10.1145/3486011.3486483;;;Software AND Engineering
On Re-engineering the X.509 PKI with Executable Specification for Better Implementation Guarantees;;;['Joyanta Debnath', 'Sze Yiu Chau', 'Omar Chowdhury'];;;November 2021;;;CCS '21: Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security;;;The X.509 Public-Key Infrastructure (PKI) standard is widely used as a scalable and flexible authentication mechanism. Flaws in X.509 implementations can make relying applications susceptible to impersonation attacks or interoperability issues. In practice, many libraries implementing X.509 have been shown to suffer from flaws that are due to noncompliance with the standard. Developing a compliant implementation is especially hindered by the design complexity, ambiguities, or under-specifications in the standard written in natural languages. In this paper, we set out to alleviate this unsatisfactory state of affairs by re-engineering and formalizing a widely used fragment of the X.509 standard specification, and then using it to develop a high-assurance implementation. Our X.509 specification re-engineering effort is guided by the principle of decoupling the syntactic requirements from the semantic requirements. For formalizing the syntactic requirements of X.509 standard, we observe that a restricted fragment of attribute grammar is sufficient. In contrast, for precisely capturing the semantic requirements imposed on the most-widely used X.509 features, we use quantifier-free first-order logic (QFFOL). Interestingly, using QFFOL results in an executable specification that can be efficiently enforced by an SMT solver. We use these and other insights to develop a high-assurance X.509 implementation named CERES. A comparison of CERES with 3 mainstream libraries (i.e., mbedTLS, OpenSSL, and GnuTLS) based on 2 million real certificate chains and 2 million synthetic certificate chains shows that CERES rightfully rejects malformed and invalid certificates.;;;https://dl.acm.org/doi/10.1145/3460120.3484793;;;Software AND Engineering
Research on Influencing Factors of Engineering Students’ Classroom Satisfaction Based on Factor Analysis Theory from the Perspective of General Education;;;['Zhou Yan', 'Zhou Jun', 'Yao Cenglin'];;;December 2021;;;EBIMCS '21: Proceedings of the 2021 4th International Conference on E-Business, Information Management and Computer Science;;;The concept of general education focuses on cultivating compound and innovative talents. Its purpose is to cultivate people's comprehensive development. With the development of science and technology, the social demand for talents is changed from professional to compound general talents.Therefore, it is particularly important for science and engineering majors to vigorously implement general education to cultivate comprehensive talents suitable for economic development.From the perspective of general education and based on the theory of factor analysis, this paper selects 501 engineering students as research objects to study the factors of students' classroom satisfaction. Four common factors were obtained by using the method of principal component extraction for dimension reduction of the proposed 16 variables, and the four main factors affecting classroom satisfaction were summarized according to the variance contribution rate. They are teaching form factor (22.460%), teaching content factor (20.853%), teaching attitude factor (18.401%) and classroom assessment factor (15.159%).Then, through the demographic difference test, it also analyzes the significant difference between gender and grade on the influencing factors. Based on this, it is proposed that teachers should pay attention to personal charm and pay more attention to the needs and feelings of students to improve the quality of classroom teaching and improve the classroom teaching satisfaction of engineering students.;;;https://dl.acm.org/doi/10.1145/3511716.3511742;;;Software AND Engineering
The Impact of Employability Skills on Employers' Satisfaction: A Conceptual Model for Fresh Graduates of Engineering;;;['Faisal Sjawie', 'Romadhani Ardi'];;;May 2021;;;APCORISE '21: Proceedings of the 4th Asia Pacific Conference on Research in Industrial and Systems Engineering;;;Corporations require employees to catch up with the continuous changes that happened in the industries. Technology development and corporations' expansion globally drive soft skills to become so essential. Employability skills and positive attitudes become the most important things considered by employers for recruiting fresh graduates. In Indonesia, the number of engineering bachelor's required is increasing each year. The manufacturing industry in Indonesia is one of the most critical sectors, which shows by the industry contribution to Indonesia's Gross Domestic Product. The study's objectives are to develop a conceptual model for employability skills among fresh graduates of engineering regarding employers' satisfaction and hiring intention and to analyze the skills gap between skills importance and skills possessed, perceived by employers. The model included seven skills as part of employability skills: communication skills, professional skills, core employability skills, thinking skills, interpersonal skills, computing skills, and enterprise and entrepreneurial skills. Two other variables are employers' satisfaction and employers' hiring intention. The data were gathered through a structured questionnaire from employers in manufacturing corporations employing fresh graduates of engineering from Indonesia Universities and Institutes.;;;https://dl.acm.org/doi/10.1145/3468013.3468332;;;Software AND Engineering
Application of Digital Signal Processing Technology in Electronic Information Engineering;;;['Hu Sheng', 'Hongxin Li'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;Due to the rapid development of modern technology, digital signal processing technology has been widely used in many fields. Among them, the application of digital signal processing technology to the field of electronic information industry has a significant impact on its development. This article mainly focuses on the application of digital signal processing technology in electronic information engineering. On the basis of a large number of documents, it understands the relevant theoretical issues of digital signal processing technology and electronic information engineering, and then analyzes the PSD using digital signal processing technology. The synchronous measurement system was designed to illustrate the practical application of digital signal processing technology in electronic information engineering. Finally, the designed system was tested, and the test conclusions confirmed that the measurement accuracy of the system in this paper is percent within four.;;;https://dl.acm.org/doi/10.1145/3495018.3495504;;;Software AND Engineering
Supporting sustainability design through agile software development;;;['Hatef Shamshiri'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Context: Sustainability has become an important topic for researchers and is gaining popularity among software development companies, but integrating it into their development processes is still lacking.  Objectives: This paper aimed to discuss the purpose of doctoral research, the research questions, the steps to answer the research questions, and the research's current progress concerning sustainability in the software development life cycle. Results: I have presented the high-level plans for the doctoral research and outlined the first part of the results of phase 1. As part of this phase 1, I have conducted an extensive literature review to collect data about sustainability in companies' agile methods. I found only a few studies reporting sustainability in agile software development, and this finding proposes that either this field was not studied, or the results have not been widely published, indicating a gap in research.;;;https://dl.acm.org/doi/10.1145/3463274.3463347;;;Software AND Engineering
Stop building castles on a swamp!: the crisis of reproducing automatic search in evidence-based software engineering;;;['Zheng Li'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;The evidence-based approach has increasingly been employed to synthesize empirical findings from the primary research in software engineering. Nevertheless, the reproducibility of evidence-based software engineering (EBSE) studies seems to be underemphasized. In our investigation into the automatic search of 311 sample studies, more than 50% of the search strings are not reusable; about 87.5% of the search activities (e.g., search field settings) are unrepeatable; and more than 95% of the whole automatic search implementations are unreproducible. Considering that searching is a cornerstone of an EBSE study, we are afraid that the reproducibility of the current secondary research could be worse than we can imagine. By analyzing and reporting the root causes of the aforementioned observations, we urge collaboration and cooperation among all the stakeholders in our community to improve the research reproducibility in EBSE.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00012;;;Software AND Engineering
Contextual Understanding and Improvement of Metamorphic Testing in Scientific Software Development;;;['Zedong Peng', 'Upulee Kanewala', 'Nan Niu'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Metamorphic testing emerges as a simple and effective approach for testing scientific software; yet, its adoption in actual scientific software projects is less studied. Aims: In order for the practitioners to better adopt metamorphic testing in their projects, we set out to first gain a deep understanding about the current qualify assurance workflow, testing practices, and tools. Method: We propose to integrate various empirical sources, including artifact analysis, stakeholder interviews, and gap analysis from the literature. Results: Applying our approach to the Open Water Analytics Stormwater Management Model project helped to identify four new needs requiring continued and more research: (1) systematic and explicit formulation of metamorphic relations, (2) metamorphic testing examples specific to the scientific software, (3) correlating metamorphic testing with regression testing, and (4) integrating metamorphic testing with build tools like CMake and continuous integration tools like GitHub Actions. Conclusions: Integrating different empirical sources is promising for establishing a contextual understanding of software engineering practices, and for action research, such as workflow refinements and tool interventions, to be carried out in a principled manner.;;;https://dl.acm.org/doi/10.1145/3475716.3484188;;;Software AND Engineering
Awareness and perception of Agile in saudi software industry;;;['Fahad S Altuwaijri', 'Maria Angela Ferrario'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;Over the last two decades, Agile software development methodology has garnered significant interest in both software industry and research with several studies investigating the level of awareness, perception and use of Agile in software engineering practice. However, most of these studies have focused on Agile practice in developed countries, with only a handful having been conducted in developing countries, especially in the Middle East. This is problematic given the strategic and economic importance of software industry in countries such as Saudi Arabia. This paper aims to start addressing this research gap with an empirical investigation of the awareness and perceptions of Agile among software practitioners in Saudi Arabia and the extent to which they are adopting Agile methods. To this end, we conduct four semi-structured interviews with expert software practitioners and a survey with 31 respondents, all from the mobile development software industry. Our findings indicate that there it seems to be a low level of awareness and usage of Agile in the country. However, we also find that those who use Agile, are appreciative of its benefits which include project management flexibility, rapid response to change, and a positive effect on team morale and communication.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00010;;;Software AND Engineering
Teaching Computer Networks to Electrical Engineering Students by a Lecture-based Course and a Lab Course: A Quantitative Analysis of Students’ Perceptions;;;['Atef Abdrabou', 'Walid Shakhatreh'];;;April 2021;;;ICIEI '21: Proceedings of the 6th International Conference on Information and Education Innovations;;;This paper investigates the effectiveness, from students’ perspectives, of teaching computer networking to electrical engineering undergrads by a classic course in data communication and a task-oriented lab course. Students’ opinions are quantitatively analyzed via an outcome-based learning approach, where the learning outcomes of both courses are detailed and evaluated by the students. The results reveal a varying degree of effectiveness based mainly on the relevance of a learning outcome to the students’ daily life experiences.;;;https://dl.acm.org/doi/10.1145/3470716.3470721;;;Software AND Engineering
Risk Assessments of Social Engineering Attacks and Set Controls in an Online Education Environment;;;['Eric Blancaflor', 'Clarion Von Harvey Banzon', 'Craig James J Jackson', 'Jameela Nadine Jamena', 'Jeffrey Miraflores', 'Leanne Kirsten Samala'];;;May 2021;;;ICMET 2021: 2021 3rd International Conference on Modern Educational Technology;;;The cybersecurity attacks for the educational field is not too highlighted in today's time. There is an incoming threat in the educational field that if not look into can result into a dangerous attack than can victimized students and educational institutions, especially those who are from third world countries. This study is to alert and to inform everyone about the vulnerability in gathering data using education as a facade that may result in a serious breach of privacy and security. In this study, a very simple method of getting data was used - survey. The study conducted an experiment where surveys were given to many students and see if they will give their information if they were told that it was for an academic purpose. Plenty of students have answered the survey which aims to get their email address, name, social media accounts and more. From there, the researchers sent the students phishing emails to test if they are mindful of these cyberattacks. The researchers also use the information from the survey to do reconnaissance. This study will show how vulnerable the educational field is to basic cyberattacks and will give some informative recommendations on what to do.;;;https://dl.acm.org/doi/10.1145/3468978.3468990;;;Software AND Engineering
Research on Construction Problems of Railway Engineering Based on Computer;;;['Chenyu Wu'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the rapid development of social economy, traffic engineering has become the focus of people's attention. At present, railway engineering occupies an important position in the field of engineering construction in China, which is of great significance to the construction of transportation network. Under the new situation, with the increasingly perfect market economic system and increasingly fierce competition, it has become the development task of railway engineering to improve the construction management of railway departments. Therefore, in the practical work, we should do a good job in the research and analysis of the construction technology, find out the problems existing in the construction, and make good use of the railway engineering construction technology on this basis. Based on this, this paper briefly expounds the computer visualization of the key points of railway engineering construction technology management, and puts forward some personal views for reference only.;;;https://dl.acm.org/doi/10.1145/3482632.3482692;;;Software AND Engineering
Multi-objectivizing software configuration tuning;;;['Tao Chen', 'Miqing Li'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Automatically tuning software configuration for optimizing a single performance attribute (e.g., minimizing latency) is not trivial, due to the nature of the configuration systems (e.g., complex landscape and expensive measurement). To deal with the problem, existing work has been focusing on developing various effective optimizers. However, a prominent issue that all these optimizers need to take care of is how to avoid the search being trapped in local optima — a hard nut to crack for software configuration tuning due to its rugged and sparse landscape, and neighboring configurations tending to behave very differently. Overcoming such in an expensive measurement setting is even more challenging. In this paper, we take a different perspective to tackle this issue. Instead of focusing on improving the optimizer, we work on the level of optimization model. We do this by proposing a meta multi-objectivization model (MMO) that considers an auxiliary performance objective (e.g., throughput in addition to latency). What makes this model unique is that we do not optimize the auxiliary performance objective, but rather use it to make similarly-performing while different configurations less comparable (i.e. Pareto nondominated to each other), thus preventing the search from being trapped in local optima.   Experiments on eight real-world software systems/environments with diverse performance attributes reveal that our MMO model is statistically more effective than state-of-the-art single-objective counterparts in overcoming local optima (up to 42% gain), while using as low as 24% of their measurements to achieve the same (or better) performance result.;;;https://dl.acm.org/doi/10.1145/3468264.3468555;;;Software AND Engineering
Enhancing Genetic Improvement of Software with Regression Test Selection;;;['Giovani Guizzo', 'Justyna Petke', 'Federica Sarro', 'Mark Harman'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Genetic improvement uses artificial intelligence to automatically improve software with respect to non-functional properties (AI for SE). In this paper, we propose the use of existing software engineering best practice to enhance Genetic Improvement (SE for AI). We conjecture that existing Regression Test Selection (RTS) techniques (which have been proven to be efficient and effective) can and should be used as a core component of the GI search process for maximising its effectiveness. To assess our idea, we have carried out a thorough empirical study assessing the use of both dynamic and static RTS techniques with GI to improve seven real-world software programs. The results of our empirical evaluation show that incorporation of RTS within GI significantly speeds up the whole GI process, making it up to 68% faster on our benchmark set, being still able to produce valid software improvements. Our findings are significant in that they can save hours to days of computational time, and can facilitate the uptake of GI in an industrial setting, by significantly reducing the time for the developer to receive feedback from such an automated technique. Therefore, we recommend the use of RTS in future test-based automated software improvement work. Finally, we hope this successful application of SE for AI will encourage other researchers to investigate further applications in this area.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00120;;;Software AND Engineering
Achieving Standard Software Security in Agile Developments;;;['Geofrey G. Kagombe', 'Ronald Waweru Mwangi', 'Joseph Muliaro Wafula'];;;August 2021;;;ICICM '21: Proceedings of the 11th International Conference on Information Communication and Management;;;The introduction of agile software development methods has brought about diverse benefits to the industry. These range from rapid deployment of software products to satisfying the ever changing customer requirements among others. These have in turn fueled the rapid adoption of these methodologies within the industry. On the down side, agile approach has been proved to be weak in handling security and therefore not appropriate for developing secure systems. The framework we present in this paper addresses this by ensuring that security is in the development process from the beginning of the project to the end. It is modeled after the SSE-CMM as a standard for security engineering. Considering its process areas, it aims to achieve the intended security goals within the agile process to appropriate levels by adopting agility in the implementation of these activities. The criteria of implementation are agility plus the SSE-CMM process areas goals. The framework is tested through a case study to check the capability levels achieved and the agility of the resultant process.;;;https://dl.acm.org/doi/10.1145/3484399.3484403;;;Software AND Engineering
Non-recurring engineering (NRE) best practices: a case study with the NERSC/NVIDIA OpenMP contract;;;['Christopher S. Daley', 'Annemarie Southwell', 'Rahulkumar Gayatri', 'Scott Biersdorfff', 'Craig Toepfer', 'Güray Özen', 'Nicholas J. Wright'];;;November 2021;;;SC '21: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis;;;The NERSC supercomputer, Perlmutter, consists of AMD CPUs and NVIDIA GPUs. NERSC users expect to be able to use OpenMP to take advantage of the highly capable GPUs. This paper describes how NERSC/NVIDIA constructed a Non-Recurring Engineering (NRE) contract to add OpenMP GPU-offload support to the NVIDIA HPC compilers. The paper describes how the contract incorporated the strengths of both parties and encouraged collaboration to improve the quality of the final deliverable. We include our best practices and how this particular contract took into account emerging OpenMP specifications, NERSC workload requirements, and how to use OpenMP most efficiently on GPU hardware. This paper includes OpenMP application performance results obtained with the NVIDIA compilers distributed in the NVIDIA HPC SDK.;;;https://dl.acm.org/doi/10.1145/3458817.3476213;;;Software AND Engineering
Construction of BIM Engineering Information Management Platform Based on Data Mining Technology;;;['Bingjin Xu'];;;December 2021;;;ICASIT 2021: 2021 International Conference on Aviation Safety and Information Technology;;;Data mining technology is one of the current research hotspots in the field of database and artificial intelligence. From the massive amount of data information, practical information that is easy to understand, rich, hidden, potentially effective, and unknown can be easily extracted. It combines the theories of database management technology, pattern recognition technology, artificial intelligence, machine learning, statistics and many other disciplines to form new technical methods. This article aims to study the construction of a BIM engineering information management platform based on data mining technology. Based on the analysis of data mining methods and the characteristics of BIM, the BIM engineering information management platform is designed and implemented, and finally the platform is tested. The test results show that when the amount of data is large, the speedup ratio is positively correlated with the number of nodes in a certain proportion. As the number of nodes increases, the ratio remains almost unchanged. This shows that as the number of nodes increases, the Hadoop cluster is significantly more efficient than a stand-alone machine. It is also relatively stable.;;;https://dl.acm.org/doi/10.1145/3510858.3510960;;;Software AND Engineering
Infiltrating security into development: exploring the world’s largest software security study;;;['Charles Weir', 'Sammy Migues', 'Mike Ware', 'Laurie Williams'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Recent years have seen rapid increases in cybercrime. The use of effective software security activities plays an important part in preventing the harm involved. Objective research on industry use of software security practices is needed to help development teams, academic researchers, and educators to focus their activities.   Since 2008, a team of researchers, including two of the authors, has been gathering objective data on the use of 121 software security activities. The Building Security In Maturity Model (BSIMM) study explores the activity use of 675,000 software developers, in companies including some of the world’s largest and most security-focused.   Our analysis of the study data shows little consistent growth in security activity adoption industry-wide until 2015. Since then, the data shows a strong increasing trend, along with the adoption of new activities to support cloud-based deployment, an emphasis on component security, and a reduction in security professionals’ policing role. Exploring patterns of adoption, activities related to detecting and responding to vulnerabilities are adopted marginally earlier than activities related to preventing vulnerabilities; and activities related to particular job roles tend to be used together. We also found that 12 developer security activities are adopted early, together, and notably more often than any others.   From these results, we offer recommendations for software and security engineers, and corresponding education and research suggestions for academia. These recommendations offer a strong contribution to improving security in development teams in the future.;;;https://dl.acm.org/doi/10.1145/3468264.3473926;;;Software AND Engineering
Evolving software to be ML-driven utilizing real-world A/B testing: experiences, insights, challenges;;;['Paul Luo Li', 'Xiaoyu Chai', 'Frederick Campbell', 'Jilong Liao', 'Neeraja Abburu', 'Minsuk Kang', 'Irina Niculescu', 'Greg Brake', 'Siddharth Patil', 'James Dooley', 'Brandon Paddock'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;ML-driven software is heralded as the next major advancement in software engineering; existing software today can benefit from being evolved to be ML-driven. In this paper, we contribute practical knowledge about evolving software to be ML-driven, utilizing real-world A/B testing. We draw on experiences evolving two software features from the Windows operating system to be ML-driven, with more than ten realworld A/B tests on millions of PCs over more than two years. We discuss practical reasons for using A/B testing to engineer ML-driven software, insights for success, as well as on-going realworld challenges. This knowledge may help practitioners, as well as help direct future research and innovations.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00026;;;Software AND Engineering
Engineering a Complete Curriculum Overhaul;;;['Luther Tychonievich', 'Mark Sherriff'];;;February 2022;;;SIGCSE 2022: Proceedings of the 53rd ACM Technical Symposium on Computer Science Education - Volume 1;;;We present an eight-year curriculum redesign effort impacting al-most every course in our computer science department. Having not made a major update to our curriculum in two decades, complications began to arise from significant increases in enrollment and instituting multiple degrees in computing in the same department. Starting from a desire to adjust a few courses, we systematically collected a broad set of requirements and blue-sky ideas from many stakeholders, resulting in an unsatisfiable set of content, ordering, and course boundary constraints. After multiple rounds of conversation with our stakeholders in and out of the department, we evolved and relaxed several of our constraints, allowing us to develop a compromise plan for seven new courses and a new prerequisite system. We then piloted five of the new courses and collected feedback on results, iterating on these courses each semester for two years. We worked with registrars, advisors, and administrators to develop a transition plan from old to new courses. This paper presents highlights of each step of this process, a summary of the resulting curriculum design, and reflections and recommendations for other departments that may want to undertake a similar update.;;;https://dl.acm.org/doi/10.1145/3478431.3499287;;;Software AND Engineering
Human Factors and their Influence on Software Development Teams - A Tertiary Study;;;['Eliezer Dutra', 'Bruna Diirr', 'Gleison Santos'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Background: Software organizations increasingly need developers with high skills for social interactions. Managers, leaders, and academics need to know the human factors influencing the individuals, the development team, and the software project activities. Despite the increasing number of secondary studies about human factors in Software Engineering (SE) and in Agile Software Development (ASD), there is no study synthesizing which human factors influence software development without a specific perspective from SE or human factor thematic. Objective: We aim to summarise human factors and their influence on SE development teams and ASD teams. Method: We executed a tertiary study. We used thematic analysis to examine the resulting data. Results: We found 29 systematic literature reviews and systematic mapping studies addressing the human perspective in SE teams. We identified 101 human factors and 79 influences grouped in 4 categories (Team member, Team, Project, and Organization). Also, we identified 71 human factors and 60 influences on ASD. The most investigated human factors are Communication, Collaboration, Knowledge, and Motivation. Conclusions: The identified human factors and their influences can be considered most significant by software organizations, researchers, and academics in SE practices. Based on our results, practitioners might propose activities that enhance human capital behaviors that influence individual motivation, agile mindset, team climate, software quality, or agile transition in traditional organizations.;;;https://dl.acm.org/doi/10.1145/3474624.3474625;;;Software AND Engineering
Resolute assurance arguments for cyber assured systems engineering;;;['Isaac Amundson', 'Darren Cofer'];;;May 2021;;;Destion '21: Proceedings of the Workshop on Design Automation for CPS and IoT;;;Resolute is a tool and language for embedding an assurance argument in a system architecture model and evaluating the validity of the associated evidence. In this paper we report on a number of extensions to Resolute that support systems engineers in developing safe and cyber-resilient systems. System requirements are imported as assurance goals to be satisfied. Architectural transforms are applied to the system model to address these requirements, while corresponding assurance strategies and evidence are automatically added to document how the requirements have been satisfied. Subsequent changes to the model that invalidate any of the assurance claims can be detected and corrected. We also use Resolute to check that the model satisfies rules for code generation and other modeling guidelines. We conclude with an application of the Resolute assurance process to the design of a mission planning system for an unmanned air vehicle.;;;https://dl.acm.org/doi/10.1145/3445034.3460507;;;Software AND Engineering
Quantum Software: Model-driven or Search-driven? A Q-SE 2021 Workshop Report;;;['Rui Abreu', 'Shaukat Ali', 'Tao Yue', 'Michael Felderer', 'Iaakov Exman'];;;October 2021;;;ACM SIGSOFT Software Engineering Notes;;;Quantum Software is a formidable challenge. This is a conse- quence of a rst encounter between software, usually perceived as an engineering discipline, and quantum computing, an outgrowth of two complex and fundamental sciences: physics and computer science. However, Quantum Software is a signi cant creativity op- portunity. This short paper characterizes the unique opportunity, while keeping in mind the great challenge. It also stands as a re- port of a workshop (Q-SE 2021) exactly created to promote under- standing and trigger motivation to exploit this opportunity, while overcoming the challenge. Q-SE 2021 | the 2nd International Workshop on Quantum Software Engineering | was co-located with the 43rd International Conference on Software Engineering (ICSE 2021). Q-SE 2021 was virtually held on June 1 and June 2 of 2021.;;;https://dl.acm.org/doi/10.1145/3485952.3485958;;;Software AND Engineering
Engineering Practical Lempel-Ziv Tries;;;['Diego Arroyuelo', 'Rodrigo Cánovas', 'Johannes Fischer', 'Dominik Köppl', 'Marvin Löbel', 'Gonzalo Navarro', 'Rajeev Raman'];;;None;;;ACM Journal of Experimental Algorithmics;;;The Lempel-Ziv 78 (LZ78) and Lempel-Ziv-Welch (LZW) text factorizations are popular, not only for bare compression but also for building compressed data structures on top of them. Their regular factor structure makes them computable within space bounded by the compressed output size. In this article, we carry out the first thorough study of low-memory LZ78 and LZW text factorization algorithms, introducing more efficient alternatives to the classical methods, as well as new techniques that can run within less memory space than the necessary to hold the compressed file. Our results build on hash-based representations of tries that may have independent interest.;;;https://dl.acm.org/doi/10.1145/3481638;;;Software AND Engineering
Application of Civil Engineering Professional Learning Based on Computer and BIM Technology;;;['Qiang Chen'];;;August 2021;;;ICIMTECH 21: <italic toggle='yes'>Retracted on September 15, 2021</italic>The Sixth International Conference on Information Management and Technology;;;NOTICE OF RETRACTION: While investigating potential publication-related misconduct in connection with the ICIMTech 2021 Conference Proceedings, serious concerns were raised that cast doubt on the integrity of the peer-review process and all papers published in the Proceedings of this Conference. The integrity of the entire Conference has been called into question. As a result, of its investigation, ACM has decided to retract the Entire Conference Proceedings and all related papers from the ACM Digital Library.None of the papers from this Proceeding should be cited in the literature because of the questionable integrity of the peer review process for this Conference.;;;https://dl.acm.org/doi/10.1145/3465631.3465921;;;Software AND Engineering
Research on 3D Digital Design of Urban Rail Transit Engineering Based on BIM;;;['Bingye Yang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;In the process of urban rail transit engineering construction, various advanced technologies will be applied, among which BIM technology has been widely used in various industries as a new technology, and has been effectively applied in urban rail transit engineering design. BIM is the building information model, which analyzes various data in engineering construction by using 3D digital model and puts forward corresponding decisions. BIM is based on the established 3D information model, which enables different participants from the project to exchange and share information in the whole life cycle of the project, thus greatly improving the production efficiency and engineering quality. The information integration of BIM Technology mainly embodies the integration of design process and design information. Based on the application of BIM Technology in urban rail transit engineering construction, this paper studies the application of BIM Technology in three-dimensional digital design of rail transit engineering, and provides some reference for the application of BIM Technology in rail transit engineering.;;;https://dl.acm.org/doi/10.1145/3482632.3483992;;;Software AND Engineering
Synthesizing Object State Transformers for Dynamic Software Updates;;;['Zelin Zhao', 'Yanyan Jiang', 'Chang Xu', 'Tianxiao Gu', 'Xiaoxing Ma'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;There is an increasing demand for evolving software systems to deliver continuous services of no restart. Dynamic software update (DSU) aims to achieve this goal by patching the system state on the fly but is currently hindered from practice due to non-trivial cross-version object state transformations. This paper revisits this problem through an in-depth empirical study of over 190 class changes from Tomcat 8. The study produced an important finding that most non-trivial object state transformers can be constructed by reassembling existing old/new version code snippets. This paper presents a domain-specific language and an efficient algorithm for synthesizing non-trivial object transformers over code reuse. We experimentally evaluated our tool implementation PASTA with real-world software systems, reporting PASTA's effectiveness in succeeding in 7.5x non-trivial object transformation tasks compared with the best existing DSU techniques.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00103;;;Software AND Engineering
Screen Parsing: Towards Reverse Engineering of UI Models from Screenshots;;;['Jason Wu', 'Xiaoyi Zhang', 'Jeff Nichols', 'Jeffrey P Bigham'];;;October 2021;;;UIST '21: The 34th Annual ACM Symposium on User Interface Software and Technology;;;Automated understanding of user interfaces (UIs) from their pixels can improve accessibility, enable task automation, and facilitate interface design without relying on developers to comprehensively provide metadata. A first step is to infer what UI elements exist on a screen, but current approaches are limited in how they infer how those elements are semantically grouped into structured interface definitions. In this paper, we motivate the problem of screen parsing, the task of predicting UI elements and their relationships from a screenshot. We describe our implementation of screen parsing and provide an effective training procedure that optimizes its performance. In an evaluation comparing the accuracy of the generated output, we find that our implementation significantly outperforms current systems (up to 23%). Finally, we show three example applications that are facilitated by screen parsing: (i) UI similarity search, (ii) accessibility enhancement, and (iii) code generation from UI screenshots.;;;https://dl.acm.org/doi/10.1145/3472749.3474763;;;Software AND Engineering
DIFFBASE: a differential factbase for effective software evolution management;;;['Xiuheng Wu', 'Chenguang Zhu', 'Yi Li'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Numerous tools and techniques have been developed to extract and analyze information from software development artifacts. Yet, there is a lack of effective method to process, store, and exchange information among different analyses. In this paper, we propose differential factbase, a uniform exchangeable representation supporting efficient querying and manipulation, based on the existing concept of program facts. We consider program changes as first-class objects, which establish links between intra-version facts of single program snapshots and provide insights on how certain artifacts evolve over time via inter-version facts. We implement a series of differential fact extractors supporting different programming languages and platforms, and demonstrate with usage scenarios the benefits of adopting differential facts in supporting software evolution management.;;;https://dl.acm.org/doi/10.1145/3468264.3468605;;;Software AND Engineering
Enterprise-driven open source software: a case study on security automation;;;['Florian Angermeir', 'Markus Voggenreiter', 'Fabiola Moyón', 'Daniel Mendez'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Agile and DevOps are widely adopted by the industry. Hence, integrating security activities with industrial practices, such as continuous integration (CI) pipelines, is necessary to detect security flaws and adhere to regulators' demands early. In this paper, we analyze automated security activities in CI pipelines of enterprise-driven open source software (OSS). This shall allow us, in the long-run, to better understand the extent to which security activities are (or should be) part of automated pipelines. In particular, we mine publicly available OSS repositories and survey a sample of project maintainers to better understand the role that security activities and their related tools play in their CI pipelines. To increase transparency and allow other researchers to replicate our study (and to take different perspectives), we further disclose our research artefacts. Our results indicate that security activities in enterprise-driven OSS projects are scarce and protection coverage is rather low. Only 6.83% of the analyzed 8,243 projects apply security automation in their CI pipelines, even though maintainers consider security to be rather important. This alerts industry to keep the focus on vulnerabilities of 3rd Party software and it opens space for other improvements of practice which we outline in this manuscript.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00037;;;Software AND Engineering
Algorithm integration model for computer aided engineering based on Backtracking Algorithm;;;['Zerui Li'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;None;;;https://dl.acm.org/doi/10.1145/3482632.3482745;;;Software AND Engineering
A Framework for the Adoption of Agile within Software SMEs in Saudi Arabia;;;['Fahad Altuwaijri', 'Maria Angela Ferrario'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;Agile is an established and globally adopted software development methodology for managing software projects, known for reducing time to market and costs, and improving customer satisfaction. However, in developing countries, such as those in the Middle East, Agile is still in the early stages of adoption compared to Europe and North America. This is problematic, specifically in the case of Saudi Arabia, which is increasingly looking at the software industry to diversify its economy to reduce the reliance on the oil industry. It is essential to understand the factors that influence the decision of Saudi software organisations to adopt Agile. Hence, this study aims to critically review the influential factors identified in the Agile adoption framework that may support or challenge the adoption of Agile in small and medium-sized enterprises (SMEs) in Saudi Arabia. To this end, we carried out a focus group study with five software practitioners working in different Saudi software SMEs. The main findings indicate the apparent influence of all the identified factors in the developed framework except those related to process, with a high level of importance attached to culture, people and knowledge factors. This study refines the framework and helps software organisations assess their readiness for adopting Agile during the development process.;;;https://dl.acm.org/doi/10.1145/3501774.3501785;;;Software AND Engineering
Engineering Cost Based on Computer Information;;;['Lingling Du'];;;August 2021;;;ICIMTECH 21: <italic toggle='yes'>Retracted on September 15, 2021</italic>The Sixth International Conference on Information Management and Technology;;;NOTICE OF RETRACTION: While investigating potential publication-related misconduct in connection with the ICIMTech 2021 Conference Proceedings, serious concerns were raised that cast doubt on the integrity of the peer-review process and all papers published in the Proceedings of this Conference. The integrity of the entire Conference has been called into question. As a result, of its investigation, ACM has decided to retract the Entire Conference Proceedings and all related papers from the ACM Digital Library.None of the papers from this Proceeding should be cited in the literature because of the questionable integrity of the peer review process for this Conference.;;;https://dl.acm.org/doi/10.1145/3465631.3465913;;;Software AND Engineering
Software ticks need no specifications;;;['Christoph Reichenbach'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Software bugs cost time, money, and lives. They drive software research and development efforts, and are central to modern software engineering. Yet we lack a clear and general definition of what bugs are. Some bugs are defects, clearly defined as failures to meet some requirement or specification. However, there are many forms of undesirable program behaviour that are completely compatible with a typical program's specification. In this paper, we argue that the lack of a criterion for identifying non-defect bugs is hampering the development of tools that find and fix bugs. We propose such a criterion, based on the idea of wasted effort, discuss how bugs that meet our definition of software ticks can complement defects, and sketch how our definition can help guide future work on software tools.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00021;;;Software AND Engineering
Safety, security, and configurable software systems: a systematic mapping study;;;['Andy Kenner', 'Richard May', 'Jacob Krüger', 'Gunter Saake', 'Thomas Leich'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;Safety and security are important properties of any software system, particularly in safety-critical domains, such as embedded, automotive, or cyber-physical systems. Moreover, particularly those domains also employ highly-configurable systems to customize variants, for example, to different customer requirements or regulations. Unfortunately, we are missing an overview understanding of what research has been conducted on the intersection of safety and security with configurable systems. To address this gap, we conducted a systematic mapping study based on an automated search, covering ten years (2011--2020) and 65 relevant (out of 367) publications. We classified each publication based on established security and safety concerns (e.g., CIA triad) as well as the connection to configurable systems (e.g., ensuring security of such a system). In the end, we found that considerably more research has been conducted on safety concerns, but both properties seem under-explored in the context of configurable systems. Moreover, existing research focuses on two directions: Ensuring safety and security properties in product-line engineering; and applying product-line techniques to ensure safety and security properties. Our mapping study provides an overview of the current state-of-the-art as well as open issues, helping practitioners identify existing solutions and researchers define directions for future research.;;;https://dl.acm.org/doi/10.1145/3461001.3471147;;;Software AND Engineering
How Gamification Affects Software Developers: Cautionary Evidence from a Natural Experiment on GitHub;;;['Lukas Moldon', 'Markus Strohmaier', 'Johannes Wachs'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;We examine how the behavior of software developers changes in response to removing gamification elements from GitHub, an online platform for collaborative programming and software development. We find that the unannounced removal of daily activity streak counters from the user interface (from user profile pages) was followed by significant changes in behavior. Long-running streaks of activity were abandoned and became less common. Weekend activity decreased and days in which developers made a single contribution became less common. Synchronization of streaking behavior in the platform's social network also decreased, suggesting that gamification is a powerful channel for social influence. Focusing on a set of software developers that were publicly pursuing a goal to make contributions for 100 days in a row, we find that some of these developers abandon this quest following the removal of the public streak counter. Our findings provide evidence for the significant impact of gamification on the behavior of developers on large collaborative programming and software development platforms. They urge caution: gamification can steer the behavior of software developers in unexpected and unwanted directions.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00058;;;Software AND Engineering
Reform of Informatization Teaching Methods in Aesthetic Education under the Background of New Engineering;;;['Yi Li'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;This article has carried out related research with the goal of promoting the reform of aesthetic education informatization methods under the background of new engineering. The article outlines the new requirements of the Fourteenth Five-Year Plan and Higher Education Conference for aesthetic education, expounds the concept of craftsmanship, and analyzes the relationship between aesthetic education, talent training and craftsmanship in the context of new engineering. It also expounds the important value of the construction craftsman spirit and engineering consciousness under the background of the new engineering discipline, and discusses the key points of the reform of informatization teaching methods in aesthetic education under this background, hoping to provide reference for related personnel of aesthetic education.;;;https://dl.acm.org/doi/10.1145/3482632.3483103;;;Software AND Engineering
Engineering implementation of MSK modulation and demodulation technology;;;['Lu Jun', 'Yu Xiaoping', 'Yang Jingfu', 'Zhong Sihui', 'Jia lanxu', 'Song Qishun'];;;May 2021;;;ICAIIS 2021: 2021 2nd International Conference on Artificial Intelligence and Information Systems;;;MSK is often used in communication, but most of them are for detailed inference. In order to study the digital realization of minimum frequency shift keying (MSK) and its principle. It is analyzed according to the principle of digital up-conversion (DUC), digital down-conversion (DDC) and filtering technology, and verified by simulation with MATLAB. Finally, it is realized by Verlig HDL language on FPGA (Field-Programmable Gate Array), and the feasibility and system parameters of the scheme are determined.;;;https://dl.acm.org/doi/10.1145/3469213.3470234;;;Software AND Engineering
Don't Disturb Me: Challenges of Interacting with Software Bots on Open Source Software Projects;;;['Mairieli Wessel', 'Igor Wiese', 'Igor Steinmacher', 'Marco Aurelio Gerosa'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Software bots are used to streamline tasks in Open Source Software (OSS) projects' pull requests, saving development cost, time, and effort. However, their presence can be disruptive to the community. We identified several challenges caused by bots in pull request interactions by interviewing 21 practitioners, including project maintainers, contributors, and bot developers. In particular, our findings indicate noise as a recurrent and central problem. Noise affects both human communication and development workflow by overwhelming and distracting developers. Our main contribution is a theory of how human developers perceive annoying bot behaviors as noise on social coding platforms. This contribution may help practitioners understand the effects of adopting a bot, and researchers and tool designers may leverage our results to better support human-bot interaction on social coding platforms.;;;https://dl.acm.org/doi/10.1145/3476042;;;Software AND Engineering
Engineering Certification Practice Teaching Management and Data Mining Based on Complex Hierarchical Model;;;['Dafeng Liu', 'Mian Huang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the rapid development of education, especially the rapid development of higher education, the informationization and modernization level of education management have made great progress, and universities have made gratifying achievements in management information system. Engineering education professional certification brings opportunities and challenges to China's higher education: on the one hand, it can promote us to improve the teaching quality and let graduates obtain internationally recognized qualification certificates. On the other hand, higher educators need to change their thinking, think backwards from the perspective of teaching output, and re-examine teaching input, so as to better cultivate graduates who meet the engineering certification standards. Educational data mining is a process of transforming the original data from educational administration system and teaching system into useful information. Based on the complex hierarchical model, this paper constructs the university practical teaching system, quantifies students' practical ability in the form of credits, and brings it into the student evaluation system, which can reflect students' personal ability more comprehensively.;;;https://dl.acm.org/doi/10.1145/3482632.3482651;;;Software AND Engineering
A Simulation Model of Engineering Construction Near-miss Event Disclosure Strategy Based on Evolutionary Game Theory;;;['Zhongfu Qin', 'Shilan Wu'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;In the field of construction engineering, the concealment reporting problem in the initial stage of near-miss event management seriously hinders its subsequent management. In order to analyze the game relationship between the front-line safety managers and the near-miss event reporters of the same project company in the near-miss event concealment reporting problem, this paper constructs a manager-reporter evolutionary game model and uses VensimPLE to build a system simulation model for the study. In this paper, the real situation is abstracted into an evolutionary game model, and each parameter in the model is logically analyzed and quantitatively assigned a value. Then, the software is used to simulate the changes of manager's supervision probability and reporter's concealment probability under different initial strategy combinations, and through the analysis of the simulation results, the strategy changes under different initial strategy settings are obtained, so as to provide theoretical selection basis for near-miss event managers to formulate supervision strategies and set the frequency of supervision.;;;https://dl.acm.org/doi/10.1145/3482632.3487473;;;Software AND Engineering
Translation Engineering: Translation in the Age of Information Technology;;;['Weimin Yuan', 'Jiming Peng'];;;August 2021;;;ICIMTECH 21: <italic toggle='yes'>Retracted on September 15, 2021</italic>The Sixth International Conference on Information Management and Technology;;;NOTICE OF RETRACTION: While investigating potential publication-related misconduct in connection with the ICIMTech 2021 Conference Proceedings, serious concerns were raised that cast doubt on the integrity of the peer-review process and all papers published in the Proceedings of this Conference. The integrity of the entire Conference has been called into question. As a result, of its investigation, ACM has decided to retract the Entire Conference Proceedings and all related papers from the ACM Digital Library.None of the papers from this Proceeding should be cited in the literature because of the questionable integrity of the peer review process for this Conference.;;;https://dl.acm.org/doi/10.1145/3465631.3465808;;;Software AND Engineering
An Evaluation Model of the Course of Electrical Control and PLC for Engineering Education Professional Certification;;;['Yang Zhao'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;The traditional engineering education pays too much attention to the scientific knowledge education based on subject knowledge in the course teaching, neglects the training of the ability of engineering practice and innovation, and leads to the serious separation of the students' knowledge and ability, and it is difficult to adapt to the demands of the creative talents of the engineering practice. The process of teaching of Electrical Control and PLC course in practical ability training is not enough in modern teaching methods of curriculum evaluation. The results oriented curriculum development theory put forward the reform of the teaching goal, the curriculum content, methods and assessment form. After the reform, the teaching plan of electronic technology is more suitable for the concept of international engineering education accreditation. The achievement oriented engineering education is goal oriented. It follows the principle of reverse design, determines the training target by the demand, then decides the graduation requirement by the training goal, and the course system and the course teaching by the requirements of the graduation.;;;https://dl.acm.org/doi/10.1145/3456887.3456917;;;Software AND Engineering
Secure software development in the era of fluid multi-party open software and services;;;['Ivan Pashchenko', 'Riccardo Scandariato', 'Antonino Sabetta', 'Fabio Massacci'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Pushed by market forces, software development has become fast-paced. As a consequence, modern development projects are assembled from 3rd-party components. Security & privacy assurance techniques once designed for large, controlled updates over months or years, must now cope with small, continuous changes taking place within a week, and happening in sub-components that are controlled by third-party developers one might not even know they existed. In this paper, we aim to provide an overview of the current software security approaches and evaluate their appropriateness in the face of the changed nature in software development. Software security assurance could benefit by switching from a process-based to an artefact-based approach. Further, security evaluation might need to be more incremental, automated and decentralized. We believe this can be achieved by supporting mechanisms for lightweight and scalable screenings that are applicable to the entire population of software components albeit there might be a price to pay.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00027;;;Software AND Engineering
A cognitive and machine learning-based software development paradigm supported by context;;;['Glaucia Melo', 'Paulo Alencar', 'Donald Cowan'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Advances in the use of cognitive and machine learning (ML) enabled systems fuel the quest for novel approaches and tools to support software developers in executing their tasks. First, as software development is a complex and dynamic activity, these tasks are highly dependent on the characteristics of the software project and its context, and developers need comprehensive support in terms of information and guidance based on the task context. Second, there is a lack of methods based on conversational-guided agents that consider cognitive aspects such as paying attention and remembering. Third, there is also a lack of techniques that make use of historical implicit or tacit data to infer new knowledge about the project tasks such as related tasks, task experts, relevant information needed for task completion and warnings, and navigation aspects of the process such as what tasks to perform next and optimal task sequencing. Based on these challenges, this paper introduces a novel paradigm for human-machine software support based on context, cognitive assistance, and machine learning, and briefly describes ongoing research activities to realize this paradigm. The research takes advantage of the synergy among emergent methods provided in context-aware software processes, cognitive computing such as chatbots, and machine learning such as recommendation systems. These novel paradigms have the potential to transform the way software development currently occurs by allowing developers to receive valuable information and guidance in real-time while they are participating in projects.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00011;;;Software AND Engineering
Innovation and Entrepreneurship Education based Intelligent New Engineering Practice Teaching Mode and Teaching Base Construction Research;;;['Qian Gao'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;In order to build a manufacturing power and implement Industry 4.0, outstanding engineers with innovative ability are urgently needed to improve national competitive strength. This paper first analyzes the current situation of the cultivation of innovative talents in computer major in colleges and universities in 4 aspects, then proposes the construction mode of intelligent new engineering practice teaching base based on the innovation and entrepreneurship education, and puts forward specific construction plans and measures. It has been proved by practice that the practical teaching mode and teaching base construction proposed by us can greatly improve students' enthusiasm for innovation and entrepreneurship, and provide students with the high success rate of national innovation and entrepreneurship projects.;;;https://dl.acm.org/doi/10.1145/3456887.3457087;;;Software AND Engineering
Project-Based Learning Using Internet of Things as an Educational Tool in COVID–19 Era with a Hybrid Context for Engineering Students;;;['Jesus Anselmo Fortoul-Diaz', 'Froylan Cortes-Santacruz', 'Daniel Perez-Rojas', 'Emmanuel Torres-Rios', 'Luis Antonio Carrillo-Martinez'];;;December 2021;;;ICETM '21: Proceedings of the 2021 4th International Conference on Education Technology Management;;;Universities must develop disciplinary skills during the COVID-19 era due to virtual classes, even in laboratory practices. In this experiment, disciplinary skills during COVID-19 era are developed through Project-Based Learning (PjBL), which is a classroom approach to give students knowledge and skills, through projects focused on real world challenges and problems. The purpose of this study was to design PjBL using Internet of Things (IoT) to have quantitative evaluation, learning experience perception, course contents assimilation, perception of improvement in soft skills and critical thinking. The project consisted in the measurement and analysis of vehicle variables for an engine embedded in IoT with idle speed conditions. The vehicle variables to be measured and analyzed are: carbon oxide and dioxide gas emissions, gas emission temperature, engine bay temperature and humidity, engine RPM, oil temperature, engine inertial forces, engine block temperature, and accelerator pedal position. The results prove that PjBLs with IoT in a hybrid context improve the students' learning experiences in a similar way to the face-to-face context. The score grade before and during COVID-19 exhibited 1.59% of increment; the learning experience perception showed that the students preferred the hybrid (42.86%) model (remote and real) in similar percentage in comparison with the face-to-face (53.06%), the virtual model (remote) was not fully accepted (4.08%). The 81.6% of the students preferred to implement projects based on IoT for future courses or prototypes.;;;https://dl.acm.org/doi/10.1145/3510309.3510327;;;Software AND Engineering
A Survey-Based Qualitative Study to Characterize Expectations of Software Developers from Five Stakeholders;;;['Khalid Hasan', 'Partho Chakraborty', 'Rifat Shahriyar', 'Anindya Iqbal', 'Gias Uddin'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background. Studies on developer productivity and well-being find that the perceptions of productivity in a software team can be a socio-technical problem. Intuitively, problems and challenges can be better handled by managing expectations in software teams. Aim. Our goal is to understand whether the expectations of software developers vary towards diverse stakeholders in software teams. Method. We surveyed 181 professional software developers to understand their expectations from five different stakeholders: (1) organizations, (2) managers, (3) peers, (4) new hires, and (5) government and educational institutions. The five stakeholders are determined by conducting semi-formal interviews of software developers. We ask open-ended survey questions and analyze the responses using open coding. Results. We observed 18 multi-faceted expectations types. While some expectations are more specific to a stakeholder, other expectations are cross-cutting. For example, developers expect work-benefits from their organizations, but expect the adoption of standard software engineering (SE) practices from their organizations, peers, and new hires. Conclusion. Out of the 18 categories, three categories are related to career growth. This observation supports previous research that happiness cannot be assured by simply offering more money or a promotion. Among the most number of responses, we find expectations from educational institutions to offer relevant teaching and from governments to improve job stability, which indicate the increasingly important roles of these organizations to help software developers. This observation can be especially true during the COVID-19 pandemic.;;;https://dl.acm.org/doi/10.1145/3475716.3475787;;;Software AND Engineering
Towards fluid software architectures: bidirectional human-AI interaction;;;['Ammar Yasser', 'Mervat Abu-Elkhier'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;The research on engineering software applications that employ artificial intelligence (AI) and machine learning (ML) is at an all-time peak. However, most of the research in this area is focused on the interactions between humans and AI which, in turn, is predominantly concerned with either building immersive interfaces and user experiences that allow for increased telemetry or on handling AI and ML applications in production (MLOps). Nonetheless, the research on fundamental architectural differences between AI-powered applications and traditional ones did not receive its fair share of attention. To that end, we believe that a new take on the fundamental architecture of building software applications is needed. With the ever increasing prominence of content-driven AI-powered applications, it is our conviction that 1) content could be served by servers without clients requesting, 2) servers could (should) request data from clients without waiting for their requests, and 3) interfaces should dynamically adapt to updates that happen to the intelligence driving the application. Hence, in this paper, we propose the fluid architecture that facilitates the bidirectional interaction between clients and servers as well as accommodates the co-dependent evolution of interfaces and back-end intelligence in AI-powered systems.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678647;;;Software AND Engineering
Research on the Path of Talent Development and Upgrading of Mining Engineering under the Background of the Intelligent Mine;;;['Yong Chen', 'Yang Xu', 'Lihua Ke', 'Nan Yao', 'Qiaozhi Wang'];;;June 2021;;;ICFET '21: Proceedings of the 7th International Conference on Frontiers of Educational Technologies;;;The construction of intelligent mines puts forward new challenges to the talent training of Mining Engineering. The connotation and future development trend of intelligent mines were systematically expounded in the paper, summarizing the current situation and the barriers to upgrading and transforming the major. Based on the development status of intelligent mines, a curriculum system construction plan was proposed incorporating the principle of merging traditional courses, introducing in new courses, strengthening knowledge integration, highlighting practical ability training, and setting elective course groups according to the research direction. In addition, a supporting teacher construction plan and a practice base construction plan were proposed accordingly. Subsequently, a talent training and an upgrading path for the major of Mining Engineering under the background of intelligent mining were proposed.;;;https://dl.acm.org/doi/10.1145/3473141.3473245;;;Software AND Engineering
A Model of Software Prototyping based on a Systematic Map;;;['Elizabeth Bjarnason', 'Franz Lang', 'Alexander Mjöberg'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Prototyping is an established practice for user interface design and for requirements engineering within agile software development, even so there is a lack of theory on prototyping. Aims: The main research objective is to provide a means to categorise prototyping instances, in order to enable comparison and reflection of prototyping practices. Method: We have performed a systematic mapping study of methodological aspects of prototyping consisting of thirty-three primary studies upon which we designed a model of prototyping that was validated through a focus group at a case company. Results: Our model consists of four aspects of prototyping, namely purpose, prototype scope, prototype use, and exploration strategy. This model supported the focus group participants in discussing prototyping practices by considering concrete prototyping instances in terms of the concepts provided by our model. Conclusions: The model can be used to categorise prototyping instances and can support practitioners in reflecting on their prototyping practices. Our study provides a starting point for further research on prototyping and into how the practice can be applied more cost-effectively to elicit, validate, and communicate requirements.;;;https://dl.acm.org/doi/10.1145/3475716.3475772;;;Software AND Engineering
Reverse engineering modeling of motor hood and injection mold design;;;['Yajun Li', 'Haixiong Wang', 'Jinhui He'];;;July 2021;;;ICIIP '21: Proceedings of the 6th International Conference on Intelligent Information Processing;;;None;;;https://dl.acm.org/doi/10.1145/3480571.3480591;;;Software AND Engineering
Cultivation of Accounting Professionals in Private Engineering Colleges in the Era of Artificial Intelligence – Take GDLGXY as an Example;;;['Wen Yang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;In March 2016, Deloitte Touche Tohmatsu Limited announced its cooperation with Kira System to introduce artificial intelligence into accounting, taxation, and auditing. Subsequently, KPMG, PricewaterhouseCoopers, Ernst & Young also introduced artificial intelligence technology, marking the emergence of artificial intelligence accounting. How to face the challenges brought by the wave of artificial intelligence to the field of accounting? How should schools deal with the impact of artificial intelligence accounting on existing talent training programs? This paper uses GDLGXY as a case to discuss the impact of artificial intelligence accounting on the cultivation of accounting professionals in private engineering colleges, analyze the problems in the process, and then propose targeted solutions. This paper has important theoretical and practical significance for the cultivation of private engineering colleges and universities on inter-disciplinary accounting talents with both artificial intelligence and accounting knowledge for enterprises.;;;https://dl.acm.org/doi/10.1145/3482632.3483044;;;Software AND Engineering
An overview of the challenges for developing software within the field of autonomous vehicles;;;['Pavle Dakić', 'Miodrag Źivković'];;;May 2021;;;ECBS 2021: 7th Conference on the Engineering of Computer Based Systems;;;Autonomous vehicles are constantly collecting information from their environment, employing reasonably sophisticated cameras and sensors. Applying new software on those vehicles should aim at correcting human errors and gaining new knowledge from all road users. The discussion of autonomous vehicles regarding software from various perspectives, including different knowledge branches such as law, social, economic, design, and ethics. Autonomous vehicles present new challenges with interesting problems in several scientific fields, which are gradually being successfully solved. Social dilemmas, moral and ethical issues show different approaches. There is still an unsolvable problem of decision-making when it comes to the involvement of the ”trolley” problem. Autonomous vehicle software should within the future have flexibility to reconstruct collisions in order that the logic, ethics, and moral algorithm applied may be analyzed. This demands the existence of very good software and hardware technology that can record all the data during a collision. This paper will cover security concerns and current challenges for developing software in the field of autonomous vehicles.;;;https://dl.acm.org/doi/10.1145/3459960.3459972;;;Software AND Engineering
How Software Refactoring Impacts Execution Time;;;['Luca Traini', 'Daniele Di Pompeo', 'Michele Tucci', 'Bin Lin', 'Simone Scalabrino', 'Gabriele Bavota', 'Michele Lanza', 'Rocco Oliveto', 'Vittorio Cortellessa'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Refactoring aims at improving the maintainability of source code without modifying its external behavior. Previous works proposed approaches to recommend refactoring solutions to software developers. The generation of the recommended solutions is guided by metrics acting as proxy for maintainability (e.g., number of code smells removed by the recommended solution). These approaches ignore the impact of the recommended refactorings on other non-functional requirements, such as performance, energy consumption, and so forth. Little is known about the impact of refactoring operations on non-functional requirements other than maintainability.We aim to fill this gap by presenting the largest study to date to investigate the impact of refactoring on software performance, in terms of execution time. We mined the change history of 20 systems that defined performance benchmarks in their repositories, with the goal of identifying commits in which developers implemented refactoring operations impacting code components that are exercised by the performance benchmarks. Through a quantitative and qualitative analysis, we show that refactoring operations can significantly impact the execution time. Indeed, none of the investigated refactoring types can be considered “safe” in ensuring no performance regression. Refactoring types aimed at decomposing complex code entities (e.g., Extract Class/Interface, Extract Method) have higher chances of triggering performance degradation, suggesting their careful consideration when refactoring performance-critical code.;;;https://dl.acm.org/doi/10.1145/3485136;;;Software AND Engineering
Software Requirements Elicitation for Complex Systems with the Functional Resonance Analysis Method (FRAM);;;['Elaine Alves Carvalho', 'José Orlando Gomes', 'Alessandro Jatobá', 'Mônica Ferreira Silva', 'Paulo Victor Rodrigues Carvalho'];;;June 2021;;;SBSI '21: Proceedings of the XVII Brazilian Symposium on Information Systems;;;Despite all efforts, the requirements elicitation task is still considered non-trivial, especially for complex (non-linear) systems. In these systems, technological support must perform more resiliently, that is, be more adaptable to deal with uncertain situations. The Resilience Engineering provides the Functional Resonance Analysis Method (FRAM) to model these systems based on a description of the actual work (Work-As-Done - WAD). Therefore, unexpected events commonly associated with variability and improvisations become more explicit with that method. Thus, a multidisciplinary approach can contribute to requirements elicitation, since FRAM models deal with variability, unpredictability, and adaptation in complex sociotechnical systems. This study applies the Design Science Research to project a heuristic model to gather information from FRAM models to elicit functional and nonfunctional requirements, showing the contributions of Resilience Engineering to Requirements Engineering to identify software requirements for complex systems.;;;https://dl.acm.org/doi/10.1145/3466933.3466950;;;Software AND Engineering
Research on the Intelligent Information Platform Construction of Petroleum Engineering;;;['Fei Sun', 'Chongliang Sun', 'Hairong Dong', 'Jing Jin', 'Yanxin Li'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;None;;;https://dl.acm.org/doi/10.1145/3495018.3495112;;;Software AND Engineering
Security guarantees for automated software testing;;;['Danushka Liyanage'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Before making important decisions about an ongoing fuzzing campaign, we believe an engineer may want to know: (i) the achieved level of confidence about the program’s correctness (residual risk), (ii) the expected increase in confidence about the program’s correctness if we invest more time for the current campaign (cost-benefit trade-off), and (iii) the total number of bugs that the fuzzer can find in the limit (effectiveness). The ability to accurately estimate the above quantities through observed data of the fuzzing campaign allows engineers to make required decisions with quantifiable accuracy. Currently, there are popular data-driven approaches to provide such quantitative guidance on decision making for white- and blackbox fuzzing campaigns. However, none of these prevailing techniques can guarantee unbiased estimation of residual risk, cost-benefit trade-off, or effectiveness for greybox fuzzing – the most popular automated software vulnerability discovery technique to date. Greybox fuzzers introduce an adaptive bias to existing estimators that needs to be corrected during the quantitative analysis to make accurate decisions about the campaign.  In this thesis, our primary objective is to develop a rich statistical framework that supports quantitative decision-making for greybox fuzzing campaigns. We leverage this framework to introduce appropriate bias correction strategies to existing estimators and propose novel estimators that account for adaptive bias in greybox fuzzing.;;;https://dl.acm.org/doi/10.1145/3468264.3473097;;;Software AND Engineering
Sector classification for crowd-based software requirements;;;['Kushagra Bhatia', 'Arpit Sharma'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Requirements engineering (RE) is the process of defining, documenting, and maintaining software requirements. Crowd-based RE (CrowdRE) involves large scale user participation in requirements engineering tasks. It improves the quality of software requirements and helps in reducing the cost. Manual extraction of useful insights from a large body of unstructured, and noisy natural language data produced during CrowdRE is an expensive, error prone and time consuming task. Thus, automated techniques are required for processing the CrowdRE data. We focus on the problem of automatic classification of crowd-based software requirements into sectors. We propose three different approaches for sector classification of crowd-based software requirements. These approaches are based on supervised machine learning (ML) models, neural networks, and bidirectional encoder representations from transformers (BERT), respectively. We apply our classification approaches to a large-sized requirements document, i.e. a CrowdRE dataset with around 3000 crowd-generated requirements for smart home applications. To evaluate the quality of our classification algorithms we use the publicly available ground truth data for computing precision, recall, and F-score. We compare the performance of several classification algorithms and our detailed experiments indicate that these algorithms can be very useful for categorizing crowd-based requirements into sectors.;;;https://dl.acm.org/doi/10.1145/3412841.3442005;;;Software AND Engineering
How do students test software units?;;;['Lex Bijlsma', 'Niels Doorn', 'Harrie Passier', 'Harold Pootjes', 'Sylvia Stuurman'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;We gained insight into ideas and beliefs on testing of students who finished an introductory course on programming without any formal education on testing. We asked students to fill in a small survey, to do four exercises and to fill in a second survey. We interviewed eleven of these students in semi-structured interviews, to obtain more in-depth insight. The main outcome is that students do not test systematically, while most of them think they do test systematically. One of the misconceptions we found is that most students can only think of test cases based on programming code. Even if no code was provided (black-box testing), students try to come up with code to base their test cases on.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00029;;;Software AND Engineering
Application of Digital Information Technology to the Quality Management System of Power Grid Engineering;;;['Xiangbiao Leng', 'Guilin Zou', 'Haixiang Yu', 'Fei Peng', 'Huan Feng', 'Bingti Huang'];;;February 2022;;;ICIIT '22: Proceedings of the 2022 7th International Conference on Intelligent Information Technology;;;The construction quality of the power grid determines whether it can operate safely and reliably. Therefore, in order to improve the construction quality of power grid projects, three technologies, GIS technology, BIM technology, and Internet of Things technology, are introduced in the article. At the beginning of this article, the author started research on the application of the three technologies in the process of power grid construction, and concluded that the application of the three technologies can greatly reduce the input of manpower and material resources, save costs, improve the efficiency of power grid construction, and can also improve the management and control efficiency of power grid construction quality. Finally, the author looks forward to the development of the three technologies by analyzing the future development trend of informatization.;;;https://dl.acm.org/doi/10.1145/3524889.3524905;;;Software AND Engineering
"Ignorance and Prejudice" in Software Fairness;;;['Jie M. Zhang', 'Mark Harman'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Machine learning software can be unfair when making human-related decisions, having prejudices over certain groups of people. Existing work primarily focuses on proposing fairness metrics and presenting fairness improvement approaches. It remains unclear how key aspect of any machine learning system, such as feature set and training data, affect fairness. This paper presents results from a comprehensive study that addresses this problem. We find that enlarging the feature set plays a significant role in fairness (with an average effect rate of 38%). Importantly, and contrary to widely-held beliefs that greater fairness often corresponds to lower accuracy, our findings reveal that an enlarged feature set has both higher accuracy and fairness. Perhaps also surprisingly, we find that a larger training data does not help to improve fairness. Our results suggest a larger training data set has more unfairness than a smaller one when feature sets are insufficient; an important cautionary finding for practising software engineers.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00129;;;Software AND Engineering
Embedded controller Visual Configuration software design analysis;;;['Yufeng Liang'];;;November 2021;;;ICSED '21: Proceedings of the 2021 3rd International Conference on Software Engineering and Development;;;Facing the massive data information and logic control pages of different engineering projects, the use of embedded visual controllers to control a variety of electronic equipment or devices, automated processing tasks, has become a modern industrial remote command monitoring, one of the development trends of functional service expansion. In this case, the use of Windows operating system, Modbus /TCP protocol, and ROM, Flash and other memory, to develop and design a visual configuration software for SmartIC industrial project control, including the upper computer visual configuration software, the lower computer ARM configuration software, by the upper computer's dynamic linked list Technology, sends the configuration file for logic instruction control and function execution, and the lower computer performs the configuration file reception, identification and operation.;;;https://dl.acm.org/doi/10.1145/3507473.3507476;;;Software AND Engineering
Hierarchical Cluster Labeling of Software Requirements using Contextual Word Embeddings;;;['Adailton Araujo', 'Ricardo Marcacini'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The popularization of social media has motivated research into machine learning methods for software requirements extraction from user comments and reviews. These methods analyze software review datasets to classify some textual excerpts as software requirements, which allows the management and monitoring of the evolution of software quality directly from the crowd users’ perspective. However, the existing methods have two major limitations. First, several duplicate requirements are extracted from reviews because users write the same requirement in different ways by using synonyms and non-technical language, often with misspellings and ambiguity. Second, requirements extraction methods do not deal with different granularity levels, thereby ignoring hierarchical relationships between software requirements. This paper presents a hierarchical cluster labeling approach for software requirements based on contextual word embeddings to address these challenges. We explore neural language models to obtain a more semantic and robust representation of the software requirements, in which the texts are represented by contextual word embeddings. Our approach organizes the software requirements into clusters and sub-clusters according to requirement similarities in the embedding space. Finally, we select representative software requirements to label each cluster and sub-cluster, thereby dealing with both duplicate and different granularity levels of the software requirements. An experimental evaluation using review datasets from 8 mobile apps shows that our approach obtains promising results and presents new ideas and research directions for data-driven requirements engineering.;;;https://dl.acm.org/doi/10.1145/3474624.3477067;;;Software AND Engineering
An Overview of a State of the Art on Developing Soft Computing-Based Language Education and Research Systems: A Survey of Engineering English Students in Uzbekistan;;;['Oybek Alikovich Eshbayev', 'Abdulxalim Xamidovich Maxmudov', 'Ravshan Urokovich Rozikov'];;;December 2021;;;ICFNDS 2021: The 5th International Conference on Future Networks &amp; Distributed Systems;;;This manuscript presents a state of –the –art overview on developing soft computing-based intelligent systems relevant to language education and research to inspire technology-savvy teacher-researchers to create their interactive tools. In this regard, two important fields (Natural Language Processing and Data Analysis) of computer science have been considered as the main directions of that linguistic computation because of their amazing software applications like automatic writing tutors, text summarizers, and so-called corpus-based apps. The paper also outlines some ethical considerations of system usage so that system designers should devise relevant design features in the future thereby teachers overcoming some classroom challenges. Unlike previous methods of studies on computer-assisted language teaching and research, our work devises a multidisciplinary method to reach the state-of-art. Through this method, we summarize the relevant literature source from two perspectives, linguistic and computational ones. The rationale of this method by the survey of engineering English students confirms that fuzzy logic-based Natural Language Processing and Data Analysis approaches can be employed effectively in language education and research. Finally, based on the multidisciplinary literature review method, the manuscript produces an overview of state-of-the-art performance as the outcome.;;;https://dl.acm.org/doi/10.1145/3508072.3508160;;;Software AND Engineering
Survey of Learning Environments for Software Testing Education;;;['Tamara Zivkovic', 'Miodrag Zivkovic'];;;May 2021;;;ECBS 2021: 7th Conference on the Engineering of Computer Based Systems;;;Software development is one of the fastest growing industries today. The defects in software can be very costly, either in terms of losing money, reputation, or even lives in case of some critical applications. Consequently, there is a high and always increasing demand for software engineers specialized in the branch of software testing. However, traditional software engineering courses pay very little attention to the software testing, and students are entering the market with very little practical testing experience. One way to address this problem is to integrate software testing into the engineering studies through collaborative learning environments and simulators that can help students gain practical experience and learn testing techniques in an interesting way. In this paper, we provide a survey of software testing environments and tools that can help in this process.;;;https://dl.acm.org/doi/10.1145/3459960.3459971;;;Software AND Engineering
Static Analysis: An Introduction: The fundamental challenge of software engineering is one of complexity.;;;['Patrick Thomson'];;;July-August 2021;;;Queue;;;Modern static-analysis tools provide powerful and specific insights into codebases. The Linux kernel team, for example, developed Coccinelle, a powerful tool for searching, analyzing, and rewriting C source code; because the Linux kernel contains more than 27 million lines of code, a static-analysis tool is essential both for finding bugs and for making automated changes across its many libraries and modules. Another tool targeted at the C family of languages is Clang scan-build, which comes with many useful analyses and provides an API for programmers to write their own analyses. Like so many things in computer science, the utility of static analysis is self-referential: To write reliable programs, we must also write programs for our programs. But this is no paradox. Static-analysis tools, complex though their theory and practice may be, are what will enable us, and engineers of the future, to overcome this challenge and yield the knowledge and insights that we practitioners deserve.;;;https://dl.acm.org/doi/10.1145/3487019.3487021;;;Software AND Engineering
A prediction model for software requirements change impact;;;['Kareshna Zamani'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Software requirements Change Impact Analysis (CIA) is a pivotal process in requirements engineering (RE) since changes to requirements are inevitable. When a requirement change is requested, its impact on all software artefacts has to be investigated to accept or reject the request. Manually performed CIA in large-scale software development is time-consuming and error-prone so, automating this analysis can improve the process of requirements change management. The main goal of this research is to apply a combination of Machine Learning (ML) and Natural Language Processing (NLP) based approaches to develop a prediction model for forecasting the requirement change impact on other requirements in the specification document. The proposed prediction model will be evaluated using appropriate datasets for accuracy and performance. The resulting tool will support project managers to perform automated change impact analysis and make informed decisions on the acceptance or rejection of requirement change requests.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678582;;;Software AND Engineering
Research on Reform of "Electrical Engineering and Electronics" Based on CDIO Education Model;;;['Miao Zhang', 'Liyun Zhang', 'Deshan Wang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;None;;;https://dl.acm.org/doi/10.1145/3482632.3482669;;;Software AND Engineering
Interpretation-enabled Software Reuse Detection Based on a Multi-Level Birthmark Model;;;['Xi Xu', 'Qinghua Zheng', 'Zheng Yan', 'Ming Fan', 'Ang Jia', 'Ting Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Software reuse, especially partial reuse, poses legal and security threats to software development. Since its source codes are usually unavailable, software reuse is hard to be detected with interpretation. On the other hand, current approaches suffer from poor detection accuracy and efficiency, far from satisfying practical demands. To tackle these problems, in this paper, we propose ISRD, an interpretation-enabled software reuse detection approach based on a multi-level birthmark model that contains function level, basic block level, and instruction level. To overcome obfuscation caused by cross-compilation, we represent function semantics with Minimum Branch Path (MBP) and perform normalization to extract core semantics of instructions. For efficiently detecting reused functions, a process for "intent search based on anchor recognition" is designed to speed up reuse detection. It uses strict instruction match and identical library call invocation check to find anchor functions (in short anchors) and then traverses neighbors of the anchors to explore potentially matched function pairs. Extensive experiments based on two real-world binary datasets reveal that ISRD is interpretable, effective, and efficient, which achieves 97.2% precision and 94.8% recall. Moreover, it is resilient to cross-compilation, outperforming state-of-the-art approaches.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00084;;;Software AND Engineering
Requirements Elicitation in the Context of Software for Low-Functioning Autistic People: An Initial Proposal of Specific Supporting Artifacts;;;['Aurea Melo', 'Ana Oran', 'Jonathas Santos', 'Luis Rivero', 'Raimundo Barreto'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Requirements engineering is a crucial stage for the success of any software, as it allows a better understanding of the needs and desires of the customers or future users. In software development for autistic users, inexperienced software engineers face difficulties in the requirements engineering stage, as there are few specific techniques and artifacts to gather requirements in such context. The challenges increase when considering low-functioning autistic people, who have the most severe limitations of the disorder. Considering the above, in this paper, we present two artifacts to support the elicitation of requirements in software projects for autistic users. We developed a set of interviewing questions based on the opinion of both software development practitioners and caregivers. Also, we have drawn inspiration in a commercial canvas model to synthesize relevant data obtained with the interviews. When validating the artifacts, we got indicators of the feasibility of applying the artifacts in an actual development project. By developing and integrating these artifacts, we intend to support the requirements engineering stage and continue their development and study in further contexts.;;;https://dl.acm.org/doi/10.1145/3474624.3477065;;;Software AND Engineering
A Pilot Study of Requirement Prioritization Techniques in Agile Software Development.;;;['Yadamanee Kuengjai', 'Lachana Ramingwong'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;Requirement prioritization (RP) is a method for identifying the most critical requirements that should be immediately addressed. The results show how much all parties truly understand the requirements of the project. A trustworthy requirements prioritization process can ensure that the most important requirements are in line with business needs and should be developed first. The process results in the prioritized list of requirements that support decision making in release planning and subsequent activities to maximize software quality and customer satisfaction. This paper identified strengths and weaknesses of existing RP techniques. That leads to identification of factors in selecting the appropriate RP techniques for software projects. The recommendation can lead to improvement of the existing RP techniques. In addition, this paper presents the survey results of RP techniques used in participating software companies which developed software in Agile Software Development (ASD) context. The results reveal the challenges faced in their RP processes.;;;https://dl.acm.org/doi/10.1145/3494885.3494912;;;Software AND Engineering
A Case Study of Onboarding in Software Teams: Tasks and Strategies;;;['An Ju', 'Hitesh Sajnani', 'Scot Kelly', 'Kim Herzig'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Developers frequently move into new teams or environments across software companies. Their onboarding experience is correlated with productivity, job satisfaction, and other short-term and long-term outcomes. The majority of the onboarding process comprises engineering tasks such as fixing bugs or implementing small features. Nevertheless, we do not have a systematic view of how tasks influence onboarding. In this paper, we present a case study of Microsoft, where we interviewed 32 developers moving into a new team and 15 engineering managers onboarding a new developer into their team - to understand and characterize developers' onboarding experience and expectations in relation to the tasks performed by them while onboarding. We present how tasks interact with new developers through three representative themes: learning, confidence building, and socialization. We also discuss three onboarding strategies as inferred from the interviews that managers commonly use unknowingly, and discuss their pros and cons and offer situational recommendations. Furthermore, we triangulate our interview findings with a developer survey (N = 189) and a manager survey (N = 37) and find that survey results suggest that our findings are representative and our recommendations are actionable. Practitioners could use our findings to improve their onboarding processes, while researchers could find new research directions from this study to advance the understanding of developer onboarding. Our research instruments and anonymous data are available at https://zenodo.org/record/4455937#.YCOQCs_0lFd.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00063;;;Software AND Engineering
Assessment of a hybrid software development process for student projects: a controlled experiment;;;['Rafał Włodarski', 'Jean-Remy Falleri', 'Corinne Parvéry'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;In recent years, a vivid interest in hybrid development methods has been observed as practitioners combine various approaches to software creation to improve productivity, product quality, and adaptability of the process to react to change. Scientific papers on the subject proliferate, however evaluation of the effectiveness of hybrid methods in academic contexts has yet to follow. The work presented investigates if introducing a hybrid approach for student projects brings added value as compared to iterative and sequential development. A controlled experiment was carried out among Bachelor students of a French engineering school to assess the impacts of a given development method on the success of student computing undertakings. Its three dimensions were examined via a set of metrics: product quality, team productivity as well as human factors (teamwork quality & learning outcomes). Several patterns were observed, which can provide a starting point for educators and researchers wishing to tailor or design a software development process for academic needs.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00039;;;Software AND Engineering
Challenges when Applying Repertory Grid Technique for Software Practices;;;['Diana Kirk', 'Kelly Blincoe'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;The Repertory Grid Technique (RGT) has been applied within the software engineering domain to investigate a variety of topics. These include topics relating to architectural knowledge, team level tacit knowledge, and project success mechanisms. The technique is based on Personal Construct Theory (PCT) and is claimed to be suitable for gaining a deep understanding of peoples’ perspectives on a topic. The essence of RGT is a consideration of similarities and differences, for example, between different project instances. In this paper, we describe a case study in which we applied the technique with the aim of eliciting practitioners’ viewpoints on contextual factors for situated software practices. We interviewed twelve practitioners in three organisations. We found that the RGT approach was challenging to implement for several reasons. Participants had difficulty in choosing specific instances of a software practice, identifying similarities and differences tended to be problematic and causal pathways were not always easy to establish. Our contributions are the highlighting of the challenges that may occur when implementing this technique, an analysis of the issues encountered and some possible mitigation approaches. These may serve as support for SE researchers considering an RGT based study.;;;https://dl.acm.org/doi/10.1145/3463274.3463841;;;Software AND Engineering
Research and practice of ministry-level software process improvement based on SW − CMM model;;;['XueFei Wang', 'KongYi Wu'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;With the continuous innovation of computer software technology, the e-government and other related information work of government departments has received increasing attention. Ministry-level information software projects are characterized by large scale, wide range of users, complex business logic, long project cycle, and large amount of post-operation and maintenance. In order to guarantee the quality of software projects, improve work efficiency, strengthen software process management capability, and effectively deal with software project risks, the article takes SW-CMM model as the basic framework, starts from three management models: project management process, engineering management process, and support activity process, and splits them into 12 sub-process domains according to the actual needs, and elaborates and analyzes the software process improvement of ministry-level information projects The main points of software process improvement for ministry-level information technology projects are elaborated and analyzed. Combining with the software engineering process improvement practices of actual software organizations, the corresponding implementation strategies are elaborated in six aspects, including controlling key links, covering the whole life cycle, promoting development standards and specifications, strengthening requirements management, enhancing project asset management and strengthening risk management, which provide an optimal solution for the process improvement of ministry-level software projects.;;;https://dl.acm.org/doi/10.1145/3520084.3520094;;;Software AND Engineering
Learning software quality assurance with bricks;;;['Miguel Ehécatl Morales-Trujillo'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Software Quality Assurance (SQA) and Software Process Improvement (SPI) are topics of crucial importance for software engineers; however, teaching them in a lecture room comes with several limitations due to lack of practical experience. With that in mind, we created KUALI-Brick, a LEGO®-based activity that brings SQA and SPI concepts together applying them in order to successfully build a LEGO city. This hands-on activity has been carried out in a fourth-year Software Engineering course at the University of Canterbury, with current results showing high levels of fun, increased engagement and an improved learning experience. We present a step-by-step guide to replicate the activity as well as lessons learned after conducting the activity for three consecutive years.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00010;;;Software AND Engineering
SmartCLIDE: Shortening the Toolchain of SOA-based Cloud Software Development by Automating Service Creation, Composition, Testing, and Deployment;;;['Theodore Maikantis', 'Theodore Chaikalis', 'Apostolos Ampatzoglou', 'Alexander Chatzigeorgiou'];;;November 2021;;;PCI '21: Proceedings of the 25th Pan-Hellenic Conference on Informatics;;;Nowadays the majority of cloud applications are developed based on the Service-Oriented Architecture (SOA) paradigm. Large-scale applications are structured as a collection of well-integrated services that are deployed in public, private or hybrid cloud. Despite the inherent benefits that service-based cloud development provides, the process is far from trivial, in the sense that it requires the software engineer to be (at least) comfortable with the use of various technologies in the long cloud development toolchain: programming in various languages, testing tools, build / CI tools, repositories, deployment mechanisms, etc. In this paper, we propose an approach and corresponding toolkit (termed SmartCLIDE—as part of the results of an EU-funded research project) for facilitating SOA-based software development for the cloud, by extending a well-known cloud IDE from Eclipse. The approach aims at shortening the toolchain for cloud development, hiding the process complexity and lowering the required level of knowledge from software engineers. The approach and tool underwent an initial validation from professional cloud software developers. The results underline the potential of such an automation approach, as well as the usability of the research prototype, opening further research opportunities and providing benefits for practitioners.;;;https://dl.acm.org/doi/10.1145/3503823.3503880;;;Software AND Engineering
Analytics Mistakes that Derail Software Startups;;;['Usman Rafiq', 'Jorge Melegati', 'Dron Khanna', 'Eduardo Guerra', 'Xiaofeng Wang'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;[Context] Software startups are engines of innovation and economy, yet building software startups is challenging and subject to a high failure rate. They need to act and respond fast in highly uncertain business environments. To do so, they need to identify crucial and actionable information that supports them in making correct decisions and reduce uncertainty. So far, the software startup literature focused predominantly on what information to measure from a metrics perspective. Thus, there is a lack of research investigating how to deal with information from an analytics perspective.  [Objective] The current study aims at understanding how software startups are dealing with crucial information that could lead to meaningful actions. The overall research question that guides the study is: what analytics mistakes do software startups make?  [Method] We investigated 22 failed software startups using their post-mortem reports as the main source. They were included in the study because the founding teams made mistakes related to information and analytics, which contributed to their startup failure to various degrees. We analyzed the collected data using thematic analysis.  [Results] Ten types of mistakes made by the 22 failed startups when dealing with information are identified. These ten types are further grouped into four categories from an analytics process perspective, including information collection, information analysis, information communication, and information usage.  [Conclusions] Our findings contribute to a better understanding of how software startups are dealing with information. It provides an opportunity for software startup teams to learn from the recurring mistakes of failed startups. Interesting future research avenues include defining patterns and antipatterns in software startup analytics by studying both failed and successful startups and doing an in-depth investigation of essential metrics for software startups.;;;https://dl.acm.org/doi/10.1145/3463274.3463305;;;Software AND Engineering
Unburdening onboarding in software product lines;;;['Raul Medeiros'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;The number of studies focusing on onboarding in software organizations has increased significantly during the last years. However, current literature overlooks onboarding in Software Product Lines (SPLs). SPLs have been proven effective in managing the increasing variability of industry software and enabling systematic reuse of a product family. Despite these benefits, SPLs are complex and exhibit particular characteristics that distinguish them from traditional software. Due to these peculiarities, SPLs require a tailor-made onboarding process. Assistance tools might help. In this dissertation, we propose assistance tools (i.e., tools built on top of the software project that help learners understand and develop knowledge) as a means for helping newcomers during onboarding in SPLs.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00121;;;Software AND Engineering
Natural language processing for software requirement specifications;;;['Mucahit Cevik', 'Savas Yildirim', 'Ayşe Başar'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Software Requirement Specifications (SRS) describe the functionality and expected performance for software products. It is one of the most important documents in the software development life cycle process that affects all the subsequent phases in product development. To manage the software requirements, requirement management tools such as IBM DOORS have been used to facilitate the communication, collaboration and verification throughout the process. Such tools generate a large amount of textual data, which can be processed through various NLP techniques to automate the software development processes. In this regard, the amalgamation of NLP and requirement engineering can catalyze the process of requirement classification (e.g., classifying requirements as functional and non-functional requirements), categorization of software documents, and topic modeling over SRS documents. Moreover, NLP-based approaches can be expanded to analyze the deeper semantics of software requirements for various purposes such as information extraction, automation of UML diagrams, AI-enabled software requirement analysis, defect and error detection in SRS, and solving the natural language ambiguities present in the requirements. In this workshop, university and IBM researchers will give insights into various existing NLP methodologies applied to SRS documents, e.g., for detecting the ambiguities and defects in the SRS documents. The prospects of various NLP-based automation techniques for conflict/duplicate detection as well as other NLP applications in requirement engineering will also be presented.;;;https://dl.acm.org/doi/10.5555/3507788.3507856;;;Software AND Engineering
Smart contract security: A practitioners' perspective: the artifact of a paper accepted in the 43rd IEEE/ACM international conference on software engineering (ICSE 2021);;;['Zhiyuan Wan', 'Xin Xia', 'David Lo', 'Jiachi Chen', 'Xiapu Luo', 'Xiaohu Yang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Blockchain is a distributed ledger that provides an open, decentralized, and fault-tolerant transaction mechanism. Blockchain technology has attracted considerable attention from both industry and academia since it is originally introduced for Bitcoin [7] to support the exchange of cryptocurrency. Blockchain technology evolves to facilitate generalpurpose computations with a wide range of decentralized applications. The Smart contract technology is one appealing decentralized application that enables the computations on top of a blockchain.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00104;;;Software AND Engineering
A Rubric to Identify Misogynistic and Sexist Texts from Software Developer Communications;;;['Sayma Sultana', 'Jaydeb Sarker', 'Amiangshu Bosu'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: As contemporary software development organizations are dominated by males, occurrences of misogynistic and sexist remarks are abundant in many communities. Such remarks are barriers to promoting diversity and inclusion in the software engineering (SE) domain. Aims: This study aims to develop a rubric to identify misogynistic remarks and sexist jokes specifically from software developer communications. Method: We have followed the systematic literature review protocol to identify 10 primary studies that have characterized misogynistic and sexist texts in various domains. Results: Based on our syntheses of the primary studies, we have developed a rubric to manually identity various categories of misogynistic or sexist remarks. We have also provided SE domain specific examples of those categories. Conclusions: Our annotation guideline will pave the path towards building automated misogynistic text classifier for the SE domain.;;;https://dl.acm.org/doi/10.1145/3475716.3484189;;;Software AND Engineering
System and Software Processes in Practice: Insights from Chinese Industry;;;['Peng Zhou', 'Arif Ali Ali Khan', 'Peng Liang', 'Sher Badshah'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Software development processes play a key role in the software and system development life cycle. Processes are becoming complex and evolve rapidly due to the modern-day continuous software engineering (CSE) concepts, which are mainly based on continuous integration, continuous delivery, infrastructure-as-code, automation and more. The fast growing Chinese software development industry adopts various processes to achieve potential benefits offered in the international market. This study is conducted with the aim to investigate the trends of processes in practice in the Chinese industry. The survey questionnaire data is collected from 34 practitioners working in software development firms across the China and the results highlight that iterative and agile processes are extensively used in industrial setting. Furthermore, agile and traditional approaches are combined to develop the hybrid processes. Most of the participants are satisfied using the current development processes, however, they show interest to continuously improve the existing process models and methods. Finally, we noticed that majority of the software development organizations used the ISO 9001 standard for process assessment and improvement activities. The given results provide preliminary overview of processes deployed in the Chinese industry.;;;https://dl.acm.org/doi/10.1145/3463274.3463786;;;Software AND Engineering
Assessing Programming Language Impact on Software Development Productivity Based on Mining OSS Repositories;;;['Altherwi Muna'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;This study is to investigate the impact of high-level, generalpurpose, programming languages on software development productivity and quality. In particular, a comparison is to be made between scripting languages and traditionally compiled, system programming ones to examine differences, if any. The data obtained for the research is from open source repositories gathered from Github. The results are going to be based on the analysis of possibly the largest open source dataset through examining a population of 15,000 projects and by including a sample of 4349 projects, where a main language can be identified. The investigation, so far, has revealed considerable differences in productivity between the two language groups.;;;https://dl.acm.org/doi/10.1145/3310013.3310017;;;Software AND Engineering
Evaluation of Software Architectures under Uncertainty: A Systematic Literature Review;;;['Dalia Sobhy', 'Rami Bahsoon', 'Leandro Minku', 'Rick Kazman'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Context: Evaluating software architectures in uncertain environments raises new challenges, which require continuous approaches. We define continuous evaluation as multiple evaluations of the software architecture that begins at the early stages of the development and is periodically and repeatedly performed throughout the lifetime of the software system. Numerous approaches have been developed for continuous evaluation; to handle dynamics and uncertainties at run-time, over the past years, these approaches are still very few, limited, and lack maturity. Objective: This review surveys efforts on architecture evaluation and provides a unified terminology and perspective on the subject. Method: We conducted a systematic literature review to identify and analyse architecture evaluation approaches for uncertainty including continuous and non-continuous, covering work published between 1990–2020. We examined each approach and provided a classification framework for this field. We present an analysis of the results and provide insights regarding open challenges. Major results and conclusions: The survey reveals that most of the existing architecture evaluation approaches typically lack an explicit linkage between design-time and run-time. Additionally, there is a general lack of systematic approaches on how continuous architecture evaluation can be realised or conducted. To remedy this lack, we present a set of necessary requirements for continuous evaluation and describe some examples.;;;https://dl.acm.org/doi/10.1145/3464305;;;Software AND Engineering
A Multivariate Characterization and Detection of Software Performance Antipatterns;;;['Alberto Avritzer', 'Ricardo Britto', 'Catia Trubiani', 'Barbara Russo', 'Andrea Janes', 'Matteo Camilli', 'André van Hoorn', 'Robert Heinrich', 'Martina Rapp', 'Jörg Henß'];;;April 2021;;;ICPE '21: Proceedings of the ACM/SPEC International Conference on Performance Engineering;;;Context. Software Performance Antipatterns (SPAs) research has focused on algorithms for the characterization, detection, and solution of antipatterns. However, existing algorithms are based on the analysis of runtime behavior to detect trends on several monitored variables (e.g., response time, CPU utilization, and number of threads) using pre-defined thresholds. Objective. In this paper, we introduce a new approach for SPA characterization and detection designed to support continuous integration/delivery/deployment (CI/CDD) pipelines, with the goal of addressing the lack of computationally efficient algorithms. Method. Our approach includes SPA statistical characterization using a multivariate analysis approach of load testing experimental results to identify the services that have the largest impact on system scalability. More specifically, we introduce a layered decomposition approach that implements statistical analysis based on response time to characterize load testing experimental results. A distance function is used to match experimental results to SPAs. Results. We have instantiated the introduced methodology by applying it to a large complex telecom system. We were able to automatically identify the top five services that are scalability choke points. In addition, we were able to automatically identify one SPA. We have validated the engineering aspects of our methodology and the expected benefits by means of a domain experts' survey. Conclusion. We contribute to the state-of-the-art by introducing a novel approach to support computationally efficient SPA characterization and detection in large complex systems using performance testing results. We have compared the computational efficiency of the proposed approach with state-of-the-art heuristics. We have found that the approach introduced in this paper grows linearly, which is a significant improvement over existing techniques.;;;https://dl.acm.org/doi/10.1145/3427921.3450246;;;Software AND Engineering
Finding metamorphic relations for scientific software;;;['Xuanyi Lin', 'Zedong Peng', 'Nan Niu', 'Wentao Wang', 'Hui Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Metamorphic testing uncovers defects by checking whether a relation holds among multiple software executions. These relations are known as metamorphic relations (MRs). For scientific software operating in a large multi-parameter input space, identifying MRs that determine the simultaneous changes among multiple variables is challenging. In this poster, we propose a fully automatic approach to classifying input and output variables from scientific software's user manual, mining these variables' associations from the user forum to generate MRs, and validating the MRs with existing regression tests. Preliminary results of our end-to-end MR support for the Storm Water Management Model (SWMM) are reported.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00118;;;Software AND Engineering
The software challenges of building smart chatbots;;;['Gwendal Daniel', 'Jordi Cabot'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Chatbots are becoming complex software artifacts that require a high-level of expertise in a variety of technical domains. This technical briefing will cover the software engineering challenges of developing high-quality chatbots. Attendees will be able to create their own bots leveraging the open source chatbot development platform Xatkit.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00138;;;Software AND Engineering
Effectively analyzing evolving software with differential facts;;;['Xiuheng Wu'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Software systems evolve continuously during their lifecycle. Developers incrementally introduce new features and fix bugs during the process, leading to lots of changes and artifacts accumulated. Driven by those rich data recorded in version control systems or issue trackers, lots of work has been done to analyze the software histories. In this PhD work, we propose a universal representation to effectively store and query over knowledge extracted from the histories, with the hope of supporting software evolution research. We have created a toolset, named DiffBase, to extract both relations between program entities at the same version, as well as atomic changes between versions. Then users can compose queries using algebraic operators, Datalog or an SQL-like language to accomplish several different evolution management tasks. Based on the existing research outcome, possible future work includes utilizing the facts approach in a scalable solution to discovering compatibility issues involving changes of multiple components and improvement on the storage and query performance of DiffBase.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678659;;;Software AND Engineering
Behavioral Economics Issues for Software Requirements Optimization for Personal Data Security and Privacy;;;['Shatadru Shikta', 'Somania Nur Mahal', 'Kazi Bushra Al Jannat', 'MAHADY HASAN', 'M. ROKONUZZAMAN'];;;July 2021;;;ICCTA '21: Proceedings of the 2021 7th International Conference on Computer Technology Applications;;;The effects of psychological, cognitive, emotional, cultural and social factors on the decisions of users and service providers for online service delivery are important factors to take into consideration in designing software applications. Increasing preference of online service delivery is also raising concerns about personal data security and privacy. Hence, there is a need for optimally trading off ease of use and extra measures for ensuring data privacy and security issues. Within this context, behavioral economics is one of the major factors in determining outcomes and successes of underlying software applications. Although much research done on behavioral economics separately, however, behavioral economics is mostly unexplored in the field of software requirements engineering process. With the growing needs of personal data security and privacy concerns, the software community needs to adapt it to software requirements optimization to incorporate and prioritize requirements related to personal data security and privacy. In this study, our main objective is to explore the behavioral economics issues towards data security and privacy and adapt them into the software requirement process. We have proposed a score-based framework. The ultimate goal of this framework is to help companies maximize the benefit and minimize the cost of software products while adapting the data security and privacy requirements in the requirement engineering process.;;;https://dl.acm.org/doi/10.1145/3477911.3477918;;;Software AND Engineering
Reel life vs. real life: how software developers share their daily life through vlogs;;;['Souti Chattopadhyay', 'Thomas Zimmermann', 'Denae Ford'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Software developers are turning to vlogs (video blogs) to share what a day is like to walk in their shoes. Through these vlogs developers share a rich perspective of their technical work as well their personal lives. However, does the type of activities portrayed in vlogs differ from activities developers in the industry perform? Would developers at a software company prefer to show activities to different extents if they were asked to share about their day through vlogs? To answer these questions, we analyzed 130 vlogs by software developers on YouTube and conducted a survey with 335 software developers at a large software company. We found that although vlogs present traditional development activities such as coding and code peripheral activities (11%), they also prominently feature wellness and lifestyle related activities (47.3%) that have not been reflected in previous software engineering literature. We also found that developers at the software company were inclined to share more non-coding tasks (e.g., personal projects, time spent with family and friends, and health) when asked to create a mock-up vlog to promote diversity. These findings demonstrate a shift in our understanding of how software developers are spending their time and find valuable to share publicly. We discuss how vlogs provide a more complete perspective of software development work and serve as a valuable source of data for empirical research.;;;https://dl.acm.org/doi/10.1145/3468264.3468599;;;Software AND Engineering
Customer Satisfaction in Software Development Projects;;;['Panos Fitsilis', 'Vyron Damasiotis', 'Sofia Sarmanioti'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;In this study, research is being conducted about the Customer's Satisfaction (CS) along with factors that have an impact on it and on the Software Project Management. The research method of this study is the Systematic Literature Review (SLR) and the main conclusion derived from this study is that the customer's active involvement through agile methods in all phases of the IT project development, leads to a higher level of satisfaction.;;;https://dl.acm.org/doi/10.1145/3501774.3501784;;;Software AND Engineering
Application of smart factory digital twin technology in the teaching system of cultivating undergraduates's ability to solve complex engineering problems;;;['Yan Bai', 'Yue Wang', 'Yanli Wang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;None;;;https://dl.acm.org/doi/10.1145/3482632.3482667;;;Software AND Engineering
Onboarding in software product lines: concept maps as welcome guides;;;['Maider Azanza', 'Arantza Irastorza', 'Raul Medeiros', 'Oscar Díaz'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;With a volatile labour and technological market, onboarding is becoming increasingly important. The process of incorporating a new developer, a.k.a. the newcomer, into a software development team is reckoned to be lengthy, frustrating and expensive. Newcomers face personal, interpersonal, process and technical barriers during their incorporation, which, in turn, affects the overall productivity of the whole team. This problem exacerbates for Software Product Lines (SPLs), where their size and variability combine to make onboarding even more challenging, even more so for developers that are transferred from the Application Engineering team into the Domain Engineering team, who will be our target newcomers. This work presents concept maps on the role of sensemaking scaffolds to help to introduce these newcomers into the SPL domain. Concept maps, used as knowledge visualisation tools, have been proven to be helpful for meaningful learning. Our main insight is to capture concepts of the SPL domain and their interrelationships in a concept map, and then, present them incrementally, helping newcomers grasp the SPL and aiding them in exploring it in a guided manner while avoiding information overload. This work's contributions are four-fold. First, concept maps are proposed as a representation to introduce newcomers into the SPL domain. Second, concept maps are presented as the means for a guided exploration of the SPL core assets. Third, a feature-driven concept map construction process is introduced. Last, the usefulness of concept maps as guides for SPL onboarding is tested through a formative evaluation. Link to the online demo: https://rebrand.ly/wacline-cmap;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00022;;;Software AND Engineering
A Systematic Review on Software Robustness Assessment;;;['Nuno Laranjeiro', 'João Agnelo', 'Jorge Bernardino'];;;None;;;ACM Computing Surveys;;;Robustness is the degree to which a certain system or component can operate correctly in the presence of invalid inputs or stressful environmental conditions. With the increasing complexity and widespread use of computer systems, obtaining assurances regarding their robustness has become of vital importance. This survey discusses the state of the art on software robustness assessment, with emphasis on key aspects like types of systems being evaluated, assessment techniques used, the target of the techniques, the types of faults used, and how system behavior is classified. The survey concludes with the identification of gaps and open challenges related with robustness assessment.;;;https://dl.acm.org/doi/10.1145/3448977;;;Software AND Engineering
ICS3Fuzzer: A Framework for Discovering Protocol Implementation Bugs in ICS Supervisory Software by Fuzzing;;;['Dongliang Fang', 'Zhanwei Song', 'Le Guan', 'Puzhuo Liu', 'Anni Peng', 'Kai Cheng', 'Yaowen Zheng', 'Peng Liu', 'Hongsong Zhu', 'Limin Sun'];;;December 2021;;;ACSAC '21: Proceedings of the 37th Annual Computer Security Applications Conference;;;The supervisory software is widely used in industrial control systems (ICSs) to manage field devices such as PLC controllers. Once compromised, it could be misused to control or manipulate these physical devices maliciously, endangering manufacturing process or even human lives. Therefore, extensive security testing of supervisory software is crucial for the safe operation of ICS. However, fuzzing ICS supervisory software is challenging due to the prevalent use of proprietary protocols. Without the knowledge of the program states and packet formats, it is difficult to enter the deep states for effective fuzzing.  In this work, we present a fuzzing framework to automatically discover implementation bugs residing in the communication protocols between the supervisory software and the field devices. To avoid heavy human efforts in reverse-engineering the proprietary protocols, the proposed approach constructs a state-book based on the readily-available execution trace of the supervisory software and the corresponding inputs. Then, we propose a state selection algorithm to find the protocol states that are more likely to have bugs. Our fuzzer distributes more budget on those interesting states. To quickly reach the interesting states, traditional snapshot-based method does not work since the communication protocols are time sensitive. We address this issue by synchronously managing external events (GUI operations and network traffic) during the fuzzing loop. We have implemented a prototype and used it to fuzz the supervisory software of four popular ICS platforms. We have found 13 bugs and received 3 CVEs, 2 are classified as critical (CVSS3.x score CRITICAL 9.8) and affected 40 different products.;;;https://dl.acm.org/doi/10.1145/3485832.3488028;;;Software AND Engineering
Planned Behavior and Social Cognitive Model for Accounting Student Intention in Learning Audit Software;;;['Bambang Leo Handoko', 'Ang Swat Lin Lindawati', 'Mazlina Mustapha'];;;December 2021;;;ICSEB '21: Proceedings of the 2021 5th International Conference on Software and e-Business;;;The industrial revolution 4.0 has penetrated all fields, including accounting and auditing. Higher education institutions and universities, in this case as labor printers, are also required to prepare graduates who are technologically savvy. We at the auditing scientific community also prepare students to become auditors who understand technology, in this case audit software. In order to become quality auditor in the future, literacy in audit software is mandatory for accounting student. We examine the factors that influence student interest in learning audio software. We use the approach of the theory of planned behavior and social cognitive theory. Our research is quantitative research, the object of our research is students who take the method and practice of computerized audit course. The data we process is primary data from questionnaires to respondents. We use statistical software for data analysis, namely Smart PLS 3. Our results state that the variables attitude, perceived behavioral control and self-efficacy have a significant effect, while subjective norms have no significant effect on student intention in learning audit software.;;;https://dl.acm.org/doi/10.1145/3507485.3507505;;;Software AND Engineering
Software Architectural Migration: An Automated Planning Approach;;;['Nacha Chondamrongkul', 'Jing Sun', 'Ian Warren'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Software architectural designs are usually changed over time to support emerging technologies and to adhere to new principles. Architectural migration is an important activity that helps to transform the architectural styles applied during a system’s design with the result of modernising the system. If not performed correctly, this process could lead to potential system failures. This article presents an automated approach to refactoring architectural design and to planning the evolution process. With our solution, the architectural design can be refactored, ensuring that system functionality is preserved. Furthermore, the architectural migration process allows the system to be safely and incrementally transformed. We have evaluated our approach with five real-world software applications. The results prove the effectiveness of our approach and identify factors that impact the performance of architectural verification and migration planning. An interesting finding is that planning algorithms generate migration plans that differ in term of their relative efficiency.;;;https://dl.acm.org/doi/10.1145/3461011;;;Software AND Engineering
From Crowdsourced Software Development to Crowdtesting;;;['Wei-Tek Tsai', 'Li Zhang', 'Shufeng Hu'];;;October 2021;;;ICCSE '21: 5th International Conference on Crowd Science and Engineering;;;Crowdsourcing Software Development (CSD) has existed and developed for many years. Over the years, CSD has made new progress and changes. The original intention of CSD is to reduce the cost of software development. However, the crowdsourcing approach encountered difficulties in software development, so it turned to software testing. Crowdsourcing Software Testing (CST) has had some successful cases. It has many advantages, such as reducing the cost and time of software testing. In this paper, we analyze the problems that crowdsourcing faces in software development and come to the view that crowdsourcing is more suitable for software testing. We analyzed the Quadrilateral Co-petition Model in the CST platforms, and gave the methods for optimization. We also proposed a new software testing program that integrates open source sharing and crowdsourcing methods.;;;https://dl.acm.org/doi/10.1145/3503181.3503185;;;Software AND Engineering
Technical Leverage in a Software Ecosystem: Development Opportunities and Security Risks;;;['Fabio Massacci', 'Ivan Pashchenko'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;In finance, leverage is the ratio between assets borrowed from others and one's own assets. A matching situation is present in software: by using free open-source software (FOSS) libraries a developer leverages on other people's code to multiply the offered functionalities with a much smaller own codebase. In finance as in software, leverage magnifies profits when returns from borrowing exceed costs of integration, but it may also magnify losses, in particular in the presence of security vulnerabilities. We aim to understand the level of technical leverage in the FOSS ecosystem and whether it can be a potential source of security vulnerabilities. Also, we introduce two metrics change distance and change direction to capture the amount and the evolution of the dependency on third-party libraries. The application of the proposed metrics on 8494 distinct library versions from the FOSS Maven-based Java libraries shows that small and medium libraries (less than 100KLoC) have disproportionately more leverage on FOSS dependencies in comparison to large libraries. We show that leverage pays off as leveraged libraries only add a 4% delay in the time interval between library releases while providing four times more code than their own. However, libraries with such leverage (i.e., 75% of libraries in our sample) also have 1.6 higher odds of being vulnerable in comparison to the libraries with lower leverage. We provide an online demo for computing the proposed metrics for real-world software libraries available under the following URL: https://techleverage.eu/.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00125;;;Software AND Engineering
Research on the Mixed Teaching Mode of Office Automation Course Based on OBE under the New Engineering Background;;;['Juan Shen'];;;May 2021;;;ICDEL '21: Proceedings of the 2021 6th International Conference on Distance Education and Learning;;;"Office Automation" is a public basic course in university curriculum, which pays attention to the combination of theory and practice. In the course implementation process, the OA course is explored in a hybrid online and offline teaching mode based on the concept of OBE. In this paper, we design a hierarchical teaching method to improve the teaching effect in a way of continuous improvement.;;;https://dl.acm.org/doi/10.1145/3474995.3475006;;;Software AND Engineering
Identifying bad software changes via multimodal anomaly detection for online service systems;;;['Nengwen Zhao', 'Junjie Chen', 'Zhaoyang Yu', 'Honglin Wang', 'Jiesong Li', 'Bin Qiu', 'Hongyu Xu', 'Wenchi Zhang', 'Kaixin Sui', 'Dan Pei'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;In large-scale online service systems, software changes are inevitable and frequent. Due to importing new code or configurations, changes are likely to incur incidents and destroy user experience. Thus it is essential for engineers to identify bad software changes, so as to reduce the influence of incidents and improve system re- liability. To better understand bad software changes, we perform the first empirical study based on large-scale real-world data from a large commercial bank. Our quantitative analyses indicate that about 50.4% of incidents are caused by bad changes, mainly be- cause of code defect, configuration error, resource contention, and software version. Besides, our qualitative analyses show that the current practice of detecting bad software changes performs not well to handle heterogeneous multi-source data involved in soft- ware changes. Based on the findings and motivation obtained from the empirical study, we propose a novel approach named SCWarn aiming to identify bad changes and produce interpretable alerts accurately and timely. The key idea of SCWarn is drawing support from multimodal learning to identify anomalies from heterogeneous multi-source data. An extensive study on two datasets with various bad software changes demonstrates our approach significantly outperforms all the compared approaches, achieving 0.95 F1-score on average and reducing MTTD (mean time to detect) by 20.4%∼60.7%. In particular, we shared some success stories and lessons learned from the practical usage.;;;https://dl.acm.org/doi/10.1145/3468264.3468543;;;Software AND Engineering
Identifying casualty changes in software patches;;;['Adriana Sejfia', 'Yixue Zhao', 'Nenad Medvidović'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Noise in software patches impacts their understanding, analysis, and use for tasks such as change prediction. Although several approaches have been developed to identify noise in patches, this issue has persisted. An analysis of a dataset of security patches for the Tomcat web server, which we further expanded with security patches from five additional systems, uncovered several kinds of previously unreported noise which we call nonessential casualty changes. These are changes that themselves do not alter the logic of the program but are necessitated by other changes made in the patch. In this paper, we provide a comprehensive taxonomy of casualty changes. We then develop CasCADe, an automated technique for automatically identifying casualty changes. We evaluate CasCADe with several publicly available datasets of patches and tools that focus on them. Our results show that CasCADe is highly accurate, that the kinds of noise it identifies occur relatively commonly in patches, and that removing this noise improves upon the evaluation results of a previously published change-based approach.;;;https://dl.acm.org/doi/10.1145/3468264.3468624;;;Software AND Engineering
Towards a Human Values Dashboard for Software Development: An Exploratory Study;;;['Arif Nurwidyantoro', 'Mojtaba Shahin', 'Michel Chaudron', 'Waqar Hussain', 'Harsha Perera', 'Rifat Ara Shams', 'Jon Whittle'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: There is a growing awareness of the importance of human values (e.g., inclusiveness, privacy) in software systems. However, there are no practical tools to support the integration of human values during software development. We argue that a tool that can identify human values from software development artefacts and present them to varying software development roles can (partially) address this gap. We refer to such a tool as human values dashboard. Further to this, our understanding of such a tool is limited. Aims: This study aims to (1) investigate the possibility of using a human values dashboard to help address human values during software development, (2) identify possible benefits of using a human values dashboard, and (3) elicit practitioners' needs from a human values dashboard. Method: We conducted an exploratory study by interviewing 15 software practitioners. A dashboard prototype was developed to support the interview process. We applied thematic analysis to analyse the collected data. Results: Our study finds that a human values dashboard would be useful for the development team (e.g., project manager, developer, tester). Our participants acknowledge that development artefacts, especially requirements documents and issue discussions, are the most suitable source for identifying values for the dashboard. Our study also yields a set of high-level user requirements for a human values dashboard (e.g., it shall allow determining values priority of a project). Conclusions: Our study suggests that a values dashboard is potentially used to raise awareness of values and support values-based decision-making in software development. Future work will focus on addressing the requirements and using issue discussions as potential artefacts for the dashboard.;;;https://dl.acm.org/doi/10.1145/3475716.3475770;;;Software AND Engineering
Understanding emotions of developer community towards software documentation;;;['Akhila Sri Manasa Venigalla', 'Sridhar Chimalakonda'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;The availability of open-source projects facilitates developers to contribute and collaborate on a wide range of projects. As a result, the developer community contributing to such open-source projects is also increasing. Many of the projects involve frequent updates and extensive reuses. A well-updated documentation helps in a better understanding of the software project and also facilitates efficient contribution and reuse. Though software documentation plays an important role in the development and maintenance of software, it also suffers from various issues that include insufficiency, inconsistency, ill-maintainability, and so on. Exploring the perception of developers towards documentation could help in understanding the reasons behind prevalent issues in software documentation. It could further aid in deciding on training that could be given to the developer community towards building more sustainable projects for society. Analyzing sentiments of contributors to a project could provide insights on understanding developer perceptions. Hence, as the first step towards this direction, we analyze sentiments of commit messages specific to the documentation of a software project. To this end, we considered the commit history of 998 GitHub projects from the GHTorrent dataset and identified 10,996 commits that correspond to the documentation of repositories. Further, we apply sentiment analysis techniques to obtain insights on the type of sentiment being expressed in commit messages of the selected commits. We observe that around 45% of the identified commit messages express trust emotion.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00018;;;Software AND Engineering
Predicting Performance Anomalies in Software Systems at Run-time;;;['Guoliang Zhao', 'Safwat Hassan', 'Ying Zou', 'Derek Truong', 'Toby Corbin'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;High performance is a critical factor to achieve and maintain the success of a software system. Performance anomalies represent the performance degradation issues (e.g., slowing down in system response times) of software systems at run-time. Performance anomalies can cause a dramatically negative impact on users’ satisfaction. Prior studies propose different approaches to detect anomalies by analyzing execution logs and resource utilization metrics after the anomalies have happened. However, the prior detection approaches cannot predict the anomalies ahead of time; such limitation causes an inevitable delay in taking corrective actions to prevent performance anomalies from happening. We propose an approach that can predict performance anomalies in software systems and raise anomaly warnings in advance. Our approach uses a Long-Short Term Memory neural network to capture the normal behaviors of a software system. Then, our approach predicts performance anomalies by identifying the early deviations from the captured normal system behaviors. We conduct extensive experiments to evaluate our approach using two real-world software systems (i.e., Elasticsearch and Hadoop). We compare the performance of our approach with two baselines. The first baseline is one state-to-the-art baseline called Unsupervised Behavior Learning. The second baseline predicts performance anomalies by checking if the resource utilization exceeds pre-defined thresholds. Our results show that our approach can predict various performance anomalies with high precision (i.e., 97–100%) and recall (i.e., 80–100%), while the baselines achieve 25–97% precision and 93–100% recall. For a range of performance anomalies, our approach can achieve sufficient lead times that vary from 20 to 1,403 s (i.e., 23.4 min). We also demonstrate the ability of our approach to predict the performance anomalies that are caused by real-world performance bugs. For predicting performance anomalies that are caused by real-world performance bugs, our approach achieves 95–100% precision and 87–100% recall, while the baselines achieve 49–83% precision and 100% recall. The obtained results show that our approach outperforms the existing anomaly prediction approaches and is able to predict performance anomalies in real-world systems.;;;https://dl.acm.org/doi/10.1145/3440757;;;Software AND Engineering
Lamboozling Attackers: A New Generation of Deception: Software engineering teams can exploit attackers' human nature by building deception environments.;;;['Kelly Shortridge', 'Ryan Petrich'];;;September-October 2021;;;Queue;;;The goal of this article is to educate software leaders, engineers, and architects on the potential of deception for systems resilience and the practical considerations for building deception environments. By examining the inadequacy and stagnancy of historical deception efforts by the information security community, the article also demonstrates why engineering teams are now poised to become significantly more successful owners of deception systems.;;;https://dl.acm.org/doi/10.1145/3494834.3494836;;;Software AND Engineering
Microtasking Software Failure Resolution: Early Results;;;['Christian Adriano'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;Open source software development enabled distributed teams of programmers to contribute to large software systems that became standards in the operation of government and business. Crowdsourcing went further by enabling contributions in the form of small and independent tasks. This allowed teams to scale from dozens to hundreds of people. While crowdsourcing established as industry practice in the areas of software testing, it is challenging for source code related tasks, e.g., software debugging. One of the reasons is that the complex dependencies in the source code can make many tasks difficult to partition and sequence, and later aggregate their outcomes. I am investigating these problems in the context of failure resolution tasks. A failure resolution task consists of inspecting the source code with the objective to identify and explain the root-cause of a software failure. My approach partitions code inspection into questions that are automatically instantiated from templates. I present here my research plan and the early results of experiments on the efficacy, efficiency, and scalability of my approach.;;;https://dl.acm.org/doi/10.1145/3310013.3310016;;;Software AND Engineering
OSS Effort Estimation Using Software Features Similarity and Developer Activity-Based Metrics;;;['Ritu Kapur', 'Balwinder Sodhi'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Software development effort estimation (SDEE) generally involves leveraging the information about the effort spent in developing similar software in the past. Most organizations do not have access to sufficient and reliable forms of such data from past projects. As such, the existing SDEE methods suffer from low usage and accuracy.We propose an efficient SDEE method for open source software, which provides accurate and fast effort estimates. The significant contributions of our article are (i) novel SDEE software metrics derived from developer activity information of various software repositories, (ii) an SDEE dataset comprising the SDEE metrics’ values derived from approximately 13,000 GitHub repositories from 150 different software categories, and (iii) an effort estimation tool based on SDEE metrics and a software description similarity model. Our software description similarity model is basically a machine learning model trained using the PVA on the software product descriptions of GitHub repositories. Given the software description of a newly envisioned software, our tool yields an effort estimate for developing it.Our method achieves the highest standardized accuracy score of 87.26% (with Cliff’s δ = 0.88 at 99.999% confidence level) and 42.7% with the automatically transformed linear baseline model. Our software artifacts are available at https://doi.org/10.5281/zenodo.5095723.;;;https://dl.acm.org/doi/10.1145/3485819;;;Software AND Engineering
Feature Transformation for Improved Software Bug Detection Models;;;['Shamse Tasnim Cynthia', 'Banani Roy', 'Debajyoti Mondal'];;;February 2022;;;ISEC 2022: 15th Innovations in Software Engineering Conference;;;Testing software is considered to be one of the most crucial phases in software development life cycle. Software bug fixing requires a significant amount of time and effort. A rich body of recent research explored ways to predict bugs in software artifacts using machine learning based techniques. For a reliable and trustworthy prediction, it is crucial to also consider the explainability aspects of such machine learning models. In this paper, we show how the feature transformation techniques can significantly improve the prediction accuracy and build confidence in building bug prediction models. We propose a novel approach for improved bug prediction that first extracts the features, then finds a weighted transformation of these features using a genetic algorithm that best separates bugs from non-bugs when plotted in a low-dimensional space, and finally, trains the machine learning model using the transformed dataset. In our experiment with real-life bug datasets, the random forest and k-nearest neighbor classifier models that leveraged feature transformation showed 4.25% improvement in recall values on an average of over 8 software systems when compared to the models built on original data.;;;https://dl.acm.org/doi/10.1145/3511430.3511444;;;Software AND Engineering
Mining Software Entities in Scientific Literature: Document-level NER for an Extremely Imbalance and Large-scale Task;;;['Patrice Lopez', 'Caifan Du', 'Johanna Cohoon', 'Karthik Ram', 'James Howison'];;;October 2021;;;CIKM '21: Proceedings of the 30th ACM International Conference on Information &amp; Knowledge Management;;;We present a comprehensive information extraction system dedicated to software entities in scientific literature. This task combines the complexity of automatic reading of scientific documents (PDF processing, document structuring, styled/rich text, scaling) with challenges specific to mining software entities: high heterogeneity and extreme sparsity of mentions, document-level cross-references, disambiguation of noisy software mentions and poor portability of Machine Learning approaches between highly specialized domains. While NER is a key component to recognize new and unseen software, considering this task as a simple NER application fails to address most of these issues. In this paper, we propose a multi-model Machine Learning approach where raw documents are ingested by a cascade of document structuring processes applied not to text, but to layout token elements. The cascading process further enriches the relevant structures of the document with a Deep Learning software mention recognizer adapted to the high sparsity of mentions. The Machine Learning cascade culminates with entity disambiguation to alleviate false positives and to provide software entity linking. A bibliographical reference resolution is integrated to the process for attaching references cited alongside the software mentions. Based on the first gold-standard annotated dataset developed for software mentions, this work establishes a new reference end-to-end performance for this task. Experiments with the CORD-19 publications have further demonstrated that our system provides practically usable performance and is scalable to the whole scientific corpus, enabling novel applications for crediting research software and for better understanding the impact of software in science.;;;https://dl.acm.org/doi/10.1145/3459637.3481936;;;Software AND Engineering
Mining software repositories with a collaborative heuristic repository;;;['Hlib Babii', 'Julian Aron Prenner', 'Laurin Stricker', 'Anjan Karmakar', 'Andrea Janes', 'Romain Robbes'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Many software engineering studies or tasks rely on categorizing software engineering artifacts. In practice, this is done either by defining simple but often imprecise heuristics, or by manual labelling of the artifacts. Unfortunately, errors in these categorizations impact the tasks that rely on them. To improve the precision of these categorizations, we propose to gather heuristics in a collaborative heuristic repository, to which researchers can contribute a large amount of diverse heuristics for a variety of tasks on a variety of SE artifacts. These heuristics are then leveraged by state-of-the-art weak supervision techniques to train high-quality classifiers, thus improving the categorizations. We present an initial version of the heuristic repository, which we applied to the concrete task of commit classification.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00030;;;Software AND Engineering
Bridging the Gap between RTL and Software Fault Injection;;;['J. Laurent', 'C. Deleuze', 'F. Pebay-Peyroula', 'V. Beroulle'];;;None;;;ACM Journal on Emerging Technologies in Computing Systems;;;Protecting programs against hardware fault injection requires accurate software fault models. However, typical models, such as the instruction skip, do not take into account the microarchitecture specificities of a processor. We propose in this article an approach to study the relation between faults at the Register Transfer Level (RTL) and faults at the software level. The goal is twofold: accurately model RTL faults at the software level and materialize software fault models to actual RTL injections. These goals lead to a better understanding of a system's security against hardware fault injection, which is important to design effective and cost-efficient countermeasures. Our approach is based on the comparison between results from RTL simulations and software injections (using a program mutation tool). Various analyses are included in this article to give insight on the relevance of software fault models, such as the computation of a coverage and fidelity metric, and to link software fault models to hardware RTL descriptions. These analyses are applied on various single-bit and multiple-bit injection campaigns to study the faulty behaviors of a RISC-V processor.;;;https://dl.acm.org/doi/10.1145/3446214;;;Software AND Engineering
Privacy as first-class requirements in software development: a socio-technical approach;;;['Yizhaq Benbenisty', 'Irit Hadar', 'Gil Luria', 'Paola Spoletini'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Privacy requirements have become increasingly important as information about us is continuously accumulated and digitally stored. However, despite the many proposed methodologies and tools to address these requirements, privacy engineering is often underperformed in most domains of the software industry. Two of the major reasons underlying this under-performance are (1) the low expertise and understanding of privacy by the two main actors in requirements engineering: users and analysts, and (2) the fact that software developers often do not perceive privacy requirements as a priority for their companies, thus neglecting to meet these requirements even when they do have the required knowledge, skills, and supporting tools to do so. To address these two problems, we propose to integrate knowledge from software engineering and organizational psychology in an iterative, customizable, socio-technical environment. Such environment has the potential to support the design of systems by providing technical tools for eliciting, modeling, and designing privacy aspects, thus addressing the knowledge gap of both data subjects and analysts, and social mechanisms for achieving a supportive and sustainable organizational privacy climate within a company, thus reorienting the organizational attention and engagement toward addressing privacy requirements.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678872;;;Software AND Engineering
Challenges of implementing software variability in eclipse OMR: an interview study;;;['Batyr Nuryyev', 'Sarah Nadi', 'Nazim Uddin Bhuiyan', 'Leonardo Banderali'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Software variability is the ability of a software system to be customized or configured for a particular context. In this paper, we discuss our experience investigating software variability implementation challenges in practice. Eclipse OMR, developed by IBM, is a set of highly configurable C++ components for building language runtimes; it supports multiple programming languages and target architectures. We conduct an interview study with 6 Eclipse OMR developers and identify 8 challenges incurred by the existing variability implementation, and 3 constraints that need to be taken into account for any reengineering effort. We discuss these challenges and investigate the literature and existing open-source systems for potential solutions. We contribute a solution for one of the challenges, namely adding variability to enumerations and arrays. We also share our experiences and lessons learned working with a large-scale highly configurable industry project. For example, we found that the "latest and greatest" research solutions may not always be favoured by developers due to small practical considerations such as build dependencies, or even C++ version constraints.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00012;;;Software AND Engineering
Trust yourself! Or maybe not: factors related to overconfidence and uncertainty assessments of software effort estimates;;;['Patricia Matsubara', 'Igor Steinmacher', 'José Maldonado', 'Bruno Gadelha', 'Tayana Conte'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software effort estimates are uncertain, given that they are probabilistic assessments of the future. Evaluating their uncertainty involves assigning them an appropriate confidence level and is paramount for satisfying commitments in software projects. However, estimators tend to be overconfident about their estimates, hampering the accuracy of their uncertainty assessments. Our research goal is to identify the factors related to overconfidence and uncertainty assessments in software estimation. To do so, we carried out a Systematic Literature Mapping (SLM), based on automated and snowballing searches. Our findings include eight factors related to overconfidence and uncertainty assessment. Some of them resulted in unexpected implications for practice. We also identified valuable and easy-to-use metrics that software practitioners can apply smoothly in their daily practice. Additionally, very few field and respondent studies exist about the topic. The software engineering area can significantly benefit from investigating how much practitioners know about the overconfidence effect, as well as of a better comprehension of the perceived importance, practices, and accuracy of uncertainty assessments in the software industry.;;;https://dl.acm.org/doi/10.1145/3474624.3474643;;;Software AND Engineering
Experiences and Practices in GUI Functional Testing: A Software Practitioners’ View;;;['Nailton Junior', 'Heitor Costa', 'Leila Karita', 'Ivan Machado', 'Larissa Soares'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software testing is an important activity to ensure software quality. A widely performed type of testing is GUI (Graphical User Interface) functional testing, where the aim is to evaluate the software functionality through their graphic interface. We can find in the literature techniques and solutions for handling GUI functional testing in the last years. However, studies that deeply analyze how professionals in the industry perform GUI functional testing are still lacking. In this study, we investigated how testing professionals perform GUI functional testing. We surveyed 222 professionals from different positions and roles who perform those tests. The results indicate that many professionals perform GUI functional testing without proper tool support. They also pointed out that GUI test automation tools have limitations. This study presents preliminary results to understand the Brazilian companies’ scenario on the difficulties of GUI functional testing.;;;https://dl.acm.org/doi/10.1145/3474624.3474640;;;Software AND Engineering
Challenges and gratitude: a diary study of software engineers working from home during Covid-19 pandemic;;;['Jenna Butler', 'Sonia Jaffe'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Covid-19 dramatically changed how organizations worked. Microsoft was one of the first to ask employees to work from home (WFH). We developed an anonymous nightly diary study with 435 participants and learned about their experiences over the first 10 weeks of the WFH directive. We found the largest challenges were having too many meetings, feeling overworked, and physical and mental health. However, engineers reported gratitude for family, increased flexibility, being employed, and team support. People who reported no gratitude were 22% (p-value=.000007) less likely to report being satisfied that day. Many people also reported that the simple act of reflecting nightly during the study was helpful to them. Our management used the anonymized, aggregate data to create new programs (such as No Meeting Friday) to address these challenges. We then saw immediate feedback on these programs in the diaries and used that to inform future decisions.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00047;;;Software AND Engineering
Smart prediction for refactorings in the software test code;;;['Luana Martins', 'Carla Bezerra', 'Heitor Costa', 'Ivan Machado'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Test smells are bad practices to either design or implement a test code. Their presence may reduce the test code quality, harming the software testing activities, primarily from a maintenance perspective. Therefore, defining strategies and tools to handle test smells and improve the test code quality is necessary. State-of-the-art strategies encompass automated support mainly based on hard thresholds of rules, static and dynamic metrics to identify the test smells. Such thresholds are subjective to interpretation and may not consider the complexity of the software projects. Moreover, they are limited as they do not automate test refactoring but only count on developers’ expertise and intuition. In this context, a technique that uses historical implicit or tacit data to generate knowledge could assist the identification and refactoring of test smells. This study aims to establish a novel approach based on machine learning techniques to suggest developers refactoring strategies for test smells. As an expected result, we could understand the applicability of the machine learning techniques to handle test smells and a framework proposal that helps developers in decision-making regarding the refactoring of test smells.;;;https://dl.acm.org/doi/10.1145/3474624.3477070;;;Software AND Engineering
An exploratory study of autopilot software bugs in unmanned aerial vehicles;;;['Dinghua Wang', 'Shuqing Li', 'Guanping Xiao', 'Yepang Liu', 'Yulei Sui'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Unmanned aerial vehicles (UAVs) are becoming increasingly important and widely used in modern society. Software bugs in these systems can cause severe issues, such as system crashes, hangs, and undefined behaviors. Some bugs can also be exploited by hackers to launch security attacks, resulting in catastrophic consequences. Therefore, techniques that can help detect and fix software bugs in UAVs are highly desirable. However, although there are many existing studies on bugs in various types of software, the characteristics of UAV software bugs have never been systematically studied. This impedes the development of tools for assuring the dependability of UAVs. To bridge this gap, we conducted the first large-scale empirical study on two well-known open-source autopilot software platforms for UAVs, namely PX4 and Ardupilot, to characterize bugs in UAVs. Through analyzing 569 bugs from these two projects, we observed eight types of UAV-specific bugs (i.e., limit, math, inconsistency, priority, parameter, hardware support, correction, and initialization) and learned their root causes. Based on the bug taxonomy, we summarized common bug patterns and repairing strategies. We further identified five challenges associated with detecting and fixing such UAV-specific bugs. Our study can help researchers and practitioners to better understand the threats to the dependability of UAV systems and facilitate the future development of UAV bug diagnosis tools.;;;https://dl.acm.org/doi/10.1145/3468264.3468559;;;Software AND Engineering
Directives of Communicability for Software Artifacts;;;['Adriana Lopes Damian', 'Clarisse Sieckenius de Souza', 'Tayana Conte'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Software artifacts created in the early stages of the development process describe the proposed solutions for the system, such as UML and prototypes. For this reason, these artifacts are important for team communication. Miscommunication via artifacts occurs because practitioners typically focus on modeling, without reflecting on how other software development team members interpret them. Incorrect information during the development process can be introduced in the system due to miscommunication, impacting its quality. In this context, this work aimed to answer the following research question: How to support effective communication between producers and consumers of artifacts developed in the early stages of software development? To answer this question, we proposed the Directives of Communicability (DCs), based on theories that investigate different communication perspectives and exploratory studies. We designed the DCs to support practitioners to analyze characteristics that affect the artifact's content on communication. We conducted different empirical studies with our proposal, with 105 participants from industry and academia. From the empirical studies results, we noticed the DCs supported the reflection of producers’ artifacts, contributing to effective communication and reducing defects caused by miscommunication.;;;https://dl.acm.org/doi/10.1145/3493244.3493276;;;Software AND Engineering
Continuous and Proactive Software Architecture Evaluation: An IoT Case;;;['Dalia Sobhy', 'Leandro Minku', 'Rami Bahsoon', 'Rick Kazman'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Design-time evaluation is essential to build the initial software architecture to be deployed. However, experts’ assumptions made at design-time are unlikely to remain true indefinitely in systems that are characterized by scale, hyperconnectivity, dynamism, and uncertainty in operations (e.g. IoT). Therefore, experts’ design-time decisions can be challenged at run-time. A continuous architecture evaluation that systematically assesses and intertwines design-time and run-time decisions is thus necessary. This paper proposes the first proactive approach to continuous architecture evaluation of the system leveraging the support of simulation. The approach evaluates software architectures by not only tracking their performance over time, but also forecasting their likely future performance through machine learning of simulated instances of the architecture. This enables architects to make cost-effective informed decisions on potential changes to the architecture. We perform an IoT case study to show how machine learning on simulated instances of architecture can fundamentally guide the continuous evaluation process and influence the outcome of architecture decisions. A series of experiments is conducted to demonstrate the applicability and effectiveness of the approach. We also provide the architect with recommendations on how to best benefit from the approach through choice of learners and input parameters, grounded on experimentation and evidence.;;;https://dl.acm.org/doi/10.1145/3492762;;;Software AND Engineering
Understanding language selection in multi-language software projects on GitHub;;;['Wen Li', 'Na Meng', 'Li Li', 'Haipeng Cai'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;There are hundreds of programming languages available for software development today. As a result, modern software is increasingly developed in multiple languages. In this context, there is an urgent need for automated tools for multi-language software quality assurance. To that end, it is useful to first understand how languages are chosen by developers in multi-language software projects. One intuitive perspective towards the understanding would be to explore the potential functionality relevance of those choices. With a plethora of publicly hosted multi-language software projects available on GitHub, we were able to obtain thousands of popular, relevant repositories across 10 years from 2010 to 2019 to enable the exploration. We start by estimating the functionality domain of each project through topic modeling, followed by studying the statistical correlation between these domains and language selection over all the sample projects through association mining. We proceed with an evolutionary characterization of these projects to provide a longitudinal view of how the association has changed over the years. Our findings offer useful insights into the rationale behind developers' choices of language combinations in multi-language software construction.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00119;;;Software AND Engineering
What We Can Learn From Visual Artists About Software Development;;;['Jingyi Li', 'Sonia Hashim', 'Jennifer Jacobs'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;This paper explores software’s role in visual art production by examining how artists use and develop software. We conducted interviews with professional artists who were collaborating with software developers, learning software development, and building and maintaining software. We found artists were motivated to learn software development for intellectual growth and access to technical communities. Artists valued efficient workflows through skilled manual execution and personal software development, but avoided high-level forms of software automation. Artists identified conflicts between their priorities and those of professional developers and computational art communities, which influenced how they used computational aesthetics in their work. These findings contribute to efforts in systems engineering research to integrate end-user programming and creativity support across software and physical media, suggesting opportunities for artists as collaborators. Artists’ experiences writing software can guide technical implementations of domain-specific representations, and their experiences in interdisciplinary production can aid inclusive community building around computational tools.;;;https://dl.acm.org/doi/10.1145/3411764.3445682;;;Software AND Engineering
A proposal to systematize introducing DevOps into the software development process;;;['Luciano de Aguiar Monteiro'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;The software development industry has been evolving with new development standards and service delivery models. Agile methodologies have reached their completion with DevOps, thereby increasing the quality of the software and creating greater speed in delivery. However, a gap regarding the formalization of its adoption and implementation doubts became relevant. My hypothesis is that, by systematizing the introduction of DevOps into the software development process and defining the function of the members of the DevOps team members, may well make it quicker to implement this process, thus reducing conflicts between the teams. As part of the investigation of this hypothesis, the result of the research will be applied in practical development environments i.e. in a Technology Agency of the State of the Brazilian Government and also at the Brazilian Company Neurotech in order to evaluate its effectiveness from metrics appropriate for DevOps environments.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00124;;;Software AND Engineering
QN-based Modeling and Analysis of Software Performance Antipatterns for Cyber-Physical Systems;;;['Riccardo Pinciroli', 'Connie U. Smith', 'Catia Trubiani'];;;April 2021;;;ICPE '21: Proceedings of the ACM/SPEC International Conference on Performance Engineering;;;Identifying performance problems in modern software systems is nontrivial, even more so when looking at specific application domains, such as cyber-physical systems. The heterogeneity of software and hardware components makes the process of performance evaluation more challenging, and traditional software performance engineering techniques may fail while dealing with interacting and heterogeneous components. The goal of this paper is to introduce a model-based approach to understand software performance problems in cyber-physical systems. In our previous work, we listed some common bad practices, namely software performance antipatterns, that may occur. Here we are interested in shedding light on these antipatterns by means of performance models, i.e., queuing network models, that provide evidence of how antipatterns may affect the overall system performance. Starting from the specification of three software performance antipatterns tailored for cyber-physical systems, we provide the queuing network models capturing the corresponding bad practices. The analysis of these models demonstrates their usefulness in recognizing performance problems early in the software development process. This way, performance engineers are supported in the task of detecting and fixing the performance criticalities.;;;https://dl.acm.org/doi/10.1145/3427921.3450251;;;Software AND Engineering
Effective Lightweight Software Fault Localization based on Test Suite Optimization;;;['Amol Saxena', 'Roheet Bhatnagar', 'Devesh Kumar Srivastava'];;;February 2022;;;ISEC 2022: 15th Innovations in Software Engineering Conference;;;Automated software fault localization techniques aid developers in program debugging by identifying the probable locations of faults in a program with minimum human intervention. As software is growing in complexity and scale today, increasing the efficiency of fault localization techniques is very essential in order to reduce the overall software development cost. The effectiveness of the test suites used in the fault localization process has a significant impact on the efficiency of the process. Previous studies, on the other hand, have placed less focus on the adequacy of test suites for the fault localization process. We apply optimized test suites in this paper to improve the performance of software fault localization in a single-fault scenario. For our experiments, we use spectrum-based fault localization (SBFL) techniques. Because of its minimal computing overhead and scalability, spectrum-based fault localization is a popular, efficient, and yet lightweight fault localization technique. To optimize the test suite, we employ a heuristic that asserts that if a faulty statement is executed by a passing test case, that test case will have a negative impact on fault localization performance. In contrast, if a passing test case does not execute the faulty statement, the faulty statement's suspiciousness increases, which has a positive impact on fault localization performance. The test suite optimization approach used in this paper significantly improves fault localization performance, as demonstrated by our experiments. The results show that the proposed method efficiently reduces the number of statements examined by about 84.94 percent on average.;;;https://dl.acm.org/doi/10.1145/3511430.3511437;;;Software AND Engineering
Combining Learning and Engagement Strategies in a Software Testing Learning Environment;;;['Peter J. Clarke', 'Debra L. Davis', 'Ingrid A. Buckley', 'Geoff Potvin', 'Mandayam Thirunarayanan', 'Edward L. Jones'];;;None;;;ACM Transactions on Computing Education;;;There continues to be an increase in enrollments in various computing programs at academic institutions due to many job opportunities available in the information, communication, and technology sectors. This enrollment surge has presented several challenges in many Computer Science (CS), Information Technology (IT), and Software Engineering (SE) programs at universities and colleges. One such challenge is that many instructors in CS/IT/SE programs continue to use learning approaches that are not learner centered and therefore are not adequately preparing students to be proficient in the ever-changing computing industry. To mitigate this challenge, instructors need to use evidence-based pedagogical approaches, e.g., active learning, to improve student learning and engagement in the classroom and equip students with the skills necessary to be lifelong learners.This article presents an approach that combines learning and engagement strategies (LESs) in learning environments using different teaching modalities to improve student learning and engagement. We describe how LESs are integrated into face-to-face (F2F) and online class activities. The LESs currently used are collaborative learning, gamification, problem-based learning, and social interaction. We describe an approach used to quantify each LES used during class activities based on a set of characteristics for LESs and the traditional lecture-style pedagogical approaches. To demonstrate the impact of using LESs in F2F class activities, we report on a study conducted over seven semesters in a software testing class at a large urban minority serving institution. The study uses a posttest-only study design, the scores of two midterm exams, and approximate class times dedicated to each LES and traditional lecture style to quantify their usage in a face-to-face software testing class. The study results showed that increasing the time dedicated to collaborative learning, gamification, and social interaction and decreasing the traditional lecture-style approach resulted in a statistically significant improvement in student learning, as reflected in the exam scores.;;;https://dl.acm.org/doi/10.1145/3469131;;;Software AND Engineering
Heterogeneous ensemble imputation for software development effort estimation;;;['Ibtissam Abnane', 'Ali Idri', 'Mohamed Hosni', 'Alain Abran'];;;August 2021;;;PROMISE 2021: Proceedings of the 17th International Conference on Predictive Models and Data Analytics in Software Engineering;;;Choosing the appropriate Missing Data (MD) imputation technique for a given Software development effort estimation (SDEE) technique is not a trivial task. In fact, the impact of the MD imputation on the estimation output depends on the dataset and the SDEE technique used and there is no best imputation technique in all contexts. Thus, an attractive solution is to use more than one single imputation technique and combine their results for a final imputation outcome. This concept is called ensemble imputation and can help to significantly improve the estimation accuracy. This paper develops and evaluates a heterogeneous ensemble imputation whose members were the four single imputation techniques: K-Nearest Neighbors (KNN), Expectation Maximization (EM), Support Vector Regression (SVR), and Decision Trees (DT). The impact of the ensemble imputation was evaluated and compared with those of the four single imputation techniques on the accuracy measured in terms of the standardized accuracy criterion of four SDEE techniques: Case Based Reasoning (CBR), Multi-Layers Perceptron (MLP), Support Vector Regression (SVR) and Reduced Error Pruning Tree (REPTree). The Wilcoxon statistical test was also performed in order to assess whether the results are significant. All the empirical evaluations were carried out over the six datasets, namely, ISBSG, China, COCOMO81, Desharnais, Kemerer, and Miyazaki. Results show that the use of heterogeneous ensemble-based imputation instead single imputation significantly improved the accuracy of the four SDEE techniques. Indeed, the ensemble imputation technique was ranked either first or second in all contexts.;;;https://dl.acm.org/doi/10.1145/3475960.3475984;;;Software AND Engineering
Dataflow Model–based Software Synthesis Framework for Parallel and Distributed Embedded Systems;;;['Eunjin Jeong', 'Dowhan Jeong', 'Soonhoi Ha'];;;None;;;ACM Transactions on Design Automation of Electronic Systems;;;Existing software development methodologies mostly assume that an application runs on a single device without concern about the non-functional requirements of an embedded system such as latency and resource consumption. Besides, embedded software is usually developed after the hardware platform is determined, since a non-negligible portion of the code depends on the hardware platform. In this article, we present a novel model-based software synthesis framework for parallel and distributed embedded systems. An application is specified as a set of tasks with the given rules for execution and communication. Having such rules enables us to perform static analysis to check some software errors at compile-time to reduce the verification difficulty. Platform-specific programs are synthesized automatically after the mapping of tasks onto processing elements is determined. The proposed framework is expandable to support new hardware platforms easily. The proposed communication code synthesis method is extensible and flexible to support various communication methods between devices. In addition, the fault-tolerant feature can be added by modifying the task graph automatically according to the selected fault-tolerance configurations by the user. The viability of the proposed software development methodology is evaluated with a real-life surveillance application that runs on six processing elements.;;;https://dl.acm.org/doi/10.1145/3447680;;;Software AND Engineering
Exploring the efficiency of self-organizing software teams with game theory;;;['Clay Stevens', 'Jared Soundy', 'Hau Chan'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Over the last two decades, software development has moved away from centralized, plan-based management toward agile methodologies such as Scrum. Agile methodologies are founded on a shared set of core principles, including self-organizing software development teams. Such teams are promoted as a way to increase both developer productivity and team morale, which is echoed by academic research. However, recent works on agile neglect to consider strategic behavior among developers, particularly during task assignment-one of the primary functions of a self-organizing team. This paper argues that self-organizing software teams could be readily modeled using game theory, providing insight into how agile developers may act when behaving strategically. We support our argument by presenting a general model for self-assignment of development tasks based on and extending concepts drawn from established game theory research. We further introduce the software engineering community to two metrics drawn from game theory---the price-of-stability and price-of-anarchy---which can be used to gauge the efficiencies of self-organizing teams compared to centralized management. We demonstrate how these metrics can be used in a case study evaluating the hypothesis that smaller teams self-organize more efficiently than larger teams, with conditional support for that hypothesis. Our game-theoretic framework provides new perspective for the software engineering community, opening many avenues for future research.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00016;;;Software AND Engineering
Bias in machine learning software: why? how? what to do?;;;['Joymallya Chakraborty', 'Suvodeep Majumder', 'Tim Menzies'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Increasingly, software is making autonomous decisions in case of criminal sentencing, approving credit cards, hiring employees, and so on. Some of these decisions show bias and adversely affect certain social groups (e.g. those defined by sex, race, age, marital status). Many prior works on bias mitigation take the following form: change the data or learners in multiple ways, then see if any of that improves fairness. Perhaps a better approach is to postulate root causes of bias and then applying some resolution strategy. This paper postulates that the root causes of bias are the prior decisions that affect- (a) what data was selected and (b) the labels assigned to those examples. Our Fair-SMOTE algorithm removes biased labels; and rebalances internal distributions such that based on sensitive attribute, examples are equal in both positive and negative classes. On testing, it was seen that this method was just as effective at reducing bias as prior approaches. Further, models generated via Fair-SMOTE achieve higher performance (measured in terms of recall and F1) than other state-of-the-art fairness improvement algorithms. To the best of our knowledge, measured in terms of number of analyzed learners and datasets, this study is one of the largest studies on bias mitigation yet presented in the literature.;;;https://dl.acm.org/doi/10.1145/3468264.3468537;;;Software AND Engineering
Optimizing the Performance of Containerized Cloud Software Systems Using Adaptive PID Controllers;;;['Mikael Sabuhi', 'Nima Mahmoudi', 'Hamzeh Khazaei'];;;None;;;ACM Transactions on Autonomous and Adaptive Systems;;;Control theory has proven to be a practical approach for the design and implementation of controllers, which does not inherit the problems of non-control theoretic controllers due to its strong mathematical background. State-of-the-art auto-scaling controllers suffer from one or more of the following limitations: (1) lack of a reliable performance model, (2) using a performance model with low scalability, tractability, or fidelity, (3) being application- or architecture-specific leading to low extendability, and (4) no guarantee on their efficiency. Consequently, in this article, we strive to mitigate these problems by leveraging an adaptive controller, which is composed of a neural network as the performance model and a Proportional-Integral-Derivative (PID) controller as the scaling engine. More specifically, we design, implement, and analyze different flavours of these adaptive and non-adaptive controllers, and we compare and contrast them against each other to find the most suitable one for managing containerized cloud software systems at runtime. The controller’s objective is to maintain the response time of the controlled software system in a pre-defined range, and meeting the Service-level Agreements, while leading to efficient resource provisioning.;;;https://dl.acm.org/doi/10.1145/3465630;;;Software AND Engineering
EmSBoTScript: A Tiny Virtual Machine-Based Embedded Software Framework;;;['Long Peng', 'Hao Xu', 'Jie Yu', 'Xiaodong Liu', 'Fei Guan'];;;December 2021;;;CSAI '21: Proceedings of the 2021 5th International Conference on Computer Science and Artificial Intelligence;;;Modern swarm and modular robotic systems can be composed of diverse and miniature hardware components. To deal with heterogeneity, researchers adopt a virtual machine (VM)-based approach to ease software programming and updating for robotic systems. However, current VM-based solutions neither consider resource-constrained devices, nor have limited capabilities. This paper introduces EmSBoTScript, a tiny VM-based robotic software framework that is tailored for heterogeneous and miniature platforms. We endow EmSBoTScript with features of CPU independence, low memory footprint, concurrency and synchronization. We elaborate its programming model, script language and VM architecture to show its novelty in this paper. Implementation details and benchmark results are also provided.;;;https://dl.acm.org/doi/10.1145/3507548.3507592;;;Software AND Engineering
A Survey of Software Log Instrumentation;;;['Boyuan Chen', 'Zhen Ming (Jack) Jiang'];;;None;;;ACM Computing Surveys;;;Log messages have been used widely in many software systems for a variety of purposes during software development and field operation. There are two phases in software logging: log instrumentation and log management. Log instrumentation refers to the practice that developers insert logging code into source code to record runtime information. Log management refers to the practice that operators collect the generated log messages and conduct data analysis techniques to provide valuable insights of runtime behavior. There are many open source and commercial log management tools available. However, their effectiveness highly depends on the quality of the instrumented logging code, as log messages generated by high-quality logging code can greatly ease the process of various log analysis tasks (e.g., monitoring, failure diagnosis, and auditing). Hence, in this article, we conducted a systematic survey on state-of-the-art research on log instrumentation by studying 69 papers between 1997 and 2019. In particular, we have focused on the challenges and proposed solutions used in the three steps of log instrumentation: (1) logging approach; (2) logging utility integration; and (3) logging code composition. This survey will be useful to DevOps practitioners and researchers who are interested in software logging.;;;https://dl.acm.org/doi/10.1145/3448976;;;Software AND Engineering
Bridging the gap between clone-and-own and software product lines;;;['Timo Kehrer', 'Thomas Thüm', 'Alexander Schultheiß', 'Paul Maximilian Bittner'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Software is often released in multiple variants to meet all customer requirements. While software product lines address this need by advocating the development of an integrated software platform, practitioners frequently rely on ad-hoc reuse based on a principle which is known as clone-and-own. This practice avoids high up-front investments, as new variants of a software family are created by simply copying and adapting an existing variant, but maintenance costs explode once a critical number of variants is reached. With our research project VariantSync, we aim to bridge the gap between clone-and-own and product lines by combining the minimal overhead and flexibility of clone-and-own with the systematic handling of variability in software product lines. The key idea is to transparently integrate product-line concepts with variant management facilities known from version control systems in order to automatically synchronize a set of evolving variants. We believe that VariantSync has the potential to change the way how practitioners develop multi-variant software systems for which it is hard to foresee which variants will be added in the future.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00013;;;Software AND Engineering
Software Acceleration of the Deformable Shape Tracking Application: How to eliminate the Eigen Library Overhead;;;['Nikos Petrellis', 'Stavros Zogas', 'Panagiotis Christakos', 'Panagiotis Mousouliotis', 'Georgios Keramidas', 'Nikolaos Voros', 'Christos Antonopoulos'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;Shape tracking is based on landmark detection and alignment. Open-source code and pre-trained models are available for an implementation that is based on an ensemble of regression trees. The C++ Deformable Shape Tracking (DEST) implementation of face alignment that is using Eigen template library for algebraic operations is employed in this work. The overhead of the C++ Eigen library calls is measured and selected computational intensive operations are ported from Eigen implementation to custom C code achieving a remarkable acceleration in the shape tracking application. An important achievement of this work is the fact that the restructured code can be directly implemented with reconfigurable hardware for further speed improvement. Driver drowsiness and distraction detection applications are exploiting shape tracking by measuring landmark distances in order to detect eye blinking, yawning, etc. Fast video processing and accuracy is mandatory in these safety critical applications. The modified software implementation of the original DEST face alignment method presented in this paper, is almost 250 times faster due to the custom implementation of computational intensive vector/matrix operations and rotations. Eigen library is still used in non-time critical parts of the code for compact description and higher readability. Flattening of nested routines and inline implementation is also used to eliminate excessive argument copies and data type checking and conversions.;;;https://dl.acm.org/doi/10.1145/3501774.3501782;;;Software AND Engineering
MICOSE4aPS: Industrially Applicable Maturity Metric to Improve Systematic Reuse of Control Software;;;['Birgit Vogel-Heuser', 'Eva-Maria Neumann', 'Juliane Fischer'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;automated Production Systems (aPS) are highly complex, mechatronic systems that usually have to operate reliably for many decades. Standardization and reuse of control software modules is a core prerequisite to achieve the required system quality in increasingly shorter development cycles. However, industrial case studies in aPS show that many aPS companies still struggle with strategically reusing software. This paper proposes a metric-based approach to objectively measure the maturity of industrial IEC 61131-based control software in aPS (MICOSE4aPS) to identify potential weaknesses and quality issues hampering systematic reuse. Module developers in the machine and plant manufacturing industry can directly benefit as the metric calculation is integrated into the software engineering workflow. An in-depth industrial evaluation in a top-ranked machine manufacturing company in food packaging and an expert evaluation with different companies confirmed the benefit of efficiently managing the quality of control software.;;;https://dl.acm.org/doi/10.1145/3467896;;;Software AND Engineering
Bringing Green Software to Computer Science Curriculum: Perspectives from Researchers and Educators;;;['João Saraiva', 'Ziliang Zong', 'Rui Pereira'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;Only recently has the software engineering community started conducting research on developing energy efficient software, or green software. This is shadowed when compared to the research already produced in the computer hardware community. While research in green software is rapidly increasing, several recent studies with software engineers show that they still miss techniques, knowledge, and tools to develop greener software. Indeed, all such studies suggest that green software should be part of a modern Computer Science Curriculum. In this paper, we present survey results from both researchers' and educators' perspective on green software education. These surveys confirm the lack of courses and educational material for teaching green software in current higher education. Additionally, we highlight three key pedagogical challenges in bringing green software to computer science curriculum and discussed existing solutions to address these key challenges. We firmly believe that 'green thinking" and the broad adoption of green software in computer science curriculum can greatly benefit our environment, society, and students in an era where software is everywhere and evolves in an unprecedented speed.;;;https://dl.acm.org/doi/10.1145/3430665.3456386;;;Software AND Engineering
Extracting Rationale for Open Source Software Development Decisions: A Study of Python Email Archives;;;['Pankajeshwara Nand Sharma', 'Bastin Tony Roy Savarimuthu', 'Nigel Stanger'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;A sound Decision-Making (DM) process is key to the successful governance of software projects. In many Open Source Software Development (OSSD) communities, DM processes lie buried amongst vast amounts of publicly available data. Hidden within this data lie the rationale for decisions that led to the evolution and maintenance of software products. While there have been some efforts to extract DM processes from publicly available data, the rationale behind 'how' the decisions are made have seldom been explored. Extracting the rationale for these decisions can facilitate transparency (by making them known), and also promote accountability on the part of decision-makers. This work bridges this gap by means of a large-scale study that unearths the rationale behind decisions from Python development email archives comprising about 1.5 million emails. This paper makes two main contributions. First, it makes a knowledge contribution by unearthing and presenting the rationale behind decisions made. Second, it makes a methodological contribution by presenting a heuristics-based rationale extraction system called Rationale Miner that employs multiple heuristics, and follows a data-driven, bottom-up approach to infer the rationale behind specific decisions (e.g., whether a new module is implemented based on core developer consensus or benevolent dictator's pronouncement). Our approach can be applied to extract rationale in other OSSD communities that have similar governance structures.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00095;;;Software AND Engineering
Transfer learning for multiobjective optimization algorithms supporting dynamic software product lines;;;['Joaquín Ballesteros', 'Lidia Fuentes'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume B;;;Dynamic Software Product Lines (DSPLs) are a well-accepted approach for self-adapting Cyber-Physical Systems (CPSs) at run-time. The DSPL approaches make decisions supported by performance models, which capture system features' contribution to one or more optimization goals. Combining performance models with Multi-Objectives Evolutionary Algorithms (MOEAs) as decision-making mechanisms is common in DSPLs. However, MOEAs algorithms start solving the optimization problem from a randomly selected population, not finding good configurations fast enough after a context change, requiring too many resources so scarce in CPSs. Also, the DSPL engineer must deal with the hardware and software particularities of the target platform in each CPS deployment. And although each system instantiation has to solve a similar optimization problem of the DSPL, it does not take advantage of experiences gained in similar CPS. Transfer learning aims at improving the efficiency of systems by sharing the previously acquired knowledge and applying it to similar systems. In this work, we analyze the benefits of transfer learning in the context of DSPL and MOEAs testing on 8 feature models with synthetic performance models. Results are good enough, showing that transfer learning solutions dominate up to 71% of the non-transfer learning ones for similar DSPL.;;;https://dl.acm.org/doi/10.1145/3461002.3473944;;;Software AND Engineering
Replication package for representation of developer expertise in open source software;;;['Tapajit Dey', 'Andrey Karnauch', 'Audris Mockus'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This describes the artifact associated with the article "Representation of Developer Expertise in Open Source Software" at the International Conference on Software Engineering 2021. The aim of the original paper was to define a feasible representation of a developer's expertise in specific focus areas of software development by gauging their fluency with different sets of APIs. The artifact is made available through Zenodo under the CC-BY-4.0 license at https://doi.org/10.5281/zenodo.4457107. The README file has detailed instructions on how to replicate the results presented in the original paper. The artifact includes the input dataset (with the developers' names and email addresses replaced by their corresponding SHA1 digest values to protect privacy) and all the associated scripts. The trained Doc2Vec models are also included in the artifact. These models can be used to obtain the Skill Space representations of developers, projects, and APIs without having to re-train the model.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00109;;;Software AND Engineering
A Mining Software Repository Extended Cookbook: Lessons learned from a literature review;;;['Daniel Barros', 'Flavio Horita', 'Igor Wiese', 'Kanan Silva'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The main purpose of Mining Software Repositories (MSR) is to discover the latest enhancements and provide an insight into how to make improvements in a software project. In light of it, this paper updates the MSR findings of the original MSR Cookbook, by first conducting a systematic mapping study to elicit and analyze the state-of-the-art, and then proposing an extended version of the Cookbook. This extended Cookbook was built on four high-level themes, which were derived from the analysis of a list of 112 selected studies. Hence, it was used to consolidate the extended Cookbook as a contribution to practice and research in the following areas by: 1) including studies published in all available and relevant publication venues; 2) including and updating recommendations in all four high-level themes, with an increase of 84% in comments in this study when compared with the original MSR Cookbook; 3) summarizing the tools employed for each high-level theme; and 4) providing lessons learned for future studies. Thus, the extended Cookbook examined in this work can support new research projects, as upgraded recommendations and the lessons learned are available with the aid of samples and tools.;;;https://dl.acm.org/doi/10.1145/3474624.3474627;;;Software AND Engineering
Mining Dependencies in Large-Scale Agile Software Development Projects: A Quantitative Industry Study;;;['Katarzyna Biesialska', 'Xavier Franch', 'Victor Muntés-Mulero'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Context: Coordination in large-scale software development is critical yet difficult, as it faces the problem of dependency management and resolution. In this work, we focus on managing requirement dependencies that in Agile software development (ASD) come in the form of user stories. Objective: This work studies decisions of large-scale Agile teams regarding identification of dependencies between user stories. Our goal is to explain detection of dependencies through users’ behavior in large-scale, distributed projects. Method: We perform empirical evaluation on a large real-world dataset from an Agile software organization, provider of a leading software for Agile project management. We mine the usage data of the Agile Lifecycle Management (ALM) tool to extract large-scale development project data for more than 70 teams running over a five-year period. Results: Our results demonstrate that dependencies among user stories are not frequently observed (the problem affects around 10% of user stories), however, their implications on large-scale ASD are considerable. Dependencies have impact on software releases and increase work coordination complexity for members of different teams. Conclusion: Requirement dependencies undermine Agile teams’ autonomy and are difficult to manage at scale. We conclude that leveraging ALM monitoring data to automatically detect dependencies could help Agile teams address work coordination needs and manage risks related to dependencies in a timely manner.;;;https://dl.acm.org/doi/10.1145/3463274.3463323;;;Software AND Engineering
On the requirements engineer role;;;['Xavier Franch', 'Cristina Palomares', 'Tony Gorschek'];;;June 2021;;;Communications of the ACM;;;The requirements engineer role is defined differently within most organizations.;;;https://dl.acm.org/doi/10.1145/3418292;;;Software AND Engineering
Software Quality Practices in Growing Startups: A Qualitative Study;;;['Adriano Pizzini', 'Ricardo Bortolo Vieira', 'Rhodrigo Deda Gomes', 'Gleison Santos', 'Andreia Malucelli', 'Sheila Reinehr'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Startups arise in environments of extreme uncertainty, with few resources and the need to scale quickly. In the growth phase, they still need agility, but they tend to concern more with software quality and the development process by having more human and financial resources. Studying the factors that lead startups in the growth phase to seek quality in their processes can help new startups anticipate implementing quality practices. In this paper, we aim to identify how startups adopt quality practices in the growth phase. We carried out a multiple case study with four growth phase startups. We applied qualitative analysis techniques to summarize the findings. The studied startups adopt limited quality practices and are influenced by the development team's maturity level, organizational culture, and experience. Furthermore, they tend to be reactive towards quality, solving the problems when they impact their product, business, customer, or when technical debt can no longer be managed. The findings are relevant to support stabilizing and growing startups to define actions to improve the quality of their processes and products. Besides, they suggest that growth phase startups begin a process of change in the organizational culture concerning quality, adopting the behavior of mature companies as soon as they get more human and financial resources.;;;https://dl.acm.org/doi/10.1145/3493244.3493254;;;Software AND Engineering
A grounded theory of the role of coordination in software security patch management;;;['Nesara Dissanayake', 'Mansooreh Zahedi', 'Asangi Jayatilaka', 'Muhammad Ali Babar'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Several disastrous security attacks can be attributed to delays in patching software vulnerabilities. While researchers and practitioners have paid significant attention to automate vulnerabilities identification and patch development activities of software security patch management, there has been relatively little effort dedicated to gain an in-depth understanding of the socio-technical aspects, e.g., coordination of interdependent activities of the patching process and patching decisions, that may cause delays in applying security patches. We report on a Grounded Theory study of the role of coordination in security patch management. The reported theory consists of four inter-related dimensions, i.e., causes, breakdowns, constraints, and mechanisms. The theory explains the causes that define the need for coordination among interdependent software/hardware components and multiple stakeholders’ decisions, the constraints that can negatively impact coordination, the breakdowns in coordination, and the potential corrective measures. This study provides potentially useful insights for researchers and practitioners who can carefully consider the needs of and devise suitable solutions for supporting the coordination of interdependencies involved in security patch management.;;;https://dl.acm.org/doi/10.1145/3468264.3468595;;;Software AND Engineering
Understanding Software-2.0: A Study of Machine Learning Library Usage and Evolution;;;['Malinda Dilhara', 'Ameya Ketkar', 'Danny Dig'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Enabled by a rich ecosystem of Machine Learning (ML) libraries, programming using learned models, i.e., Software-2.0, has gained substantial adoption. However, we do not know what challenges developers encounter when they use ML libraries. With this knowledge gap, researchers miss opportunities to contribute to new research directions, tool builders do not invest resources where automation is most needed, library designers cannot make informed decisions when releasing ML library versions, and developers fail to use common practices when using ML libraries.We present the first large-scale quantitative and qualitative empirical study to shed light on how developers in Software-2.0 use ML libraries, and how this evolution affects their code. Particularly, using static analysis we perform a longitudinal study of 3,340 top-rated open-source projects with 46,110 contributors. To further understand the challenges of ML library evolution, we survey 109 developers who introduce and evolve ML libraries. Using this rich dataset we reveal several novel findings.Among others, we found an increasing trend of using ML libraries: The ratio of new Python projects that use ML libraries increased from 2% in 2013 to 50% in 2018. We identify several usage patterns including the following: (i) 36% of the projects use multiple ML libraries to implement various stages of the ML workflows, (ii) developers update ML libraries more often than the traditional libraries, (iii) strict upgrades are the most popular for ML libraries among other update kinds, (iv) ML library updates often result in cascading library updates, and (v) ML libraries are often downgraded (22.04% of cases). We also observed unique challenges when evolving and maintaining Software-2.0 such as (i) binary incompatibility of trained ML models and (ii) benchmarking ML models. Finally, we present actionable implications of our findings for researchers, tool builders, developers, educators, library vendors, and hardware vendors.;;;https://dl.acm.org/doi/10.1145/3453478;;;Software AND Engineering
Study of the Utility of Text Classification Based Software Architecture Recovery Method RELAX for Maintenance;;;['Daniel Link', 'Kamonphop Srisopha', 'Barry Boehm'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background. The software architecture recovery method RELAX produces a concern-based architectural view of a software system graphically and textually from that system's source code. The method has been implemented in software which can recover the architecture of systems whose source code is written in Java. Aims. Our aim was to find out whether the availability of architectural views produced by RELAX can help maintainers who are new to a project in becoming productive with development tasks sooner, and how they felt about working in such an environment. Method. We conducted a user study with nine participants. They were subjected to a controlled experiment in which maintenance success and speed with and without access to RELAX recovery results were compared to each other. Results. We have observed that employing architecture views produced by RELAX helped participants reduce time to get started on maintenance tasks by a factor of 5.38 or more. While most participants were unable to finish their tasks within the allotted time when they did not have recovery results available, all of them finished them successfully when they did. Additionally, participants reported that these views were easy to understand, helped them to learn the system's structure and enabled them to compare different versions of the system. Conclusions. Through the speedup to the start of maintenance experienced by the participants as well as in their formed opinions, RELAX has shown itself to be a valuable help that could provide the basis of further tools that specifically support the development process with a focus on maintenance.;;;https://dl.acm.org/doi/10.1145/3475716.3484194;;;Software AND Engineering
Verification Strategies for Feature-Oriented Software Product Lines;;;['Elias Kuiter', 'Alexander Knüppel', 'Tabea Bordis', 'Tobias Runge', 'Ina Schaefer'];;;February 2022;;;VaMoS '22: Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;;;Highly-customizable software systems in form of software product lines are becoming increasingly relevant for safety-critical systems, in which the correctness of software is a major concern. To ensure the correct behavior of a software product line, each product can be verified in isolation—however, this strategy quickly becomes infeasible for a large number of products.  In this paper, we propose proof plans, a novel strategy for verifying feature-oriented software product lines based on partial proofs. Our technique splits the verification task into small proofs that can be reused across method variants, which gives rise to a wider spectrum of verification strategies for software product lines. We describe applications of our technique and evaluate one of them on a case study by comparing it with established verification strategies.;;;https://dl.acm.org/doi/10.1145/3510466.3511272;;;Software AND Engineering
Software safety test case design method based on Fuzzy Fault Tree Analysis;;;['Shiran Cai', 'Wei Zhang'];;;November 2021;;;ICSED '21: Proceedings of the 2021 3rd International Conference on Software Engineering and Development;;;Aiming at the problems of insufficient software safety testing and incomplete aerospace data, combined with fuzzy set theory, a design methodology for safety test cases of aerospace software is proposed. A fuzzy fault tree of aerospace software is established on the basis of fault tree analysis technology and expert investigation method, the trapezoidal fuzzy numbers are used to replace the failure probabilities of the bottom events, and then obtain the minimum cut sets through the qualitative analysis of the fault tree, the minimum safety test cases is designed according to the minimum cut sets. Finally, different test cases are prioritized by the cut set importance results calculated by the quantitative analysis of the fuzzy fault tree. According to the experimental results, the proposed method provides a reference for improving the safety of the aerospace system while reducing the number of test cases and ensuring the sufficiency and efficiency of the software safety test cases.;;;https://dl.acm.org/doi/10.1145/3507473.3507474;;;Software AND Engineering
EvoMe: a software evolution management engine based on differential factbase;;;['Xiuheng Wu', 'Mengyang Li', 'Yi Li'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Managing large and fast-evolving software systems can be a challenging task. Numerous solutions have been developed to assist in this process, enhancing software quality and reducing development costs. These techniques---e.g., regression test selection and change impact analysis---are often built as standalone tools, unable to share or reuse information among them. In this paper, we introduce a software evolution management engine, EvoMe, to streamline and simplify the development of such tools, allowing them to be easily prototyped using an intuitive query language and quickly deployed for different types of projects. EvoMe is based on differential factbase, a uniform exchangeable representation of evolving software artifacts, and can be accessed directly through a Web interface. We demonstrate the usage and key features of EvoMe on real open-source software projects. The demonstration video can be found at: http://youtu.be/6mMgu6rfnjY.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678795;;;Software AND Engineering
A comparative study of vulnerability reporting by software composition analysis tools;;;['Nasif Imtiaz', 'Seaver Thorn', 'Laurie Williams'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Modern software uses many third-party libraries and frameworks as dependencies. Known vulnerabilities in these dependencies are a potential security risk. Software composition analysis (SCA) tools, therefore, are being increasingly adopted by practitioners to keep track of vulnerable dependencies. Aim: The goal of this study is to understand the difference in vulnerability reporting by various SCA tools. Understanding if and how existing SCA tools differ in their analysis may help security practitioners to choose the right tooling and identify future research needs. Method: We present an in-depth case study by comparing the analysis reports of 9 industry-leading SCA tools on a large web application, OpenMRS, composed of Maven (Java) and npm (JavaScript) projects. Results: We find that the tools vary in their vulnerability reporting. The count of reported vulnerable dependencies ranges from 17 to 332 for Maven and from 32 to 239 for npm projects across the studied tools. Similarly, the count of unique known vulnerabilities reported by the tools ranges from 36 to 313 for Maven and from 45 to 234 for npm projects. Our manual analysis of the tools' results suggest that accuracy of the vulnerability database is a key differentiator for SCA tools. Conclusion: We recommend that practitioners should not rely on any single tool at the present, as that can result in missing known vulnerabilities. We point out two research directions in the SCA space: i) establishing frameworks and metrics to identify false positives for dependency vulnerabilities; and ii) building automation technologies for continuous monitoring of vulnerability data from open source package ecosystems.;;;https://dl.acm.org/doi/10.1145/3475716.3475769;;;Software AND Engineering
On reducing the energy consumption of software product lines;;;['Édouard Guégain', 'Clément Quinton', 'Romain Rouvoy'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;Along the last decade, several studies considered green software design as a key development concern to improve the energy efficiency of software. Yet, few techniques address this concern for Software Product Lines (SPL). In this paper, we therefore introduce two approaches to measure and reduce the energy consumption of a SPL by analyzing a limited set of products sampled from this SPL. While the first approach relies on the analysis of individual feature consumptions, the second one takes feature interactions into account to better mitigate energy consumption of resulting products. Our experimental results on a real-world SPL indicate that both approaches succeed to produce significant energy improvements on a large number of products, while consumption data was modeled from a small set of sampled products. Furthermore, we show that taking feature interactions into account leads to more products improved with higher energy savings per product.;;;https://dl.acm.org/doi/10.1145/3461001.3471142;;;Software AND Engineering
The Covid 19 Pandemic and its Effects on Agile Software Development;;;['Michael Neumann', 'Yevgen Bogdanov', 'Senol Sager'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;Companies worldwide have enabled their employees to work remotely as a consequence of the Covid 19 pandemic. Software development is a human-centered discipline and thrives on teamwork. Agile methods are focusing on several social aspects of software development. Software development teams in Germany were mainly co-located before the pandemic. This paper aims to validate the findings of existing studies by expanding on an existing multiple-case study. Therefore, we collected data by conducting semi-structured interviews, observing agile practices, and viewing project documents in three cases. Based on the results, we can confirm the following findings: 1) The teams rapidly adapted the agile practices and roles, 2) communication is more objective within the teams, 3) decreased social exchange between team members, 4) the expectation of a combined approach of remote and onsite work after the pandemic, 5) stable or increased (perceived) performance and 6) stable or increased well-being of team members.;;;https://dl.acm.org/doi/10.1145/3520084.3520093;;;Software AND Engineering
Software Quality Assessment of a Web Application for Biomedical Data Analysis;;;['Lena Wiese', 'Ingmar Wiese', 'Kristina Lietz'];;;July 2021;;;IDEAS '21: Proceedings of the 25th International Database Engineering &amp; Applications Symposium;;;Data Science as a multidisciplinary discipline has seen a massive transformation in the direction of operationalisation of analysis workflows. Yet it can be observed that such a workflow consists of potentially many diverse components: like modules in different programming languages, database backends, or web frontends. In order to achieve high efficiency and reproducibility of the analysis, a sufficiently high level of software engineering for the different components as well as an overall software architecture that integrates and automates the different components is needed. For the use case of gene expression analysis, from a software quality point of view we analyze a newly developed web application that allows user-friendly access to the underlying workflow.;;;https://dl.acm.org/doi/10.1145/3472163.3472172;;;Software AND Engineering
The software heritage filesystem (SwhFS): integrating source code archival with development;;;['Thibault Allançon', 'Antoine Pietri', 'Stefano Zacchiroli'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;We introduce the Software Heritage filesystem (SwhFS), a user-space filesystem that integrates large-scale open source software archival with development workflows. SwhFS provides a POSIX filesystem view of Software Heritage, the largest public archive of software source code and version control system (VCS) development history. Using SwhFS, developers can quickly "checkout" any of the 2 billion commits archived by Software Heritage, even after they disappear from their previous known location and without incurring the performance cost of repository cloning. SwhFS works across unrelated repositories and different VCS technologies. Other source code artifacts archived by Software Heritage---individual source code files and trees, releases, and branches---can also be accessed using common programming tools and custom scripts, as if they were locally available. A screencast of SwhFS is available online at dx.doi.org/10.5281/zenodo.4531411.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00032;;;Software AND Engineering
WNOS: Enabling Principled Software-Defined Wireless Networking;;;['Zhangyu Guan', 'Lorenzo Bertizzolo', 'Emrecan Demirors', 'Tommaso Melodia'];;;None;;;IEEE/ACM Transactions on Networking;;;This article investigates the basic design principles for a new <italic>Wireless Network Operating System (WNOS), a radically different approach to software-defined</italic> networking (SDN) for <italic>infrastructure-less</italic> wireless networks. Departing from well-understood approaches inspired by OpenFlow, WNOS provides the network designer with an abstraction hiding (i) the lower-level details of the wireless protocol stack and (ii) the distributed nature of the network operations. Based on this abstract representation, the WNOS takes network control programs written on a centralized, high-level view of the network and automatically generates distributed cross-layer control programs based on distributed optimization theory that are executed by each individual node on an abstract representation of the radio hardware. We first discuss the main architectural principles of WNOS. Then, we discuss a new approach to automatically generate solution algorithms for each of the resulting subproblems in an automated fashion. Finally, we illustrate a prototype implementation of WNOS on software-defined radio devices and test its effectiveness by considering specific cross-layer control problems. Experimental results indicate that, based on the automatically generated distributed control programs, WNOS achieves 18&#x0025;, 56&#x0025; and 80.4&#x0025; utility gain in networks with low, medium and high levels of interference; maybe more importantly, we illustrate how the global network behavior can be controlled by modifying a few lines of code on a centralized abstraction.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3064824;;;Software AND Engineering
Design of Secure Connectors for Complex Message Communications in Software Architecture;;;['Michael Shin', 'Taeghyun Kang', 'Hassan Gomaa'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;This paper describes the design of secure connectors that deal with various message communications between application components in secure distributed component-based software architectures. The secure connectors are designed with more than one communication pattern between application components, security patterns required by the components, and security coordinators integrating security patterns and communication patterns. This paper describes the pseudocode of security coordinators. The secure connectors make application components free from maintaining complex message communication sequence logic and security concerns. To validate our design, we applied secure connectors to the model-view-controller (MVC) architecture for a secure distributed baseball game application.;;;https://dl.acm.org/doi/10.1145/3501774.3501778;;;Software AND Engineering
Structuring a comprehensive software security course around the OWASP application security verification standard;;;['Sarah E. Elder', 'Nusrat Zahan', 'Val Kozarev', 'Rui Shu', 'Tim Menzies', 'Laurie Williams'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Lack of security expertise among software practitioners is a problem with many implications. First, there is a deficit of security professionals to meet current needs. Additionally, even practitioners who do not plan to work in security may benefit from increased understanding of security. The goal of this paper is to aid software engineering educators in designing a comprehensive software security course by sharing an experience running a software security course for the eleventh time. Through all the eleven years of running the software security course, the course objectives have been comprehensive - ranging from security testing, to secure design and coding, to security requirements to security risk management. For the first time in this eleventh year, a theme of the course assignments was to map vulnerability discovery to the security controls of the Open Web Application Security Project (OWASP) Application Security Verification Standard (ASVS). Based upon student performance on a final exploratory penetration testing project, this mapping may have increased students' depth of understanding of a wider range of security topics. The students efficiently detected 191 unique and verified vulnerabilities of 28 different Common Weakness Enumeration (CWE) types during a three-hour period in the OpenMRS project, an electronic health record application in active use.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00019;;;Software AND Engineering
Architectural strategies for interoperability of software-intensive systems: practitioners' perspective;;;['Pedro Henrique Dias Valle', 'Lina Garcés', 'Elisa Yumi Nakagawa'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Background: Currently, it is becoming increasingly common in the construction of more complex systems through the integration of existing and operational systems. To correctly construct these systems they must address interoperability requirements at different levels, i.e., technical, semantic, syntactic, and organizational. Several architectural strategies (i.e., architectural styles, patterns, and tactics) can be reused during such systems integration. However, there is a lack of evidence to orient which strategies and how they could be used during software integration practice. Objective: To investigate how architectural strategies have been used in practice to promote the interoperability of software-intensive systems. Method: We planned and executed an online survey with practitioners from different parts of the world, most of them with more than five years of experience in software integration. Results: We identified: (i) the main architectural strategies used in practice to promote different interoperability types in software-intensive systems; (ii) the difficulty level perceived by practitioners for using these strategies in real projects; (iii) the quality attributes more negatively impacted by these strategies; (iv) practitioners' suggestions to improve integration processes of software-intensive systems; (vi) common technologies used to integrate systems; (vii) and challenges perceived by practitioners during software-intensive systems integration. Conclusions: It is important to develop guidelines to assist practitioners in systematically selecting and applying the most suitable architectural strategies to their integration projects, analyzing the benefits and drawbacks of each strategy regarding other important quality attributes, such as security, reliability, and performance.;;;https://dl.acm.org/doi/10.1145/3412841.3442015;;;Software AND Engineering
The Labor of Maintaining and Scaling Free and Open-Source Software Projects;;;['R. Stuart Geiger', 'Dorothy Howard', 'Lilly Irani'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Free and/or open-source software (or F/OSS) projects now play a major and dominant role in society, constituting critical digital infrastructure relied upon by companies, academics, non-profits, activists, and more. As F/OSS has become larger and more established, we investigate the labor of maintaining and sustaining those projects at various scales. We report findings from an interview-based study with contributors and maintainers working in a wide range of F/OSS projects. Maintainers of F/OSS projects do not just maintain software code in a more traditional software engineering understanding of the term: fixing bugs, patching security vulnerabilities, and updating dependencies. F/OSS maintainers also perform complex and often-invisible interpersonal and organizational work to keep their projects operating as active communities of users and contributors. We particularly focus on how this labor of maintaining and sustaining changes as projects and their software grow and scale across many dimensions. In understanding F/OSS to be as much about maintaining a communal project as it is maintaining software code, we discuss broadly applicable considerations for peer production communities and other socio-technical systems more broadly.;;;https://dl.acm.org/doi/10.1145/3449249;;;Software AND Engineering
ARROW: restoration-aware traffic engineering;;;['Zhizhen Zhong', 'Manya Ghobadi', 'Alaa Khaddaj', 'Jonathan Leach', 'Yiting Xia', 'Ying Zhang'];;;August 2021;;;SIGCOMM '21: Proceedings of the 2021 ACM SIGCOMM 2021 Conference;;;Fiber cut events reduce the capacity of wide-area networks (WANs) by several Tbps. In this paper, we revive the lost capacity by reconfiguring the wavelengths from cut fibers into healthy fibers. We highlight two challenges that made prior solutions impractical and propose a system called Arrow to address them. First, our measurements show that contrary to common belief, in most cases, the lost capacity is only partially restorable. This poses a cross-layer challenge from the Traffic Engineering (TE) perspective that has not been considered before: “Which IP links should be restored and by how much to best match the TE objective?” To address this challenge, Arrow's restoration-aware TE system takes a set of partial restoration candidates (that we call LotteryTickets) as input and proactively finds the best restoration plan. Second, prior work has not considered the reconfiguration latency of amplifiers. However, in practical settings, amplifiers add tens of minutes of reconfiguration delay. To enable fast and practical restoration, Arrow leverages optical noise loading and bypasses amplifier reconfiguration altogether. We evaluate Arrow using large-scale simulations and a testbed. Our testbed demonstrates Arrow's end-to-end restoration latency is eight seconds. Our large-scale simulations compare Arrow to the state-of-the-art TE schemes and show it can support 2.0x--2.4x more demand without compromising 99.99% availability.;;;https://dl.acm.org/doi/10.1145/3452296.3472921;;;Software AND Engineering
Towards a corpus for credibility assessment in software practitioner blog articles;;;['Ashley Williams', 'Matthew Shardlow', 'Austen Rainer'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Background: Blogs are a source of grey literature which are widely adopted by software practitioners for disseminating opinion and experience. Analysing such articles can provide useful insights into the state–of–practice for software engineering research. However, there are challenges in identifying higher quality content from the large quantity of articles available. Credibility assessment can help in identifying quality content, though there is a lack of existing corpora. Credibility is typically measured through a series of conceptual criteria, with ’argumentation’ and ’evidence’ being two important criteria.  Objective: We create a corpus labelled for argumentation and evidence that can aid the credibility community. The corpus consists of articles from the blog of a single software practitioner and is publicly available.  Method: Three annotators label the corpus with a series of conceptual credibility criteria, reaching an agreement of 0.82 (Fleiss’ Kappa). We present preliminary analysis of the corpus by using it to investigate the identification of claim sentences (one of our ten labels).  Results: We train four systems (Bert, KNN, Decision Tree and SVM) using three feature sets (Bag of Words, Topic Modelling and InferSent), achieving an F1 score of 0.64 using InferSent and a Linear SVM.  Conclusions: Our preliminary results are promising, indicating that the corpus can help future studies in detecting the credibility of grey literature. Future research will investigate the degree to which the sentence level annotations can infer the credibility of the overall document.;;;https://dl.acm.org/doi/10.1145/3463274.3463330;;;Software AND Engineering
Characterizing the Evolution of Size and Inheritance in Object-Oriented Software;;;['Bruno Luan de Sousa', 'Mariza Andrade da Silva Bigonha', 'Kecia Aline Marques Ferreira', 'Glaura da Conceição Franco'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Software evolution consists of adapting, correcting, and updating a system. It is widely known that the systems became increasingly complex and challenging to be maintained over their evolution. However, the way the systems’ internal structure evolves is not known in detail. Understanding how the internal software structure evolves is essential to help developers better plan, manage, and perform software maintenance tasks. In this work, we present an empirical analysis to investigate how the internal structure of object-oriented systems evolves from the perspective of inheritance hierarchy and size. Besides, we analyzed the set of classes within the systems that affect these dimensions’ evolution and how such classes evolve. We used a methodology based on time series, linear regression techniques, and trend tests to analyze the evolution of object-oriented systems. Using this methodology, we identified the function that better explains how the size and the inheritance tree evolve. This study revealed eight software evolution properties, among them: inheritance hierarchy tends to increase in depth and decrease in breadth; inheritance hierarchy depth and the size of classes grow according to a linear model. The empirical evidence found in this work provides a fine-grained knowledge of how object-oriented software systems’ internal structure evolves from internal dimensions.;;;https://dl.acm.org/doi/10.1145/3493244.3493247;;;Software AND Engineering
Change Propagation Path: An Approach for Detecting Co-Changes Among Software Entities;;;['Ali Ben Abdullah', 'Abdelsalam M. Maatuk', 'Osama M. Ben Omran'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;The failure in propagating software changes properly during the maintenance process is one of the main causes of defects and poor software performance. It also increases the time consumed while searching for related changes manually. In addition, incomplete changes increase the cost of the maintenance process, by hiring highly paid senior developers, to give consultations for maintaining the software systems. In this paper, we present an approach called Change Propagation Path (CPP), which is a data mining method that aims at helping developers to predict software complementary changes and perform changes correctly. The CPP approach employs the frequent pattern analysis technique to be used on historical data stored within software repositories. We have designed a web-based tool called Wide Assisting and Leading (WALead) and conducted an experimental study as a proof of concept and to validate the proposed approach. The WALead tool was designed to support developers remotely and through any platform. The tool has been tested in terms of its effects on the maintenance process, and to prove the feasibility of the CPP approach.;;;https://dl.acm.org/doi/10.1145/3492547.3492629;;;Software AND Engineering
The pareto distribution of software features and no-code;;;['Ahmed ElBatanony', 'Giancarlo Succi'];;;October 2021;;;BCNC 2021: Proceedings of the 1st ACM SIGPLAN International Workshop on Beyond Code: No Code;;;This research analyzes the top-performing software applications to identify the Pareto distribution of the features and accordingly proposes the use of no-code tools to increase the efficiency of software developers.;;;https://dl.acm.org/doi/10.1145/3486949.3486964;;;Software AND Engineering
Research on software service risk uncertainty calculation method based on information entropy;;;['Tilei Gao', 'Ming Yang', 'Xiaohui Jia', 'Tao Zhang', 'Bingfu Mou'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;Software is the soul of computer system. The risk faced by software service directly determines the trustworthiness of software system. Taking the information entropy theory as the main method, this paper proposes a software service risk uncertainty calculation method based on information entropy. By calculating the entropy weight coefficient of each risk component factor, the uncertainty of software service risk is calculated. The research findings of this paper will provide theoretical and methodological support for the comprehensive evaluation of software service risk and the measurement of software service trustworthiness.;;;https://dl.acm.org/doi/10.1145/3494885.3494894;;;Software AND Engineering
Delta-based verification of software product families;;;['Marco Scaletta', 'Reiner Hähnle', 'Dominic Steinhöfel', 'Richard Bubel'];;;October 2021;;;GPCE 2021: Proceedings of the 20th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;;;The quest for feature- and family-oriented deductive verification of software product lines resulted in several proposals. In this paper we look at delta-oriented modeling of product lines and combine two new ideas: first, we extend Hähnle & Schaefer’s delta-oriented version of Liskov’s substitution principle for behavioral subtyping to work also for overridden behavior in benign cases. For this to succeed, programs need to be in a certain normal form. The required normal form turns out to be achievable in many cases by a set of program transformations, whose correctness is ensured by the recent technique of abstract execution. This is a generalization of symbolic execution that permits reasoning about abstract code elements. It is needed, because code deltas contain partially unknown code contexts in terms of “original” calls.  Second, we devise a modular verification procedure for deltas based on abstract execution, representing deltas as abstract programs calling into unknown contexts.  The result is a “delta-based” verification approach, where each modification of a method in a code delta is verified in isolation, but which overcomes the strict limitations of behavioral subtyping and works for many practical programs. The latter claim is substantiated with case studies and benchmarks.;;;https://dl.acm.org/doi/10.1145/3486609.3487200;;;Software AND Engineering
Energy Efficient routing protocol for Internet of Vehicles based on software-defined network;;;['XinXin Du', 'XiaoHui Hu', 'JiaNan Zhao'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;With the significant application and expansion of the Vehicle Ad Hoc Network (VANET), how to ensure routing data transmission between vehicles with limited energy resources is one of the most critical challenges in this network. To solve this problem, introducing software-defined network (SDN) architecture, the SDN is applied to form VANET SDN-VANET structure. And we use the advantages of genetic algorithms to propose an energy-saving routing algorithm (EEGA), which sends data from the source to the target vehicle with minimum energy cost and provides better QoS for the communication between vehicles. Finally, the SDN-VANET environment is built on the NS3 simulator, and validates the routing algorithm. The results show that EEGA can effectively select the relay node that meets the service requirements in the routing process, reduce the average E2E delay, reduce the packet loss rate and balance the network energy.;;;https://dl.acm.org/doi/10.1145/3501409.3501525;;;Software AND Engineering
A Software Reuse Development Method Based on Base Capability Component Adaptation Model;;;['Ying Liu', 'XiaoLu Zhou', 'DanPing Li', 'ZhongZhi Wang'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;Software reuse is a good way to prove the quality and releasing cycle of software product. In this paper, we propose a software reuse development method based on base capability component adaptation (BCCA) model. The atomic capabilities are divided into three capability groups, and the atomic capabilities combine with each other to compose the needed architecture. We implemented BCCA model in our ITSM system, which proves the effectiveness of our method.;;;https://dl.acm.org/doi/10.1145/3501409.3501671;;;Software AND Engineering
Mining cross-domain apps for software evolution: a feature-based approach;;;['MD Kafil Uddin', 'Qiang He', 'Jun Han', 'Caslon Chua'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;The skyrocketing growth of mobile apps and mobile devices has significantly fueled the competition among app developers. They have leveraged the app store capabilities to analyse app data and identify app improvement opportunities. Existing research has shown that app developers mostly rely on in-domain (i.e., same domain or same app) data to improve their apps. However, relying on in-domain data results in low diversity and lacks novelty in recommended features. In this work, we present an approach that automatically identifies, classifies and ranks relevant popular features from cross-domain apps for recommendation to any given target app. It includes the following three steps: 1) identify cross-domain apps that are relevant to the target app in terms of their features; 2) filter and group semantically the features of the relevant cross-domain apps that are complementary to the target app; 3) rank and prioritize the complementary cross-domain features (in terms of their domain, app, feature and popularity characteristics) for adoption by the target app's developers. We have run extensive experiments on 100 target apps from 10 categories over 15,200 cross-domain apps from 31 categories. The experimental results have shown that our approach to identifying, grouping and ranking complementary cross-domain features for recommendation has achieved an accuracy level of over 89%. Our semantic feature grouping technique has also significantly outperformed two existing baseline techniques. The empirical evaluation validates the efficacy of our approach in providing personalised feature recommendation and enhancing app's user serendipity.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678514;;;Software AND Engineering
Overcoming Knowledge-Sharing Barriers that Affect Software Quality: An Experience Report;;;['Rayfran Rocha Lima', 'Oswald Ekwoge', 'Bruno Bonifácio', 'Raquel Cunha', 'Hualter Barbosa', 'Ana Carolina Oran Rocha'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;There are several barriers to the knowledge management process in the current technological market environment that can affect software quality, especially in a distributed environment. One of them relates to the knowledge sharing needed to fulfill required tasks to ensure the projects’ deliverables. This paper is an experience report that assesses the gaps of knowledge (GoK) in the project leaders (PL) team. To accomplish this, it was carried out documental analysis and focus group sessions to review essential activities developed by the PL team during the software development process. Afterward, we carried out a survey to verify the GoK of PL team members related to their ability to perform essential activities to develop Security Maintenance Release projects. This paper also shows analyzes of three ways to share knowledge and a training program guidelines to eliminate existing GoK in the PL team. The findings reveal that although many factors affect the success rates of the knowledge sharing process, a training plan considering the combination of four factors can shorten the learning curve of PL team members. We hope this paper can contribute helping other knowledge-based companies and scientific community to increase their competitive advantages related to the knowledge sharing process and to minimize software quality problems such as rework effort and defective product delivery.;;;https://dl.acm.org/doi/10.1145/3493244.3493266;;;Software AND Engineering
Investigating documented information for accurate effort estimation in agile software development;;;['Jirat Pasuksmit'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;An Agile development team estimates the effort of a work item to plan a sprint (i.e., an iteration in Scrum). Hence, reliable effort estimation would help the team create a reliable sprint plan. Prior studies proposed automated approaches to help the team to estimate the effort accurately. However, the effort estimated by the previously proposed approaches may become inaccurate when the related information is changed. Especially when the estimated effort is changed after the sprint has been planned, the sprint plan may be invalidated and the team might waste their time and effort spent in planning. This thesis aims to help the Agile development team improve the stability of effort estimation (in the Story Points unit) while aligning with the just-in-time practice of Agile. Hence, we first conduct empirical studies using mixed-methods approaches to investigate the potential impact of instability of Story Points. To help an Agile team to achieve reliable effort estimation with optimal effort, we will develop approaches to predict the future Story Points changes and the future information changes to help the team cope with uncertainty when finalizing the sprint plan.;;;https://dl.acm.org/doi/10.1145/3468264.3473106;;;Software AND Engineering
Using Natural Language Processing and Graph Mining to Explore Inter- Related Requirements in Software Artefacts;;;['Maninder Singh'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;Software development is prone to software faults due to the involvement of multiple stakeholders especially during the fuzzy phases (requirements and design). Software inspections are commonly used in industry to detect and fix problems in requirements and design artifacts thereby mitigating the fault propagation to later phases. The requirements documented in natural language (NL) are prone to contain faults because of different vocabularies among stakeholders. This research employs various NL processing with semantic analysis (SA) and mining solutions from graph theory to NL requirements to develop inter-related requirements (IRRs) that can help identify requirements that may need similar fixes. Additionally, our approach aims at aiding requirements' engineers with fault-prone regions both pre and post inspection. Pre-inspection, our approach using IRRs help removing redundant and extraneous faults within related requirements while post-inspection, it aids engineers analyse the impact of a change in one requirement on another related requirements. So, this research aims at developing a graph of inter-related requirements using natural language processing and semantic analysis approaches on a given requirements document that can be used to aid various decisions pre and post-inspections.;;;https://dl.acm.org/doi/10.1145/3310013.3310018;;;Software AND Engineering
Comparative study of random search hyper-parameter tuning for software effort estimation;;;['Leonardo Villalobos-Arias', 'Christian Quesada-López'];;;August 2021;;;PROMISE 2021: Proceedings of the 17th International Conference on Predictive Models and Data Analytics in Software Engineering;;;Empirical studies on software effort estimation have employed hyper-parameter tuning algorithms to improve model accuracy and stability. While these tuners can improve model performance, some might be overly complex or costly for the low dimensionality datasets used in SEE. In such cases a method like random search can potentially provide similar benefits as some of the existing tuners, with the advantage of using low amounts of resources and being simple to implement. In this study we evaluate the impact on model accuracy and stability of 12 state-of-the-art hyper-parameter tuning algorithms against random search, on 9 datasets of the PROMISE repository and 4 sub-datasets from the ISBSG R18 dataset. This study covers 2 traditional exhaustive tuners (grid and random searches), 6 bio-inspired algorithms, 2 heuristic tuners, and 3 model-based algorithms. The tuners are used to configure support vector regression, classification and regression trees, and ridge regression models. We aim to determine the techniques and datasets for which certain tuners were 1) more effective than default hyper-parameters, 2) more effective than random search, 3) which models(s) can be considered "the best" for which datasets. The results of this study show that hyper-parameter tuning was effective (increased accuracy and stability) in 862 (51%) of the 1,690 studied scenarios. The 12 state-of-the-art tuners were more effective than random search in 95 (6%) of the 1,560 studied (non-random search) scenarios. Although not effective in every dataset, the combination of flash tuning, logarithm transformation and support vector regression obtained top ranking in accuracy on the highest amount (8 out of 13) of datasets. Hyperband tuned ridge regression with logarithm transformation obtained top ranking in accuracy on the highest amount (10 out of 13) of datasets. We endorse the use of random search as a baseline for comparison for future studies that consider hyper-parameter tuning.;;;https://dl.acm.org/doi/10.1145/3475960.3475986;;;Software AND Engineering
Software Defect Prediction Method based on Hybrid Sampling;;;['Xiaozhi Du', 'Hehe Yue', 'Honglei Dong'];;;May 2021;;;ICFEICT 2021: International Conference on Frontiers of Electronics, Information and Computation Technologies;;;Software defect prediction is an essential technology to provide guidance and assistance for software testers and developers. However, the problem of imbalanced data sets limits the effect and application of the software defect prediction. To address this issue, this paper proposes a software defect prediction method based on hybrid sampling, which combines the strategies of over-sampling with under-sampling. For minority class, over-sampling uses k-means to cluster samples, then adopts SMOTE to generate artificial data based on safe areas of the clustering outcome. For majority class, under-sampling uses logistic regression classifier to get the misclassification probability of each sample and its instance hardness value. Then the samples, whose instance hardness values are lower than the threshold, are removed from the datasets. The experimental results show that our method is superior to the previous methods. Compared with SMOTE-kNN, SMOTE-Tomek, SMOTE and DBSMOTE, the accuracy of our method is improved by 17.60%, 6.99%, 8.66% and 26.18% on average respectively.;;;https://dl.acm.org/doi/10.1145/3474198.3478215;;;Software AND Engineering
Finding Software License Violations Through Binary Code Clone Detection - A Retrospective;;;['Armijn Hemel', 'Karl Trygve Kalleberg', 'Rob Vermaas', 'Eelco Dolstra'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;Ten years ago, we published the article Finding software license violations through binary code clone detection at the MSR 2011 conference. Our paper was motivated by the tendency of em- bedded hardware vendors to only release binary blobs of their rmware, often violating the licensing terms of open-source soft- ware present inside those blobs. The techniques presented in our paper were designed to accurately identify open-source code hid- den inside binary blobs. Here, we give our perspectives on the impact of our work, both industrially and academically, and re- visit the original problem statement to see what has happened in the eld of open-source compliance in the intervening decade.;;;https://dl.acm.org/doi/10.1145/3468744.3468752;;;Software AND Engineering
One thousand and one stories: a large-scale survey of software refactoring;;;['Yaroslav Golubev', 'Zarina Kurbatova', 'Eman Abdullah AlOmar', 'Timofey Bryksin', 'Mohamed Wiem Mkaouer'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Despite the availability of refactoring as a feature in popular IDEs, recent studies revealed that developers are reluctant to use them, and still prefer the manual refactoring of their code. At JetBrains, our goal is to fully support refactoring features in IntelliJ-based IDEs and improve their adoption in practice. Therefore, we start by raising the following main questions. How exactly do people refactor code? What refactorings are the most popular? Why do some developers tend not to use convenient IDE refactoring tools?   In this paper, we investigate the raised questions through the design and implementation of a survey targeting 1,183 users of IntelliJ-based IDEs. Our quantitative and qualitative analysis of the survey results shows that almost two-thirds of developers spend more than one hour in a single session refactoring their code; that refactoring types vary greatly in popularity; and that a lot of developers would like to know more about IDE refactoring features but lack the means to do so. These results serve us internally to support the next generation of refactoring features, as well as can help our research community to establish new directions in the refactoring usability research.;;;https://dl.acm.org/doi/10.1145/3468264.3473924;;;Software AND Engineering
Testing your question answering software via asking recursively;;;['Songqiang Chen', 'Shuo Jin', 'Xiaoyuan Xie'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Question Answering (QA) is an attractive and challenging area in NLP community. There are diverse algorithms being proposed and various benchmark datasets with different topics and task formats being constructed. QA software has also been widely used in daily human life now. However, current QA software is mainly tested in a reference-based paradigm, in which the expected outputs (labels) of test cases need to be annotated with much human effort before testing. As a result, neither the just-in-time test during usage nor the extensible test on massive unlabeled real-life data is feasible, which keeps the current testing of QA software from being flexible and sufficient. In this paper, we propose a method, QAAskeR, with three novel Metamorphic Relations for testing QA software. qaAskeR does not require the annotated labels but tests QA software by checking its behaviors on multiple recursively asked questions that are related to the same knowledge. Experimental results show that qaAskeR can reveal violations at over 80% of valid cases without using any pre-annotated labels. Diverse answering issues, especially the limited generalization on question types across datasets, are revealed on a state-of-the-art QA algorithm.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678670;;;Software AND Engineering
Early Life Cycle Software Defect Prediction: Why? How?;;;['N. C. Shrikanth', 'Suvodeep Majumder', 'Tim Menzies'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Many researchers assume that, for software analytics, "more data is better." We write to show that, at least for learning defect predictors, this may not be true. To demonstrate this, we analyzed hundreds of popular GitHub projects. These projects ran for 84 months and contained 3,728 commits (median values). Across these projects, most of the defects occur very early in their life cycle. Hence, defect predictors learned from the first 150 commits and four months perform just as well as anything else. This means that, at least for the projects studied here, after the first few months, we need not continually update our defect prediction models. We hope these results inspire other researchers to adopt a "simplicity-first" approach to their work. Some domains require a complex and data-hungry analysis. But before assuming complexity, it is prudent to check the raw data looking for "short cuts" that can simplify the analysis.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00050;;;Software AND Engineering
CVEfixes: automated collection of vulnerabilities and their fixes from open-source software;;;['Guru Bhandari', 'Amara Naseer', 'Leon Moonen'];;;August 2021;;;PROMISE 2021: Proceedings of the 17th International Conference on Predictive Models and Data Analytics in Software Engineering;;;Data-driven research on the automated discovery and repair of security vulnerabilities in source code requires comprehensive datasets of real-life vulnerable code and their fixes. To assist in such research, we propose a method to automatically collect and curate a comprehensive vulnerability dataset from Common Vulnerabilities and Exposures (CVE) records in the National Vulnerability Database (NVD). We implement our approach in a fully automated dataset collection tool and share an initial release of the resulting vulnerability dataset named CVEfixes. The CVEfixes collection tool automatically fetches all available CVE records from the NVD, gathers the vulnerable code and corresponding fixes from associated open-source repositories, and organizes the collected information in a relational database. Moreover, the dataset is enriched with meta-data such as programming language, and detailed code and security metrics at five levels of abstraction. The collection can easily be repeated to keep up-to-date with newly discovered or patched vulnerabilities. The initial release of CVEfixes spans all published CVEs up to 9 June 2021, covering 5365 CVE records for 1754 open-source projects that were addressed in a total of 5495 vulnerability fixing commits. CVEfixes supports various types of data-driven software security research, such as vulnerability prediction, vulnerability classification, vulnerability severity prediction, analysis of vulnerability-related code changes, and automated vulnerability repair.;;;https://dl.acm.org/doi/10.1145/3475960.3475985;;;Software AND Engineering
Multi-stream online transfer learning for software effort estimation: is it necessary?;;;['Leandro L. Minku'];;;August 2021;;;PROMISE 2021: Proceedings of the 17th International Conference on Predictive Models and Data Analytics in Software Engineering;;;Software Effort Estimation (SEE) may suffer from changes in the relationship between features describing software projects and their required effort over time, hindering predictive performance of machine learning models. To cope with that, most machine learning-based SEE approaches rely on receiving a large number of Within-Company (WC) projects for training over time, being prohibitively expensive. The approach Dycom reduces the number of required WC training projects by transferring knowledge from Cross-Company (CC) projects. However, it assumes that CC projects have no chronology and are entirely available before WC projects start being estimated. Given the importance of taking chronology into account to cope with changes, it may be beneficial to also take the chronology of CC projects into account. This paper thus investigates whether and under what circumstances treating CC projects as multiple data streams to be learned over time may be useful for improving SEE. For that, an extension of Dycom called OATES is proposed to enable multi-stream online learning, so that both incoming WC and CC data streams can be learnt over time. OATES is then compared against Dycom and five other approaches on a case study using four different scenarios derived from the ISBSG Repository. The results show that OATES improved predictive performance over the state-of-the-art when the number of CC projects available beforehand was small. Learning CC projects over time as multiple data streams is thus recommended for improving SEE in such scenario. When the number of CC projects available beforehand was large, OATES obtained similar predictive performance to the state-of-the-art. Therefore, CC data streams are unnecessary in this scenario, but are not detrimental either.;;;https://dl.acm.org/doi/10.1145/3475960.3475988;;;Software AND Engineering
Characterizing Student Proficiency in Software Modeling in Terms of Functions, Structures, and Behaviors;;;['Paul J. Thomas', 'Devang Patel', 'Alejandra J. Magana'];;;None;;;ACM Transactions on Computing Education;;;Software modeling is an integral practice for software engineers, especially as the complexity of software solutions increases. Unified Modeling Language (UML) is the industry standard for software modeling. however, it is often used incorrectly and misunderstood by novice software designers. This study is centered around understanding patterns of student proficiency of abstraction and systems thinking within a software modeling context. The participants of this study (n = 97) belonged to a systems analysis and design course that is primarily taken by second-year university students. The exam solutions to a case study from the course were evaluated for modeling proficiency. As evidence of proficiency in abstract thinking and systems thinking, we evaluated UML activity diagrams, class diagrams, and sequence diagrams and the alignment between these representations in terms of functions, structures, and behaviors. The results suggest students being proficient in modeling the functional aspects of an information system while facing some difficulty in capturing the structural and behavioral aspects of an information system. Clustering analysis revealed two groups within the sample, with one group displaying a significantly higher abstraction and systems thinking ability. Statistically significant correlations were also found between student proficiency of abstraction and their modeling proficiency in terms of functions, structures, and behaviors.;;;https://dl.acm.org/doi/10.1145/3458039;;;Software AND Engineering
Requirements Behind Reviews: How do Software Practitioners See App User Reviews to Think of Requirements?;;;['Walter Takashi Nakamura', 'José Cezar de Souza', 'Lígia Márcia Teixeira', 'Afonso Silva', 'Rogenis da Silva', 'Bruno Gadelha', 'Tayana Conte'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;The popularity of mobile computing has led to the development of several mobile apps to solve end-users everyday problems. Nowadays, app stores allow users to write reviews reporting their experiences using the apps. Negative experiences can reveal the reasons why users are moving from one app to another and drive app adoption by future users. Thus, software companies should listen to users’ voices to meet their needs and improve the quality of their apps. In this context, Data-Driven Requirements Engineering (DDRE) emerges as an alternative approach to develop and manage requirements from large volumes of data such as user reviews. Most research on DDRE has focused on assessing different machine learning, information retrieval, and natural language processing techniques for automatic requirements mining and classification. However, we need to move forward to understand how to support the DDRE adoption by software practitioners who will apply the paradigm in practice. In this paper, we present a tool-supported approach for data-driven requirements elicitation. It applies text mining techniques to obtain user reviews from app stores and presents the most frequent terms with their associated reviews through a visual representation. To advance the understanding of DDRE adoption, we conducted a feasibility study with industry practitioners to investigate how our approach supports the requirements elicitation process. Our main findings indicated a positive acceptance by practitioners. They perceived it as easy to use and useful to think of requirements while demonstrating an intention to adopt it in the requirements elicitation process.;;;https://dl.acm.org/doi/10.1145/3493244.3493245;;;Software AND Engineering
Design of A Wideband Software Radio;;;['Tongliang Fan', 'Yandong Sun'];;;October 2021;;;ICITEE '21: Proceedings of the 4th International Conference on Information Technologies and Electrical Engineering;;;In modern tactical communication, the radio station has low power consumption and good compatibility of different frequency band signals. The software radio platform can cover a wide band, which is designed by RF direct sampling. By integrating digital signal processing, the requirements of small size. The waveform tests show this platform has good communication performance. The platform can meet the requirements of miniaturization, low power consumption.;;;https://dl.acm.org/doi/10.1145/3513142.3513143;;;Software AND Engineering
Understanding Bounding Functions in Safety-Critical UAV Software;;;['Xiaozhou Liang', 'John Henry Burns', 'Joseph Sanchez', 'Karthik Dantu', 'Lukasz Ziarek', 'Yu David Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Unmanned Aerial Vehicles (UAVs) are an emerging computation platform known for their safety-critical need. In this paper, we conduct an empirical study on a widely used open-source UAV software framework, Paparazzi, with the goal of understanding the safety-critical concerns of UAV software from a bottom-up developer-in-the-field perspective. We set our focus on the use of Bounding Functions (BFs), the runtime checks injected by Paparazzi developers on the range of variables. Through an in-depth analysis on BFs in the Paparazzi autopilot software, we found a large number of them (109 instances) are used to bound safety-critical variables essential to the cyber-physical nature of the UAV, such as its thrust, its speed, and its sensor values. The novel contributions of this study are two fold. First, we take a static approach to classify all BF instances, presenting a novel datatype-based 5-category taxonomy with finegrained insight on the role of BFs in ensuring the safety of UAV systems. Second, we dynamically evaluate the impact of the BF uses through a differential approach, establishing the UAV behavioral difference with and without BFs. The two-pronged static and dynamic approach together illuminates a rarely studied design space of safety-critical UAV software systems.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00119;;;Software AND Engineering
Public Software Development Activity During the Pandemic;;;['Vanessa Klotzman', 'Farima Farmahinifarahani', 'Cristina Lopes'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background The emergence of the COVID-19 pandemic has impacted all human activity, including software development. Early reports seem to indicate that the pandemic may have had a negative effect on software developers, socially and personally, but that their software development productivity may not have been negatively impacted. Aims: Early reports about the effects of the pandemic on software development focused on software developers' well-being and on their productivity as employees. We are interested in a different aspect of software development: the developers' public contributions, as seen in GitHub and Stack Overflow activities. Did the pandemic affect the developers' public contributions and, of so, in what way? Method: Considering the data from between 2017 and till 2020, we study the trends within GitHub's push, create, pull request, and release events, and within Stack Overflow's new users, posts, votes, and comments. We performed linear regressions, correlation analyses, outlier analyses, hypothesis testing, and we also contacted individual developers in order to gather qualitative insights about their unusual public contributions. Results: Our study shows that within GitHub and Stack Overflow, the onset of the pandemic (March/April 2020) is reflected in a set of outliers in developers' contributions that point to an increase in activity. The distributions of contributions during the entire year of 2020 were, in some aspects, different, but, in other aspects, similar from the recent past. Additionally, we found one noticeably disrupted pattern of contribution in Stack Overflow, namely the ratio Questions/Answers, which was much higher in 2020 than before. Testimonials from the developers we contacted were mixed: while some developers reported that their increase in activity was due to the pandemic, others reported that it was not. Conclusion: In Github, there was a noticeable increase in public software development activity in 2020, as well as more abrupt changes in daily activities; in Stack Overflow, there was a noticeable increase in new users and new questions at the onset of the pandemic, and in the ratio of Questions/Answers during 2020. The results may be attributed to the pandemic, but other factors could have come into play.;;;https://dl.acm.org/doi/10.1145/3475716.3475778;;;Software AND Engineering
Education, Innovation and Software Production: The use of Reflective Practice;;;['Aline Andrade', 'Regina Albuquerque', 'Tania Mara Dors', 'Fabio Vinicius Binder', 'Andreia Malucelli', 'Sheila Reinehr'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;None;;;https://dl.acm.org/doi/10.1145/3493244.3493265;;;Software AND Engineering
Timely and accurate detection of model deviation in self-adaptive software-intensive systems;;;['Yanxiang Tong', 'Yi Qin', 'Yanyan Jiang', 'Chang Xu', 'Chun Cao', 'Xiaoxing Ma'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Control-based approaches to self-adaptive software-intensive systems (SASs) are hailed for their optimal performance and theoretical guarantees on the reliability of adaptation behavior. However, in practice the guarantees are often threatened by model deviations occurred at runtime. In this paper, we propose a Model-guided Deviation Detector (MoD2) for timely and accurate detection of model deviations. To ensure reliability, a SAS can switch a control-based optimal controller for a mandatory controller once an unsafe model deviation is detected. MoD2 achieves both high timeliness and high accuracy through a deliberate fusion of parameter deviation estimation, uncertainty compensation, and safe region quantification. Empirical evaluation with three exemplar systems validated the efficacy of MoD2 (93.3% shorter detection delay, 39.4% lower FN rate, and 25.2% lower FP rate), as well as the benefits of the adaptation-switching mechanism (abnormal rate dropped by 29.2%).;;;https://dl.acm.org/doi/10.1145/3468264.3468548;;;Software AND Engineering
Limited Associativity Makes Concurrent Software Caches a Breeze;;;['Dolev Adas', 'Gil Einziger', 'Roy Friedman'];;;January 2022;;;ICDCN '22: Proceedings of the 23rd International Conference on Distributed Computing and Networking;;;Software caches optimize the performance of diverse storage systems, databases and other software systems. Existing works on software caches automatically resort to fully associative cache designs. Our work shows that limited associativity caches are a promising direction for concurrent software caches. Specifically, we demonstrate that limited associativity enables simple yet efficient realizations of multiple cache management schemes that can be trivially parallelized. We show that the obtained hit ratio is usually similar to fully associative caches of the same management policy, but the throughput is improved by up to x5 compared to production-grade caching libraries, especially in multi-threaded executions.;;;https://dl.acm.org/doi/10.1145/3491003.3491013;;;Software AND Engineering
ConE: A Concurrent Edit Detection Tool for Large-scale Software Development;;;['Chandra Maddila', 'Nachiappan Nagappan', 'Christian Bird', 'Georgios Gousios', 'Arie van Deursen'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Modern, complex software systems are being continuously extended and adjusted. The developers responsible for this may come from different teams or organizations, and may be distributed over the world. This may make it difficult to keep track of what other developers are doing, which may result in multiple developers concurrently editing the same code areas. This, in turn, may lead to hard-to-merge changes or even merge conflicts, logical bugs that are difficult to detect, duplication of work, and wasted developer productivity. To address this, we explore the extent of this problem in the pull-request-based software development model. We study half a year of changes made to six large repositories in Microsoft in which at least 1,000 pull requests are created each month. We find that files concurrently edited in different pull requests are more likely to introduce bugs. Motivated by these findings, we design, implement, and deploy a service named Concurrent Edit Detector (ConE) that proactively detects pull requests containing concurrent edits, to help mitigate the problems caused by them. ConE has been designed to scale, and to minimize false alarms while still flagging relevant concurrently edited files. Key concepts of ConE include the detection of the Extent of Overlap between pull requests, and the identification of Rarely Concurrently Edited Files. To evaluate ConE, we report on its operational deployment on 234 repositories inside Microsoft. ConE assessed 26,000 pull requests and made 775 recommendations about conflicting changes, which were rated as useful in over 70% (554) of the cases. From interviews with 48 users, we learned that they believed ConE would save time in conflict resolution and avoiding duplicate work, and that over 90% intend to keep using the service on a daily basis.;;;https://dl.acm.org/doi/10.1145/3478019;;;Software AND Engineering
Re-imagining performance reviews: automated dashboards for continuous visibility of engineers' performance;;;['Fatma Meawad'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Traditional methods for performance appraisal are not suitable for agile fast-paced software companies. This has been a realization in the software industry since the early adoption of agile methodologies. Nonetheless, software companies are still struggling to find a practical solution that fits the highly dynamic nature of their teams. In particular, high-growth companies, scaleups, need to be creative at how they approach performance appraisals. In this talk, we introduce automated review dashboards to support a seamless appraisal process and continuous visibility of software engineers' performance. The proposed dashboards leverage structure from existing growth frameworks while automating the aggregation of relevant qualitative and quantitative performance metrics. We reflect on our experience using the dashboards at Robusta, a medium-sized software scaleup company. The dashboards enabled a team of four managers to provide timely feedback to 56 engineers with a base for continuous visibility. We explore the design of the dashboards, the customizable metrics and the overall review experience from the perspectives of different stakeholders. We conclude with the lessons learned and practical advice for scaleups facing the same challenge.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00046;;;Software AND Engineering
Guidelines for Promoting Software Product Line Experiments;;;['Viviane Furtado', 'Edson OliveiraJr', 'Marcos Kalinowski'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;The importance of experimentation for Software Engineering research has been notably established in the last years. The software engineering community has discussed how to proper report and evaluate experiments using different approaches, such as quality criteria, scales, and checklists. Nevertheless, there are no guidelines to support researchers and practitioners active in straightforward software engineering research areas, as in Software Product Lines (SPL), at conducting experiments. We hypothesize that experimentation guidelines may aid such a specific area by providing advice and actual excerpts reflecting good practices of SPL experimentation, thus experimentally evolving this area. Therefore, the goal of this paper is to provide guidelines for properly reporting and promoting SPL experiments. We defined such guidelines based on well-known software engineering experiment reports, quality evaluation checklists, and data extracted from 211 SPL experiments identified in a systematic mapping study. We evaluated the guidelines with a qualitative study with SPL and experimentation experts applying open and axial coding procedures. The evaluation enabled us to improve the guidelines. The resulting guidelines contain specific advice to researchers active in SPL and provide examples taken from published SPL experiments. The experts’ positive points indicate that the proposed guidelines can aid SPL researchers and practitioners. Sharing the resulting guidelines could support conducting SPL experiments and allow further area evolution based on prospective experiment replications and reproductions from well-designed and reported experiments.;;;https://dl.acm.org/doi/10.1145/3483899.3483909;;;Software AND Engineering
Good Bug Hunting: Inspiring and Motivating Software Testing Novices;;;['Natalia Silvis-Cividjian', 'Marc Went', 'Robert Jansma', 'Viktor Bonev', 'Emil Apostolov'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;Although software testing is crucial in safeguarding our rapidly digitizing society against accidental and malefic threats, students often perceive it as an unattractive activity when compared to design or coding. A more abundant exposure to bugs and their impact can improve the situation. To test this radically new hypothesis, we developed VU-BugZoo, an interactive software testing learning platform. Built upon a repository of fault-seeded executables, the platform engages students and teachers in a dynamic bug-hunting experience. What counts the most in this game is the quality of the test strategy and fault diagnosis, rather than just the quantity of devised test cases. In this paper, we describe the VU-BugZoo web-application, developed using a stack of Vue.js and Python Flask, running in Docker containers. Next, we report on its first deployment in the midst of the COVID-19 pandemic, for a remote assessment of 50 graduate CS students enrolled in an introductory software testing course. Students' evaluations show that for novices, a 100%-bug-guarantee, end-to-end testing challenge (1) makes learning more effective, (2) offers an adequate assessment instrument and (3) adds more excitement to an otherwise uninspiring chore. More research is needed to investigate the potential of our bug-centric approach to contribute to the hard mission of boosting students' interest in a testing career. We are currently extending the corpus of bugs with more fascinating and representative examples, and investigating code animation, automated grading and formative feedback generation. We intend to make the platform available for other software testing courses in academia and industry.;;;https://dl.acm.org/doi/10.1145/3430665.3456330;;;Software AND Engineering
A software architecture to control service-oriented manufacturing systems;;;['Sebastiano Gaiardelli', 'Stefano Spellini', 'Marco Panato', 'Michele Lora', 'Franco Fummi'];;;March 2022;;;DATE '22: Proceedings of the 2022 Conference &amp; Exhibition on Design, Automation &amp; Test in Europe;;;This paper presents a software architecture extending the classical automation pyramid to control and reconfigure flexible, service-oriented manufacturing systems. At the Planning level, the architecture requires a Manufacturing Execution System (MES) consistent with the International Society of Automation (ISA) standard. Then, the Supervisory level is automated by introducing a novel component, called Automation Manager. The new component interacts upward with the MES, and downward with a set of servers providing access to the manufacturing machines. The communication with machines relies on the OPC Unified Architecture (OPC UA) standard protocol, which allows exposing production tasks as "services". The proposed software architecture has been prototyped to control a real production line, originally controlled by a commercial MES, unable to fully exploit the flexibility provided by the case study manufacturing system. Meanwhile, the proposed architecture is fully exploiting the production line's flexibility.;;;https://dl.acm.org/doi/10.5555/3539845.3539856;;;Software AND Engineering
SoftMark: Software Watermarking via a Binary Function Relocation;;;['Honggoo Kang', 'Yonghwi Kwon', 'Sangjin Lee', 'Hyungjoon Koo'];;;December 2021;;;ACSAC '21: Proceedings of the 37th Annual Computer Security Applications Conference;;;The ease of reproducibility of digital artifacts raises a growing concern in copyright infringement; in particular, for a software product. Software watermarking is one of the promising techniques to verify the owner of licensed software by embedding a digital fingerprint. Developing an ideal software watermark scheme is challenging because i) unlike digital media watermarking, software watermarking must preserve the original code semantics after inserting software watermark, and ii) it requires well-balanced properties of credibility, resiliency, capacity, imperceptibility, and efficiency. We present SoftMark, a software watermarking system that leverages a function relocation where the order of functions implicitly encodes a hidden identifier. By design, SoftMark does not introduce additional structures (i.e., codes, blocks, or subroutines), being robust in unauthorized detection, while maintaining a negligible performance overhead and reasonable capacity. With various strategies against viable attacks (i.e., static binary re-instrumentation), we tackle the limitations of previous reordering-based approaches. Our empirical results demonstrate the practicality and effectiveness by successful embedding and extraction of various watermark values.;;;https://dl.acm.org/doi/10.1145/3485832.3488027;;;Software AND Engineering
Formal software verification measures up;;;['Samuel Greengard'];;;July 2021;;;Communications of the ACM;;;Verified coding techniques use mathematical proofs to ensure code is error-free and hacker-resistant. Can the approach revolutionize software?;;;https://dl.acm.org/doi/10.1145/3464933;;;Software AND Engineering
Design of GPU-Based Aerial Monitoring Signal Processing Software;;;['Jian Cao', 'Da Wu'];;;June 2021;;;ICCIR '21: Proceedings of the 2021 1st International Conference on Control and Intelligent Robotics;;;GPU (Graphic Unit Process) that has emerged in recent years has the advantages of strong floating-point computing power and high storage bandwidth, low development costs, short cycle times, and high portability. In the software development mode, the departmentalization study of GPU's air monitoring signal processing algorithm is completed, and the platform porting and acceleration of signal processing algorithm can be realized, so as to solve the problems of real-time and function expansion of air surveillance signal processing.;;;https://dl.acm.org/doi/10.1145/3473714.3473753;;;Software AND Engineering
SPLReePlan - Automated Support for Software Product Line Reengineering Planning;;;['Luciano Marchezan', 'Wesley Klewerton Guez Assunção', 'João Carbonell', 'Elder Rodrigues', 'Maicon Bernardino', 'Fábio Basso'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;The extractive adoption of Software Product Lines (SPL) relies on the reuse of the already developed systems, employing a reengineering process. However, due to the diversity of options found in the daily practice of SPL development, rigorous planning of scenarios is critical to perform SPL reengineering. This diversity is the result of different organizational aspects, such as team experience and product portfolio. Hence, a proper planning process must consider technical and organizational aspects, however, most existing studies in the field do not take into account organizational aspects of the companies. In this work, we present SPLReePlan, an automated framework to aid the SPL reengineering planning taking into account technical and organizational aspects. Our framework is supported by a web-based tool, ready to be used in the industry. To investigate how flexible is SPLReePlan to support the SPL reengineering planning in diverse situations, we extracted eight different scenarios from the SPL literature, which are used as input for the evaluation of SPLReePlan. The results indicate that SPLReePlan can be satisfactorily customized to a variety of scenarios with different artifacts, feature retrieval techniques, and reengineering activities. As a contribution, we discuss the lessons learned within the evaluation, and present challenges that were faced, being a source of information for tool builders or motivating new studies.;;;https://dl.acm.org/doi/10.1145/3483899.3483902;;;Software AND Engineering
Software Testing Effort Estimation and Related Problems: A Systematic Literature Review;;;['Ilona Bluemke', 'Agnieszka Malanowska'];;;None;;;ACM Computing Surveys;;;Although testing effort estimation is a very important task in software project management, it is rarely described in the literature. There are many difficulties in finding any useful methods or tools for this purpose. Solutions to many other problems related to testing effort calculation are published much more often. There is also no research focusing on both testing effort estimation and all related areas of software engineering. To fill this gap, we performed a systematic literature review on both questions. Although our primary objective was to find some tools or implementable metods for test effort estimation, we have quickly discovered many other interesting topics related to the main one. The main contribution of this work is the presentation of the testing effort estimation task in a very wide context, indicating the relations with other research fields. This systematic literature review presents a detailed overview of testing effort estimation task, including challenges and approaches to automating it and the solutions proposed in the literature. It also exhaustively investigates related research topics, classifying publications that can be found in connection to the testing effort according to seven criteria formulated on the basis of our research questions. We present here both synthesis of our finding and the deep analysis of the stated research problems.;;;https://dl.acm.org/doi/10.1145/3442694;;;Software AND Engineering
How Do Brazilian Software Development Teams Deal with Working From Home After a Year of the COVID-19 Pandemic?;;;['Carla Bezerra', 'Emanuel Coutinho', 'Amarildo Araujo'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The COVID-19 pandemic has lasted for over 1 year. During the pandemic, several software development companies migrated to working from home (WFH). Several studies have recorded an initial moment of adaptation to WFH. This study investigated how Brazilian software development teams dealt with WFH after 1 year of a pandemic and how this change in work was on the software development process. We applied a survey with 67 participants of software development teams and investigated aspects, as: work routine, collaboration, communication, productivity, financial assistance and software development process. We performed a quantitative and qualitative analysis of the survey results and compared them with previous studies. Our key findings are: (i) 56.71% of the participants said that it has an impact on the work routine related to work overload and exceeds the company’s standard hours; (ii) 92.54% of the participants consider their team to be collaborative; (iii) 82.70% are satisfied with the communication at WFH; (iv) 86.55% has meetings once or twice a day; (v) 59.7% had an improvement in productivity in WFH and 75% are satisfied with their productivity; (vi) 79.60% receive some assistance from the company for WFH; (vii) 82.1% said that the company intends or probably intends to continue in the WFH, and (viii) 55.2% said they had changed in the software development process due to WFH. The main positive changes in the process are related to the practices of: daily meetings, agile processes, code review, pair programming and code versioning.;;;https://dl.acm.org/doi/10.1145/3474624.3474637;;;Software AND Engineering
Leveraging relational concept analysis for automated feature location in software product lines;;;['Nicolas Hlad', 'Bérénice Lemoine', 'Marianne Huchard', 'Abdelhak-Djamel Seriai'];;;October 2021;;;GPCE 2021: Proceedings of the 20th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;;;Formal Concept Analysis (FCA) has been introduced for almost a decade as a suitable method for Feature Location (FL) on a collection of product variants. Even though FCA-based FL techniques allow to locate the core of a feature implementation, they do not propose a solution to trace feature interactions to their implementation. Thus, the extracted traceability links (traces) are too inaccurate, and, in the context of SPL extraction, cannot be used to generate complete products.  In this paper, we propose to complement the FCA-based FL techniques by leveraging the power of Relational Concept Analysis, an extension of FCA to multi-relational data. From two given formal contexts, one for the product’s artefact and one for their features, our technique computes the traces that link the features and the feature interactions to their corresponding artefacts. Additionally, we introduce a stage that removes unnecessary features from the extracted traces, to make them easier to understand by an expert. Our FL technique can be applied at any artefact granularity (from files to statements) and independently from software languages.  The results show that our technique produces valid traces, from which we were able to completely rebuild the set of artefacts for each initial product. Moreover, they show that our trace reduction removes, on average, between 31% and 85% of unnecessary features from the traces.;;;https://dl.acm.org/doi/10.1145/3486609.3487208;;;Software AND Engineering
Factors that Affect Merge Conflicts: A Software Developers’ Perspective;;;['Catarina Costa', 'José Menezes', 'Bruno Trindade', 'Rodrigo Santos'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Merge conflicts are very common in collaborative software development. Such collaborative work is usually supported by the use of branches, which at some point can be merged. In the technical literature, several studies propose mechanisms to avoid conflicts, even though this is not always possible. Some recent studies have tried to identify factors that lead to conflicts. In our study, we aim to investigate factors that can lead to conflicts, or that can somehow reduce the chances of conflicts, from the developers’ perspective. To do so, we conducted a survey research with 109 software developers to understand the way they use branches, the occurrence of conflicts and resolution process, and factors that can lead or avoid conflicts. Results show that the use of branches is very common and mostly has the purpose of creating a new feature or fixing a bug. According to the participants, in most projects, developers have autonomy to create new branches and sometimes conflicts happen. The main factors that can lead to conflicts are “the time a branch is isolated” and “lack of communication”. On the other hand, the factors cited as good practices to avoid conflicts were “improve team communication” and “less branching-duration”.;;;https://dl.acm.org/doi/10.1145/3474624.3474641;;;Software AND Engineering
Representation of Developer Expertise in Open Source Software;;;['Tapajit Dey', 'Andrey Karnauch', 'Audris Mockus'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Background: Accurate representation of developer expertise has always been an important research problem. While a number of studies proposed novel methods of representing expertise within individual projects, these methods are difficult to apply at an ecosystem level. However, with the focus of software development shifting from monolithic to modular, a method of representing developers' expertise in the context of the entire OSS development becomes necessary when, for example, a project tries to find new maintainers and look for developers with relevant skills. Aim: We aim to address this knowledge gap by proposing and constructing the Skill Space where each API, developer, and project is represented and postulate how the topology of this space should reflect what developers know (and projects need). Method: we use the World of Code infrastructure to extract the complete set of APIs in the files changed by open source developers and, based on that data, employ Doc2Vec embeddings for vector representations of APIs, developers, and projects. We then evaluate if these embeddings reflect the postulated topology of the Skill Space by predicting what new APIs/projects developers use/join, and whether or not their pull requests get accepted. We also check how the developers' representations in the Skill Space align with their self-reported API expertise. Result: Our results suggest that the proposed embeddings in the Skill Space appear to satisfy the postulated topology and we hope that such representations may aid in the construction of signals that increase trust (and efficiency) of open source ecosystems at large and may aid investigations of other phenomena related to developer proficiency and learning.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00094;;;Software AND Engineering
Tracking and Reporting Software Maintenance Requests Challenges in CMMS Systems: Proposing a custom computerized maintenance management systems CMMS tool, especially designed for software systems maintenance;;;['Gumma B. Alshokry', 'Mohamed A. Hagal', 'Bilal A. Aljabour'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;Abstract- It is almost impossible to produce a software system which do not need to be changed. Once the software system is put into use, new requirements may appear, and changes of the current features may be requested by the users. Also, parts of the software may have to be modified to avoid errors found during operation, or to improve software performance, by changing functional or non-functional characteristics. After software deployment, software usually evolve in response to requests for change or in response to market competition. Computerized maintenance management systems CMMS used to verify maintenance regulatory compliance. To control the maintenance process manually it requires a lot of effort and time. In the same time the CMMS have some challenges while covering software changes requests. This paper suggests a way and a tool for tracking and reporting software maintenance requests to cover all challenges in CMMS systems, and supporting software changes requisites more effectively.;;;https://dl.acm.org/doi/10.1145/3492547.3492621;;;Software AND Engineering
Software development in disruptive times;;;['João Varajão'];;;October 2021;;;Communications of the ACM;;;Creating a software solution with fast decision capability, agile project management, and extreme low-code technology.;;;https://dl.acm.org/doi/10.1145/3453932;;;Software AND Engineering
A live environment for inspection and refactoring of software systems;;;['Sara Fernandes'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Refactoring helps to improve the design of software systems, making them more readable, maintainable, cleaner, and easy to expand. Most of the tools that already exist on this concept allow developers to select and execute the best refactoring techniques for a particular programming context. However, they aren’t interactive and prompt enough, providing a poor programming experience. In this gap, we can introduce and combine the topic of liveness with refactoring methods. Live Refactoring allows to know continuously, while programming, the blocks of code that we should refactor and why they were classified as problematic. Therefore, it shortens the time needed to create high-quality systems, due to early and continuous refactoring feedback, support, and guidance. This paper presents our research project based on a live refactoring environment. This environment is focused on a refactoring tool that aims to explore the concept of Live Refactoring and its main components --- recommendation, visualization, and application.;;;https://dl.acm.org/doi/10.1145/3468264.3473100;;;Software AND Engineering
Toward Exploratory Understanding of Software using Test Suites;;;['Dominik Meier', 'Toni Mattis', 'Robert Hirschfeld'];;;March 2021;;;Programming '21: Companion Proceedings of the 5th International Conference on the Art, Science, and Engineering of Programming;;;Changing software without correctly understanding it often leads to confusion, as developers do not understand how the change corresponds to the new observed behaviour of the system. Today, many software systems are equipped with a test suite. Test suites document code and give feedback on changed program behaviour. We explored ways to use test suites for software comprehension and implemented a tool that provides additional visualisation and gives immediate feedback on software changes. Information about changes in the software and their implications to the test suite are collected using mutation testing. The tool uses this information to present relevant test cases for developers, and additionally prioritise test executions for immediate feedback. Our research indicates that entropy metrics can find test cases that are relevant for a specific context in the source code. Additionally, simple test case prioritisation strategies can already lead to a significant decrease in feedback time. Based on our case study we argue that test suites are not only useful for regression testing but can be used to generate meaningful information for software comprehension activities.;;;https://dl.acm.org/doi/10.1145/3464432.3464438;;;Software AND Engineering
Commercial Aircraft On-Board Loadable Software Distribution and Control Digital Solution;;;['Lei Zhang', 'Jinghua Sun', 'Ling Li', 'Jinling Cheng'];;;November 2021;;;AISS '21: Proceedings of the 3rd International Conference on Advanced Information Science and System;;;Modern commercial aircraft have become more and more software-controlled. The use of physical media to distribute and control on-board loadable software is inefficient and costly. The paper studied the traditional software distribution and control process, and proposed a VPN and wireless-based digital solution framework by applying the State of the Art, including electronic signatures, data encryption, network security, artificial Intelligence(AI), and digital twin technology. The solutions can significantly enhance the ability of manufacturers and operators to manage the on-board loadable software, reduce the time spent in copying and distributing the physical media, which can also contribute to aircraft predictive maintenance.;;;https://dl.acm.org/doi/10.1145/3503047.3503053;;;Software AND Engineering
Mining Evidences of Internet of Robotic Things (IoRT) Software from Open Source Projects;;;['Michel Albonico', 'Adair Rohling', 'Juliano Santos', 'Paulo Varela'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;The current world scenario is heading to contactless technologies, where robots are in the center. These systems usually benefit from Internet of Things (IoT) sensing, being named Internet of Robotics Things (IoRT) systems. Developing IoRT software naturally involves high levels of complexity, which may be softened with well-established architectural evidence. In this paper, we aim at mining IoRT software architectural evidence from open source IoRT software repositories. For this, we (i) extract a dataset from GitHub repositories containing real open-source IoRT systems, (ii) mine relevant information from those repositories, (iii) and compile a catalog of architectural software characteristics. The catalog from our study can then be used by practitioners architects.;;;https://dl.acm.org/doi/10.1145/3483899.3483900;;;Software AND Engineering
Implementation of Processing Algorithm on Radar Signal Mixed Mode Software;;;['Jian Cao', 'Xiaobin Li'];;;June 2021;;;ICCIR '21: Proceedings of the 2021 1st International Conference on Control and Intelligent Robotics;;;This paper discusses the implementation of a radar signal mixed mode software processing algorithm. In this mode, all cores are divided equally into groups, each containing two cores, which can independently perform a beam signal processing task. This is equivalent to a data flow pattern, which completes the multi-beam processing process in parallel, thus giving full play to the processor's multicore characteristics.;;;https://dl.acm.org/doi/10.1145/3473714.3473755;;;Software AND Engineering
ArchViMP – a Framework for Automatic Extraction of Concurrency-related Software Architectural Properties;;;['Monireh Pourjafarian', 'Jasmin Jahic'];;;August 2021;;;ICPP Workshops '21: 50th International Conference on Parallel Processing Workshop;;;Concurrent multithreaded programs are more complex than sequential ones due to inter-dependencies of threads over shared memory. Because of these, software architects and developers quickly become overwhelmed when trying to design and manage concurrent software. Existing approaches that try to support architecture efforts in this domain rely on the visualization of concurrency-related properties of software to ease its understanding, but they fail because i) the abstractions they use do not capture information of architectural significance, and because ii) raw visualization of the interdependencies does not scale.  In this paper, we suggest a scalable solution that focuses on the abstraction of concurrency properties and their visualization using architectural views. Our framework for automatic extraction of concurrency-related architectural properties (ArchViMP) proposes i) a set of logical rules that abstract concurrency-related architecturally significant software properties and ii) a set of architectural views suitable for showing these concurrency properties.;;;https://dl.acm.org/doi/10.1145/3458744.3473349;;;Software AND Engineering
Microservice-based performance problem detection in cyber-physical system software updates;;;['Aitor Gartziandia'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Software embedded in Cyber-Physical Systems (CPSs) usually has a large life-cycle and is continuously evolving. The increasing expansion of IoT and CPSs has highlighted the need for additional mechanisms for remote deployment and updating of this software, to ensure its correct behaviour. Performance problems require special attention, as they may appear in operation due to limitations in lab testing and environmental conditions. In this context, we propose a microservice-based method to detect performance problems in CPSs. These microservices will be deployed in installation to detect performance problems in run-time when new software versions are deployed. The problem detection is based on Machine Learning algorithms, which predict the performance of a new software release based on knowledge from previous releases. This permits taking corrective actions so that system reliability is guaranteed.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00062;;;Software AND Engineering
Data Structures for a Generic Software System using the Composite Design Pattern;;;['Stefan Nadschläger', 'Daniel Hofer', 'Josef Küng', 'Markus Jäger'];;;July 2021;;;EuroPLoP'21: 26th European Conference on Pattern Languages of Programs;;;A well-designed generic software system can be reused in many contexts by efficiently handling variability. In this paper, data structures and their application in a software architecture is presented that apply the basic idea of the Composite design pattern to keep it as simple as possible, but also as generic as possible. The application of these data structures is shown throughout a layered architecture so that software developers can follow and apply the concepts. The benefit of such an architecture is that it (1) only makes use of familiar concepts, and it is easy to read and understand by knowing especially one design pattern and (2) results in a generic software system, usable in different domains.;;;https://dl.acm.org/doi/10.1145/3489449.3489972;;;Software AND Engineering
Establishing a Pattern Language for the Organization of Distributed Software Development;;;['Shakirullah Waseeb', 'Waheedullah Sulaiman Khail', 'Valentino Vranic'];;;July 2021;;;EuroPLoP'21: 26th European Conference on Pattern Languages of Programs;;;Despite considerable efforts to address organizational problems of distributed software development, currently available solutions do not seem to be sufficient. They are fragmented into individual patterns either not forming coherent pattern languages to address organizational distributed software development or being incorporated into extensive pattern languages for organizing software development in general. Another problem is their disconnection from the current technological support for collaboration. We attempt at overcoming these problems by providing a set of six organizational patterns for distributed software development. We relate them to each other and to other known patterns and practices practically establishing a pattern language for the organization of distributed software development. The overall idea of how this pattern language can be used is presented using a pattern story of a real company.;;;https://dl.acm.org/doi/10.1145/3489449.3489979;;;Software AND Engineering
An Under-sampling Algorithm Based on Weighted Complexity and Its Application in Software Defect Prediction;;;['Wei Wei', 'Feng Jiang', 'Xu Yu', 'Junwei Du'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;The under-sampling technique is an important method to solve the class imbalance issue in software defect prediction. However, the existing under-sampling methods generally ignore the problem that there are great differences in the complexities of different samples. In fact, the complexities of samples can play an important role in defect prediction, since there is a close relation between the complexities of samples and whether they have defects. Therefore, when we use the under-sampling technique to handle the class imbalance issue in software defect prediction, it is necessary to consider the complexities of samples. In this paper, we propose the notion of weighted complexity. When calculating the weighted complexity of each sample, the weights of different condition attributes are considered. Based on the weighted complexity, we propose a new under-sampling algorithm, called WCP-UnderSampler, and apply it to software defect prediction. In WCP-UnderSampler, we first employ the granularity decision entropy in rough sets to calculate the significance and the weight of each condition attribute; Second, the weighted complexity of each sample is obtained by calculating the weighted sum of the values of the sample on all attributes; Third, the majority class samples are sorted in descending order according to their weighted complexities, and the majority class samples with higher complexities are selected until a balanced data set is obtained. Experiments on defect prediction data sets show that we can obtain better software defect prediction results by using WCP-UnderSampler to handle the imbalanced data.;;;https://dl.acm.org/doi/10.1145/3520084.3520091;;;Software AND Engineering
Software-defined address mapping: a case on 3D memory;;;['Jialiang Zhang', 'Michael Swift', 'Jing (Jane) Li'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;3D-stacking memory such as High-Bandwidth Memory (HBM) and Hybrid Memory Cube (HMC) provides orders of magnitude more bandwidth and significantly increased channel-level parallelism (CLP) due to its new parallel memory architecture. However, it is challenging to fully exploit the abundant CLP for performance as the bandwidth utilization is highly dependent on address mapping in the memory controller. Unfortunately, CLP is very sensitive to a program’s data access pattern, which is not made available to OS/hardware by existing mechanisms.  In this work, we address these challenges with software-defined address mapping (SDAM) that, for the first time, enables user program to obtain a direct control of the low-level memory hardware in a more intelligent and fine-grained manner. In particular, we develop new mechanisms that can effectively communicate a program’s data access properties to the OS and hardware and to use it to control data placement in hardware. To guarantee correctness and reduce overhead in storage and performance, we extend Linux kernel and C-language memory allocators to support multiple address mappings. For advanced system optimization, we develop machine learning methods that can automatically identify access patterns of major variables in a program and cluster these with similar access patterns to reduce the overhead for SDAM. We demonstrate the benefits of our design on real system prototype, comprising (1) a RISC-V processor, near memory accelerators and HBM modules using Xilinx FPGA platform, and (2) modified Linux and glibc. Our evaluation on standard CPU benchmarks and data-intensive benchmarks (for both CPU and accelerators) demonstrates 1.41×, 1.84× speedup on CPU and 2.58× on near memory accelerators in our system with SDAM compared to a baseline system that uses a fixed address mapping.;;;https://dl.acm.org/doi/10.1145/3503222.3507774;;;Software AND Engineering
A model using agile methodologies for defining metrics to be used by the public sector in Brazil to set remuneration for outsourced software development;;;['Washington Henrique de Carvalho Almeida'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;The process of contracting software factories within the scope of the Federal Public Administration (APF, in Portuguese) in Brazil has undergone some changes due to legislative alterations and a model has been proposed to improve the rendering of services regarding delivering results. Software factory contracts based on predictive processes and on the metrics of Function Points are the target of criticisms and have issues in achieving results, as verified in previous research. The initial objective of the study now proposed will be to define a process model for formulating metrics that can be used in agile contracts as opposed to those of standardized Function Points which have already proved to be quite problematic and difficult for the contractor to manage. Thus, in line with the theme of agile contracts for software development companies, the study proposed will looking for better understand the problem of software development and its maintenance by public agencies by means of contracts using agil methodologies and appropriate metrics for remunerating these services.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00125;;;Software AND Engineering
Privacy Champions in Software Teams: Understanding Their Motivations, Strategies, and Challenges;;;['Mohammad Tahaei', 'Alisa Frik', 'Kami Vaniea'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;Software development teams are responsible for making and implementing software design decisions that directly impact end-user privacy, a challenging task to do well. Privacy Champions—people who strongly care about advocating privacy—play a useful role in supporting privacy-respecting development cultures. To understand their motivations, challenges, and strategies for protecting end-user privacy, we conducted 12 interviews with Privacy Champions in software development teams. We find that common barriers to implementing privacy in software design include: negative privacy culture, internal prioritisation tensions, limited tool support, unclear evaluation metrics, and technical complexity. To promote privacy, Privacy Champions regularly use informal discussions, management support, communication among stakeholders, and documentation and guidelines. They perceive code reviews and practical training as more instructive than general privacy awareness and on-boarding training. Our study is a first step towards understanding how Privacy Champions work to improve their organisation’s privacy approaches and improve the privacy of end-user products.;;;https://dl.acm.org/doi/10.1145/3411764.3445768;;;Software AND Engineering
Let a thousand flowers bloom: on the uses of diversity in software testing;;;['Alex Groce'];;;October 2021;;;Onward! 2021: Proceedings of the 2021 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software;;;Software testing is hard, and a testing problem is composed of many sub-problems with different, often conflicting, solutions. Like many real-world problems, it admits no single optimal solution, but requires dexterity, and the opportunistic combination of many partial solutions. Exploration and experiment, even by practitioners, are important in real-world critical testing efforts. An important set of research results in the field endorse and codify the value of diversity in test generation. However, our current approaches to evaluating research results arguably cut against this fundamental reality: while effective testing may need true diversity, combining many partial answers, the iron logic of the research results section often imposes a totalizing vision where authors must at least pretend to present a monolithic, unitary solution, a new “king of the hill.”;;;https://dl.acm.org/doi/10.1145/3486607.3486772;;;Software AND Engineering
Validation on machine reading comprehension software without annotated labels: a property-based method;;;['Songqiang Chen', 'Shuo Jin', 'Xiaoyuan Xie'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Machine Reading Comprehension (MRC) in Natural Language Processing has seen great progress recently. But almost all the current MRC software is validated with a reference-based method, which requires well-annotated labels for test cases and tests the software by checking the consistency between the labels and the outputs. However, labeling test cases of MRC could be very costly due to their complexity, which makes reference-based validation hard to be extensible and sufficient. Furthermore, solely checking the consistency and measuring the overall score may not be sensible and flexible for assessing the language understanding capability. In this paper, we propose a property-based validation method for MRC software with Metamorphic Testing to supplement the reference-based validation. It does not refer to the labels and hence can make much data available for testing. Besides, it validates MRC software against various linguistic properties to give a specific and in-depth picture on linguistic capabilities of MRC software. Comprehensive experimental results show that our method can successfully reveal violations to the target linguistic properties without the labels. Moreover, it can reveal problems that have been concealed by the traditional validation. Comparison according to the properties provides deeper and more concrete ideas about different language understanding capabilities of the MRC software.;;;https://dl.acm.org/doi/10.1145/3468264.3468569;;;Software AND Engineering
Supporting Readability by Comprehending the Hierarchical Abstraction of a Software Project;;;['Avijit Bhattacharjee', 'Banani Roy', 'Kevin Schneider'];;;February 2022;;;ISEC 2022: 15th Innovations in Software Engineering Conference;;;Exploring the source code of a software system is a prevailing task that is frequently done by contributors to a system. Practitioners often use call graphs to aid in understanding the source code of an inadequately documented software system. Call graphs, when visualized, show caller and callee relationships between functions. A static call graph provides an overall structure of a software system and dynamic call graphs generated from dynamic execution logs can be used to trace program behaviour for a particular scenario. Unfortunately a call graph of an entire system can be very complicated and hard to understand. Hierarchically abstracting a call graph can be used to summarize an entire system’s structure and more easily comprehending function calls. In this work, we mine concepts from source code entities (functions) to generate a concept cluster tree with improved naming of cluster nodes to complement existing studies and facilitate more effective program comprehension for developers. We apply three different information retrieval techniques (TFIDF, LDA, and LSI) on function names and function name variants to label the nodes of a concept cluster tree generated by clustering execution paths. From our experiment in comparing automatic labelling with manual labeling by participants for 12 use cases, we found that among the techniques on average, TFIDF performs better with 64% matching. LDA and LSI had 37% and 23% matching respectively. In addition, using the words in function name variants performed at least 5% better in participant ratings for all three techniques on average for the use cases.;;;https://dl.acm.org/doi/10.1145/3511430.3511441;;;Software AND Engineering
Do Critical Components Smell Bad? An Empirical Study with Component-based Software Product Lines;;;['Anderson Uchôa', 'Wesley Klewerton Guez Assunção', 'Alessandro Garcia'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;Component-based software product line (SPL) consists of a set of software products that share common components. For a proper SPL product composition, each component has to follow three principles: encapsulating a single feature, restricting data access, and be replaceable. However, it is known that developers usually introduce anomalous structures, i.e., code smells, along the implementation of components. These code smells might violate one or more component principles and hinder the SPL product composition. Thus, developers should identify code smells in component-based SPLs, especially those affecting highly interconnected components, which are called critical components. Nevertheless, there is limited evidence of how smelly these critical components tend to be in component-based SPLs. To address this limitation, this paper presents a survey with developers of three SPLs. We inquire these developers about their perceptions of a critical component. Then, we characterize critical components per SPL, and identify nine recurring types of code smells. Finally, we quantitatively assess the smelliness of the critical components. Our results suggest that: (i) critical components are ten times more prone to have code smells than non-critical ones; (ii) the most frequent code smell types affecting critical components violate several component principles together; and (iii) these smell types affect multiple SPL components.;;;https://dl.acm.org/doi/10.1145/3483899.3483907;;;Software AND Engineering
Improving Critical Infrastructure Protection by Enhancing Software Acquisition Process Through Blockchain;;;['Jelena Marjanović', 'Nikola Dalčeković', 'Goran Sladić'];;;May 2021;;;ECBS 2021: 7th Conference on the Engineering of Computer Based Systems;;;Proliferating supply chain attacks indicate that today's practices are insufficient for ensuring security and increasingly represent the weakest link in cybersecurity of software-based operational technologies. By tracking every action of integrating procured software components into an existing system, from analyzing vendors’ security to auditing purchaser's supply chain, a more secure software supply chain can be provided. Hyperledger Fabric, as a permissioned blockchain network, provides immutable i.e. tamper-proof solution for tracking the information stored on the ledger, while allowing only preauthorized actors to participate in the network. An approach that is taken in this paper is to track the software components that are introduced in the system, whether they are commercial-off-the-shelf components or tailor-made components and track their security analysis by utilizing blockchain technology. By defining Organization in blockchain network which can participate in the supply chain management process, this paper demonstrates the benefits of utilizing Hyperledger Fabric for managing acquired software components that are introduced in critical infrastructure. Given the analyzed use cases and proposed architecture, it can be concluded that Hyperledger Fabric blockchain provides necessary trust in a multi-party environment which is the basis for more efficient auditing of the whole process. The trustworthy logs and easier auditing are the key enablers for a supply chain management process that can address the described needs.;;;https://dl.acm.org/doi/10.1145/3459960.3459973;;;Software AND Engineering
Investigating Proprietary Software Ecosystem Governance and Health: An Updated and Refined Perspective;;;['Luiz Alexandre Costa', 'Awdren Fontão', 'Rodrigo Santos'];;;June 2021;;;SBSI '21: Proceedings of the XVII Brazilian Symposium on Information Systems;;;Although the approaches conceptualizing software ecosystems (SECO) have gained more relevance since 2010, there are not many studies addressing proprietary SECO. In a proprietary SECO, organizations are concerned with keeping their assets protected by intellectual property so that they are not exposed publicly, preventing this information from being used by competitors. Understanding how the governance mechanisms work and how organizations handle incidents on their platforms is a real challenge in this scenario. In this work, we aim at: i) providing an update on SECO governance mechanisms and SECO health metrics; ii) analyzing SECO classifications and evaluating the evolution of proprietary SECO; and iii) exploring the organization’s strategies in this context and investigating the SECO incident management process. To do so, a longitudinal literature study was performed on SECO, extending an existing study that covered 2006 to 2015. As such, we analyzed 422 studies from 2016 to 2020 and provided an updated perspective based on seven research questions, as well as a refined perspective on proprietary SECO and a deep understanding on the incident management process in this scenario. Results reveal that governance strategies aim to share knowledge, provide continuous innovation and increase competitive advantage in the market.;;;https://dl.acm.org/doi/10.1145/3466933.3466955;;;Software AND Engineering
Clio: a hardware-software co-designed disaggregated memory system;;;['Zhiyuan Guo', 'Yizhou Shan', 'Xuhao Luo', 'Yutong Huang', 'Yiying Zhang'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Memory disaggregation has attracted great attention recently because of its benefits in efficient memory utilization and ease of management. So far, memory disaggregation research has all taken one of two approaches: building/emulating memory nodes using regular servers or building them using raw memory devices with no processing power. The former incurs higher monetary cost and faces tail latency and scalability limitations, while the latter introduces performance, security, and management problems.  Server-based memory nodes and memory nodes with no processing power are two extreme approaches. We seek a sweet spot in the middle by proposing a hardware-based memory disaggregation solution that has the right amount of processing power at memory nodes. Furthermore, we take a clean-slate approach by starting from the requirements of memory disaggregation and designing a memory-disaggregation-native system.  We built Clio, a disaggregated memory system that virtualizes, protects, and manages disaggregated memory at hardware-based memory nodes. The Clio hardware includes a new virtual memory system, a customized network system, and a framework for computation offloading. In building Clio, we not only co-design OS functionalities, hardware architecture, and the network system, but also co-design compute nodes and memory nodes. Our FPGA prototype of Clio demonstrates that each memory node can achieve 100 Gbps throughput and an end-to-end latency of 2.5 µ s at median and 3.2 µ s at the 99th percentile. Clio also scales much better and has orders of magnitude lower tail latency than RDMA. It has 1.1× to 3.4× energy saving compared to CPU-based and SmartNIC-based disaggregated memory systems and is 2.7× faster than software-based SmartNIC solutions.;;;https://dl.acm.org/doi/10.1145/3503222.3507762;;;Software AND Engineering
An analysis of Monte Carlo simulations for forecasting software projects;;;['Pedro Miranda', 'J. Pascoal Faria', 'Filipe F. Correia', 'Ahmed Fares', 'Ricardo Graça', 'João Mendes Moreira'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Forecasts of the effort or delivery date can play an important role in managing software projects, but the estimates provided by development teams are often inaccurate and time-consuming to produce. This is not surprising given the uncertainty that underlies this activity. This work studies the use of Monte Carlo simulations for generating forecasts based on project historical data. We have designed and run experiments comparing these forecasts against what happened in practice and to estimates provided by developers, when available. Comparisons were made based on the mean magnitude of relative error (MMRE). We did also analyze how the forecasting accuracy varies with the amount of work to be forecasted and the amount of historical data used. To minimize the requirements on input data, delivery date forecasts for a set of user stories were computed based on takt time of past stories (time elapsed between the completion of consecutive stories); effort forecasts were computed based on full-time equivalent (FTE) hours allocated to the implementation of past stories. The MMRE of delivery date forecasting was 32% in a set of 10 runs (for different projects) of Monte Carlo simulation based on takt time. The MMRE of effort forecasting was 20% in a set of 5 runs of Monte Carlo simulation based on FTE allocation, much smaller than the MMRE of 134% of developers' estimates. A better forecasting accuracy was obtained when the number of historical data points was 20 or higher. These results suggest that Monte Carlo simulations may be used in practice for delivery date and effort forecasting in agile projects, after a few initial sprints.;;;https://dl.acm.org/doi/10.1145/3412841.3442030;;;Software AND Engineering
Hierarchical Software Design Methodology for High Concurrency and Fine-Grained Permission Control Scenarios;;;['Yuan Han', 'Qingqing Song', 'Xinquan Huang', 'Jie Yin'];;;August 2021;;;CCRIS '21: Proceedings of the 2021 2nd International Conference on Control, Robotics and Intelligent System;;;Because complex software usually faces high concurrency and complex permission control scenarios, and there are problems with low code reuse rate and chaotic function module structure in the development process of its access control module, so providing software design methodology for such scenarios is helpful to improve software productivity and software quality play an important role. This paper proposes a hierarchical software design methodology for the development of complex software under high concurrency and fine-grained permission control scenarios. The software design methodology divides the hierarchical structure according to the characteristics of the access control process, and provides support for fine-grained control and multi-level control of permissions. For high concurrency scenarios, a cache management layer is added to improve the efficiency of the access control process. According to the actual needs of software development, the specific levels in the software design methodology are divided. By decoupling the user status detection, user status verification and permission authentication in the access control process, the support of this software design methodology in different framework environments is guaranteed and the security risks caused by the high coupling between frameworks are reduced. Through a series of 0-500K concurrent test experiments, the performance data of different frameworks in the same scenario is obtained, which provides users with a reference when implementing the software design methodology proposed in this article, enable it to choose a framework for better performance depending on the scenario it faces.;;;https://dl.acm.org/doi/10.1145/3483845.3483867;;;Software AND Engineering
A Recommender System based on Intuitionistic Fuzzy Sets for Software Requirements Prioritization;;;['Dimitrios Tzimos', 'Vassilis C. Gerogiannis', 'Le Hoang Son', 'Anthony Karageorgos'];;;November 2021;;;PCI '21: Proceedings of the 25th Pan-Hellenic Conference on Informatics;;;Requirements Prioritization (RP) is an important activity in requirements engineering aiming to give priority and order to requirements for implementation in the next version of a software project. RP is applied iteratively, according to various prioritization criteria, by multiple project stakeholders who may have different roles, needs and knowledge. In large-scale software projects, where the set of candidate requirements is large, stakeholders may not be interested in evaluating all requirements and they may not have the expertise, the time or the willingness to consider all candidate requirements. Recommender Systems (RS) can be a useful solution to information overload when stakeholders have to evaluate a large number of alternatives. During evaluation of requirements, it is often practically impossible to ensure that all stakeholders have complete knowledge on all requirements. Thus, stakeholders may show some degree of uncertainty and hesitation, as it is difficult to precisely evaluate each requirement according to each prioritization criterion. The intuitionistic Fuzzy Sets (IFSs) are an extension of fuzzy sets which can deal with stakeholders’ uncertainty and hesitation regarding the prioritization criteria importance and requirements ratings. The aim of this paper is to present an RS approach based on the collaborative filtering technique to effectively provide suggestions to stakeholders while prioritizing requirements. The proposed RS approach is tested using a publicly available large dataset of software requirements and the results show an improved performance.;;;https://dl.acm.org/doi/10.1145/3503823.3503908;;;Software AND Engineering
Software-hardware co-optimization for computational chemistry on superconducting quantum processors;;;['Gushu Li', 'Yunong Shi', 'Ali Javadi-Abhari'];;;June 2021;;;ISCA '21: Proceedings of the 48th Annual International Symposium on Computer Architecture;;;Computational chemistry is the leading application to demonstrate the advantage of quantum computing in the near term. However, large-scale simulation of chemical systems on quantum computers is currently hindered due to a mismatch between the computational resource needs of the program and those available in today's technology. In this paper we argue that significant new optimizations can be discovered by co-designing the application, compiler, and hardware. We show that multiple optimization objectives can be coordinated through the key abstraction layer of Pauli strings, which are the basic building blocks of computational chemistry programs. In particular, we leverage Pauli strings to identify critical program components that can be used to compress program size with minimal loss of accuracy. We also leverage the structure of Pauli string simulation circuits to tailor a novel hardware architecture and compiler, leading to significant execution overhead reduction by up to 99%. While exploiting the high-level domain knowledge reveals significant optimization opportunities, our hardware/software framework is not tied to a particular program instance and can accommodate the full family of computational chemistry problems with such structure. We believe the co-design lessons of this study can be extended to other domains and hardware technologies to hasten the onset of quantum advantage.;;;https://dl.acm.org/doi/10.1109/ISCA52012.2021.00070;;;Software AND Engineering
Developing an Inspection Checklist for the Adequacy Assessment of Software Systems to Quality Attributes of the Brazilian General Data Protection Law: An Initial Proposal;;;['João Mendes', 'Davi Viana', 'Luis Rivero'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The General Data Protection Law (LGPD) in Brazil was created with the goal of regulating how associations collect, transmit and store users’ personal data. Although it became applicable in 2020, several software development teams still don’t know what quality attributes are necessary for a system to comply with such law and to avoid legal and monetary penalties. Furthermore, there are still no checklists for verifying quality criteria related to the Brazilian LGPD. In this paper, an inspection checklist is proposed to evaluate software systems regarding their adherence to the Brazilian LGPD. We identified the attributes from papers describing the impact of the law in the development of Brazilian software systems; and from papers describing existing techniques and quality attributes for evaluating the adherence of software systems to laws from other countries. The final evaluation checklist contains a total of 52 attributes distributed in evaluation categories, such as: transparency, legal rights, security, contentment and responsibility. To assess the proposed checklist, we applied the checklist to evaluate a government web application. The initial results indicate that the current version of the checklist allows the identification of problems regarding the adherence of software systems to the Brazilian LGPD.;;;https://dl.acm.org/doi/10.1145/3474624.3477069;;;Software AND Engineering
Integration verification across software and hardware for a simple embedded system;;;['Andres Erbsen', 'Samuel Gruetter', 'Joonwon Choi', 'Clark Wood', 'Adam Chlipala'];;;June 2021;;;PLDI 2021: Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation;;;The interfaces between layers of a system are susceptible to bugs if developers of adjacent layers proceed under subtly different assumptions. Formal verification of two layers against the same formal model of the interface between them can be used to shake out these bugs. Doing so for every interface in the system can, in principle, yield unparalleled assurance of the correctness and security of the system as a whole. However, there have been remarkably few efforts that carry out this exercise, and all of them have simplified the task by restricting interactivity of the application, inventing new simplified instruction sets, and using unrealistic input and output mechanisms. We report on the first verification of a realistic embedded system, with its application software, device drivers, compiler, and RISC-V processor represented inside the Coq proof assistant as one mathematical object, with a machine-checked proof of functional correctness. A key challenge is structuring the proof modularly, so that further refinement of the components or expansion of the system can proceed without revisiting the rest of the system.;;;https://dl.acm.org/doi/10.1145/3453483.3454065;;;Software AND Engineering
Research on Calculation Method of Software Service Risk Occurrence Probability Based on Markov Chain Theory;;;['Xiaohui Jia', 'Shuyang Qu', 'Tilei Gao', 'Bingfu Mou'];;;November 2021;;;AISS '21: Proceedings of the 3rd International Conference on Advanced Information Science and System;;;The new computing models represented by cloud computing, Internet of things, big data and artificial intelligence put forward higher requirements for the trustworthiness of software services. Software service risk occurrence probability is one of the key indicators of software service trustworthiness. The trustworthiness of software services with low risk occurrence probability is not necessarily high, but the trustworthiness of software services with high risk occurrence probability is certainly low. In order to solve the screening problem of software services with high risk probability in the process of software service selection, this paper proposes a software service risk probability calculation method based on Markov Chain theory, and verifies the effectiveness and feasibility of the proposed method through a case study.;;;https://dl.acm.org/doi/10.1145/3503047.3503097;;;Software AND Engineering
Business Model for Brazilian Indie Game Studios in Game Software Ecosystems;;;['Bruno Xavier', 'Davi Viana', 'Rodrigo Santos'];;;June 2021;;;SBSI '21: Proceedings of the XVII Brazilian Symposium on Information Systems;;;Context: The Software Ecosystem (SECO) strategy dominates the digital game industry. The leading game companies adopted SECO dynamics, forcing external actors (e.g., game studios) to adapt to a highly competitive scenario. Objective: Considering the significant growth of the Brazilian digital games industry in the last years, this study aims to present and evaluate a business model proposed for the independent Brazilian game studios immersed in the Game SECO (GSECO) context. Method: We explained the proposed model and reported on 15 online interviews to capture comments and suggestions. Three researchers applied the Grounded Theory (GT) procedures to extract actions to improve the business model. Results: 25 suggestions to improve the proposed business model emerged. Finally, we use the business model concepts and subdomains to both define the suggestions to be adopted and identify opportunities for future work. Conclusion: The first version of the business model for independent studios in GSECO reached a high level of relevance in its first evaluation. Some interviewees highlighted the differential of the model in directing the construction of a digital game business contextualized in the Brazilian scenario and how the tool can directly contribute to the maturity of the industry. As future work, we identified the need to expand the model for all subdomains and new evaluation with actors from different regions.;;;https://dl.acm.org/doi/10.1145/3466933.3466956;;;Software AND Engineering
Artifact for "GenTree: using decision trees to learn interactions for configurable software";;;['KimHao Nguyen', 'ThanhVu Nguyen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This document describes the artifact package accompanying the ICSE'21 paper "GenTree: Using Decision Trees to Learn Interactions for Configurable Software" [1]. The artifact includes GenTree source code, pre-built binaries, benchmark program specifications, and scripts to replicate the data presented in the paper. Furthermore, GenTree is applicable to new programs written in supported languages (C, C++, Python, Perl, Ocaml), or can be extended to support new languages easily. GenTree implementation is highly modular and optimized, hence, it can also be used as a framework for developing and testing new interaction inference algorithms. We hope the artifact will be useful for researchers who are interested in interaction learning, especially iterative and data-driven approaches.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00076;;;Software AND Engineering
New life for cordless communication, old regrets for software projects;;;['Andrei Sukhov', 'Igor Sorokin', 'Doug Meil'];;;October 2021;;;Communications of the ACM;;;The Communications website, http://cacm.acm.org, features more than a dozen bloggers in the BLOG@CACM community. In each issue of Communications, we'll publish selected posts or excerpts.twitterFollow us on Twitter at http://twitter.com/blogCACMhttp://cacm.acm.org/blogs/blog-cacmAndrei Sukhov and Igor Sorokin ponder the potential benefits of DECT to the Internet of Things, while Doug Meil considers how software engineers should reflect on their accomplishments.;;;https://dl.acm.org/doi/10.1145/3479972;;;Software AND Engineering
A Formal Framework of Software Product Line Analyses;;;['Thiago Castro', 'Leopoldo Teixeira', 'Vander Alves', 'Sven Apel', 'Maxime Cordy', 'Rohit Gheyi'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;A number of product-line analysis approaches lift analyses such as type checking, model checking, and theorem proving from the level of single programs to the level of product lines. These approaches share concepts and mechanisms that suggest an unexplored potential for reuse of key analysis steps and properties, implementation, and verification efforts. Despite the availability of taxonomies synthesizing such approaches, there still remains the underlying problem of not being able to describe product-line analyses and their properties precisely and uniformly. We propose a formal framework that models product-line analyses in a compositional manner, providing an overall understanding of the space of family-based, feature-based, and product-based analysis strategies. It defines precisely how the different types of product-line analyses compose and inter-relate. To ensure soundness, we formalize the framework, providing mechanized specification and proofs of key concepts and properties of the individual analyses. The formalization provides unambiguous definitions of domain terminology and assumptions as well as solid evidence of key properties based on rigorous formal proofs. To qualitatively assess the generality of the framework, we discuss to what extent it describes five representative product-line analyses targeting the following properties: safety, performance, dataflow facts, security, and functional program properties.;;;https://dl.acm.org/doi/10.1145/3442389;;;Software AND Engineering
A Practical Approach into Some Software to Create Videos about Historical Figures to Enhance the Teaching Quality of Topic “Counter-Offensive on the Southwestern Border (1975-1979)” At FPT Education;;;['Hue Thi Pham', 'Kieu Tien Thi Nguyen'];;;July 2021;;;ICEMT '21: Proceedings of the 5th International Conference on Education and Multimedia Technology;;;In the 21st century, the problem of innovating teaching and learning methods and applying information technology in the process of organizing training is an objective and urgent requirement both in the short and long term. This is a decisive factor in improving the quality of education and training in general and teaching national history in particular. Fortunately, the available video creation software (Biteable, ProShow Gold, Camtasia) are effective support tools in preparing electronic lesson plans. The application of the mentioned software to create documentaries about historical figures is an appropriate choice in the 4.0 era. Particularly, the application of these software in teaching about “Counter-offensive on the Southwestern border (1975-1979)” (also known as Cambodian-Vietnamese war) will create a new step for the problem of teaching and learning history. History teaching and learning activities at FPT educational institution are improved compared to traditional methods.;;;https://dl.acm.org/doi/10.1145/3481056.3481097;;;Software AND Engineering
Collaborative Platform for Supervision and Advice of Agricultural Engineer to Farmers Thanks to IoT and WebRTC;;;['Ousmane Racine Ly', 'Keba Gueye', 'Samuel Ouya', 'Gervais Mendy'];;;July 2021;;;ICCCM '21: Proceedings of the 9th International Conference on Computer and Communications Management;;;In Senegal, agriculture is a very important part of the economic fabric. Farmers are confronted with numerous problems of insect attacks of all kinds, diseases that affect plants and soils that vary from year to year. However, there is only one school of agricultural engineering, hence the lack of experts to advise and help farmers. An agricultural engineer has under his supervision a large number of farmers. In this article we propose a platform coupled with an IoT device. This platform developed with NodeJs uses WebRTC for communication between users and the Web of Things to receive and visualize field data in real time. Thus, while being in video communication with the farmer, the agronomist has an interface allowing him to see the data from the sensors placed in the fields. These sensors will inform the state of the soil. All these data will allow the agronomist to diagnose the situation efficiently and to recommend an adequate treatment for the good performance of the crop. The solution allows a greater efficiency of the agronomists in front of the extent of the zones which they must cover. Indeed, the agronomist, whatever his location, can intervene remotely;;;https://dl.acm.org/doi/10.1145/3479162.3479184;;;Software AND Engineering
Persistent software transactional memory in Haskell;;;['Nicolas Krauter', 'Patrick Raaf', 'Peter Braam', 'Reza Salkhordeh', 'Sebastian Erdweg', 'André Brinkmann'];;;August 2021;;;Proceedings of the ACM on Programming Languages;;;Emerging persistent memory in commodity hardware allows byte-granular accesses to persistent state at memory speeds. However, to prevent inconsistent state in persistent memory due to unexpected system failures, different write-semantics are required compared to volatile memory. Transaction-based library solutions for persistent memory facilitate the atomic modification of persistent data in languages where memory is explicitly managed by the programmer, such as C/C++. For languages that provide extended capabilities like automatic memory management, a more native integration into the language is needed to maintain the high level of memory abstraction. It is shown in this paper how persistent software transactional memory (PSTM) can be tightly integrated into the runtime system of Haskell to atomically manage values of persistent transactional data types. PSTM has a clear interface and semantics extending that of software transactional memory (STM). Its integration with the language’s memory management retains features like garbage collection and allocation strategies, and is fully compatible with Haskell's lazy execution model. Our PSTM implementation demonstrates competitive performance with low level libraries and trivial portability of existing STM libraries to PSTM. The implementation allows further interesting use cases, such as persistent memoization and persistent Haskell expressions.;;;https://dl.acm.org/doi/10.1145/3473568;;;Software AND Engineering
Measuring and Modeling Group Dynamics in Open-Source Software Development: A Tensor Decomposition Approach;;;['Thomas Bock', 'Angelika Schmid', 'Sven Apel'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Many open-source software projects depend on a few core developers, who take over both the bulk of coordination and programming tasks. They are supported by peripheral developers, who contribute either via discussions or programming tasks, often for a limited time. It is unclear what role these peripheral developers play in the programming and communication efforts, as well as the temporary task-related sub-groups in the projects. We mine code-repository data and mailing-list discussions to model the relationships and contributions of developers in a social network and devise a method to analyze the temporal collaboration structures in communication and programming, learning about the strength and stability of social sub-groups in open-source software projects. Our method uses multi-modal social networks on a series of time windows. Previous work has reduced the network structure representing developer collaboration to networks with only one type of interaction, which impedes the simultaneous analysis of more than one type of interaction. We use both communication and version-control data of open-source software projects and model different types of interaction over time. To demonstrate the practicability of our measurement and analysis method, we investigate 10 substantial and popular open-source software projects and show that, if sub-groups evolve, modeling these sub-groups helps predict the future evolution of interaction levels of programmers and groups of developers. Our method allows maintainers and other stakeholders of open-source software projects to assess instabilities and organizational changes in developer interaction and can be applied to different use cases in organizational analysis, such as understanding the dynamics of a specific incident or discussion.;;;https://dl.acm.org/doi/10.1145/3473139;;;Software AND Engineering
Text classification on software requirements specifications using transformer models;;;['Derya Kici', 'Aysun Bozanta', 'Mucahit Cevik', 'Devang Parikh', 'Ayşe Başar'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Text classification in Software Requirements Specifications (SRS) documents is an essential task for various purposes including automatically extracting requirements and their types as well as identification of duplicate or conflicting information, which all contribute to avoiding potential issues in the later stages of the software development life cycle. While a variety of machine learning approaches have been considered for text classification over SRS documents, many of these fail to provide adequate performance as they often ignore the meaning of software artifacts or integrate domain knowledge for the classification task. Recent advances in deep learning methodology have significantly contributed to Natural Language Processing (NLP) and text classification. One of the main challenges in using deep learning models for various NLP tasks in the software engineering domain is the scarcity of labeled textual data. In addition, even with sufficient data, training from the scratch still requires significant training time and computational resources. Transfer learning is a novel approach that proposes a solution to such reservations by providing pre-trained models that enable fine-tuning with the customized data. In this research, we conduct an empirical analysis on multi-class text classification over SRS documents using different pre-trained transformer models including BERT, DistilBERT, Roberta, AlBERT, and XLNet, and compare their performance. We test the performance of these models using three SRS datasets: DOORS, NFR-PROMISE, and PURE. Our numerical study shows that the transformer models are able to generate highly accurate results to classify all categories except Priority of the requirements. While all models provide a 80% or higher accuracy for other classification tasks, the accuracy of the models to classify the Priority does not exceed 60%.;;;https://dl.acm.org/doi/10.5555/3507788.3507811;;;Software AND Engineering
RARE: evolutionary feature engineering for rare-variant bin discovery;;;['Satvik Dasariraju', 'Ryan J. Urbanowicz'];;;July 2021;;;GECCO '21: Proceedings of the Genetic and Evolutionary Computation Conference Companion;;;Features with rare states, such as rare genetic variants, pose a significant challenge for both statistical and machine learning analyses due to limited detection power and uncertainty surrounding the nature of their role (e.g., additive, heterogeneous, or epistatic) in predicting outcomes such as disease phenotype. Rare variant 'bins' (RVBs) hold the potential to increase association detection power. However, previously proposed binning approaches relied on prior-knowledge assumptions, instead of data-driven techniques, and ignored the potential for multivariate interactions. We present the Relevant Association Rare-variant-bin Evolver (RARE), the first evolutionary algorithm for automatically constructing and evaluating RVBs with either univariate or epistatic associations. We evaluate RARE's ability to correctly bin simulated rare-variant associations over a variety of algorithmic and dataset scenarios. Specifically, we examine (1) ability to detect RVBs of univariate effect (with or without noise), (2) using fixed vs. adaptable bins sizes, (3) employing expert knowledge to initialize bins, and (4) ability to detect RVBs interacting with a separate common variant. We present preliminary results demonstrating the feasibility, efficacy, and limitations of this proposed rare-variant feature engineering algorithm.;;;https://dl.acm.org/doi/10.1145/3449726.3463174;;;Software AND Engineering
Indirect Multi-Mapping for Burstiness Management in Software Defined Networks;;;['Xuwei Yang', 'Hongli Xu', 'Shigang Chen', 'He Huang'];;;None;;;IEEE/ACM Transactions on Networking;;;Large software defined networks use a cluster of distributed controllers to process flow requests from a massive number of switches. To cope with traffic dynamics, this paper studies a new problem of how to improve the residual capacity available at the controllers to handle request bursts experienced at the switches. While the total residual capacity is a constant under a given total capacity of all controllers and a given total workload from all switches, this paper considers the residual capacity available to each individual switch, which depends on how the switches are mapped to the controllers for management. We focus on how to <italic>maximize the minimum residual capacity available to any switch</italic>. The prior work either provides poor residual capacity or incurs heavy synchronization overhead by simulation results. This paper proposes a new method called <italic>indirect multi-mapping</italic> that achieves both high residual capacity and low synchronization cost. We formally define a non-linear integer optimization problem for max-min residual capacity under indirect multi-mapping. We then approximate the problem as two sub-problems: switch-controller mapping selection and weight assignment for each switch-controller mapping. We solve these sub-problems and formally analyze their approximate factor. We implement the proposed solution on an SDN testbed for experimental studies and use simulations for large-scale investigation. Our evaluation shows that indirect multi-mapping improves the minimum residual capacity by 49.8&#x0025; on average and reduces the synchronization cost by 41.9-60.3&#x0025; on average when compared with the alternatives.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3078132;;;Software AND Engineering
From Blackboard to the Office: A Look Into How Practitioners Perceive Software Testing Education;;;['Luana Martins', 'Vinicius Brito', 'Daniela Feitosa', 'Larissa Rocha', 'Heitor Costa', 'Ivan Machado'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;The teaching-learning process may require specific pedagogical approaches to establish a relationship with industry practices. Recently, some studies investigated the educators’ perspectives and the undergraduate courses curriculum to identify potential weaknesses and solutions for the software testing teaching process. However, it is still unclear how the practitioners evaluate the acquisition of knowledge about software testing in undergraduate courses. This study carried out an expert survey with 68 newly graduated practitioners to determine what the industry expects from them and what they learned in academia. The yielded results indicated that those practitioners learned at a similar rate as others with a long industry experience. Also, they studied less than half of the 35 software testing topics collected in the survey and took industry-backed extracurricular courses to complement their learning. Additionally, our findings point out a set of implications for future research, as the respondents’ learning difficulties (e.g., lack of learning sources) and the gap between academic education and industry expectations (e.g., certifications).;;;https://dl.acm.org/doi/10.1145/3463274.3463338;;;Software AND Engineering
Enabling Software Resilience in GPGPU Applications via Partial Thread Protection;;;['Lishan Yang', 'Bin Nie', 'Adwait Jog', 'Evgenia Smirni'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Graphics Processing Units (GPUs) are widely used by various applications in a broad variety of fields to accelerate their computation but remain susceptible to transient hardware faults (soft errors) that can easily compromise application output. By taking advantage of a general purpose GPU application hierarchical organization in threads, warps, and cooperative thread arrays, we propose a methodology that identifies the resilience of threads and aims to map threads with the same resilience characteristics to the same warp. This allows engaging partial replication mechanisms for error detection/correction at the warp level. By exploring 12 benchmarks (17 kernels) from 4 benchmark suites, we illustrate that threads can be remapped into reliable or unreliable warps with only 1.63% introduced overhead (on average), and then enable selective protection via replication to those groups of threads that truly need it. Furthermore, we show that thread remapping to different warps does not sacrifice application performance. We show how this remapping facilitates warp replication for error detection and/or correction and achieves an average reduction of 20.61% and 27.15% execution cycles, respectively comparing to standard duplication/triplication.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00114;;;Software AND Engineering
Detecting Malicious Switches for a Secure Software-defined Tactile Internet;;;['Bin Yuan', 'Chen Lin', 'Deqing Zou', 'Laurence Tianruo Yang', 'Hai Jin'];;;None;;;ACM Transactions on Internet Technology;;;The rapid development of the Internet of Things has led to demand for high-speed data transformation. Serving this purpose is the Tactile Internet, which facilitates data transfer in extra-low latency. In particular, a Tactile Internet based on software-defined networking (SDN) has been broadly deployed because of the proven benefits of SDN in flexible and programmable network management. However, the vulnerabilities of SDN also threaten the security of the Tactile Internet. Specifically, an SDN controller relies on the network status (provided by the underlying switches) to make network decisions, e.g., calculating a routing path to deliver data in the Tactile Internet. Hence, the attackers can compromise the switches to jeopardize the SDN and further attack Tactile Internet systems. For example, an attacker can compromise switches to launch distributed denial-of-service attacks to overwhelm the SDN controller, which will disrupt all the applications in the Tactile Internet. In pursuit of a more secure Tactile Internet, the problem of abnormal SDN switches in the Tactile Internet is analyzed in this article, including the cause of abnormal switches and their influences on different network layers. Then we propose an approach that leverages the messages sent by all switches to identify abnormal switches, which adopts a linear structure to store historical messages at a relatively low cost. By mapping each flow message to the flow establishment model, our method can effectively identify malicious SDN switches in the Tactile Internet and thus enhance its security.;;;https://dl.acm.org/doi/10.1145/3415146;;;Software AND Engineering
Software Hint-Driven Data Management for Hybrid Memory in Mobile Systems;;;['Fei Wen', 'Mian Qin', 'Paul Gratz', 'Narasimha Reddy'];;;None;;;ACM Transactions on Embedded Computing Systems;;;Hybrid memory systems, comprised of emerging non-volatile memory (NVM) and DRAM, have been proposed to address the growing memory demand of current mobile applications. Recently emerging NVM technologies, such as phase-change memories (PCM), memristor, and 3D XPoint, have higher capacity density, minimal static power consumption and lower cost per GB. However, NVM has longer access latency and limited write endurance as opposed to DRAM. The different characteristics of distinct memory classes render a new challenge for memory system design.Ideally, pages should be placed or migrated between the two types of memories according to the data objects’ access properties. Prior system software approaches exploit the program information from OS but at the cost of high software latency incurred by related kernel processes. Hardware approaches can avoid these latencies, however, hardware’s vision is constrained to a short time window of recent memory requests, due to the limited on-chip resources.In this work, we propose OpenMem: a hardware-software cooperative approach that combines the execution time advantages of pure hardware approaches with the data object properties in a global scope. First, we built a hardware-based memory manager unit (HMMU) that can learn the short-term access patterns by online profiling, and execute data migration efficiently. Then, we built a heap memory manager for the heterogeneous memory systems that allows the programmer to directly customize each data object’s allocation to a favorable memory device within the presumed object life cycle. With the programmer’s hints guiding the data placement at allocation time, data objects with similar properties will be congregated to reduce unnecessary page migrations.We implemented the whole system on the FPGA board with embedded ARM processors. In testing under a set of benchmark applications from SPEC 2017 and PARSEC, experimental results show that OpenMem reduces 44.6% energy consumption with only a 16% performance degradation compared to the all-DRAM memory system. The amount of writes to the NVM is reduced by 14% versus the HMMU-only, extending the NVM device lifetime.;;;https://dl.acm.org/doi/10.1145/3494536;;;Software AND Engineering
A Ranking of Software Reliability Evaluation Based on Intuitionistic Fuzzy Aggregation Technique;;;['Linxin Chen', 'Riqing Chen', 'Jian Lin'];;;December 2021;;;ACAI '21: Proceedings of the 2021 4th International Conference on Algorithms, Computing and Artificial Intelligence;;;During the software life cycle, software reliability is limited by various uncertain factors, and relevant factors need to be aggregated for reliability evaluation. The influence of these factors on reliability is often determined by engineering experience and subjective judgment, which inevitably leads to subjectivity and vague, and fuzzy set theory is an effective method to deal with uncertain information. The research in this paper aims to help software development organizations complete the software engineering evaluations that are the efficient measures of software reliability. The metrics value of each evaluation criterion was elicited through expert opinion and an aggregation technology is then developed for transforming attribute values into intuitionistic fuzzy numbers (IFNs) to obtain the collective evaluation of each alternative. Next, according to the intuitionistic fuzzy weighted averaging operator, the collective attribute values are aggregated to overall evaluations of alternatives. Finally, the ranking functions are applied to indicate the score degree and the rank of each alternative. A practical example is provided for applying software project reliability evaluation to demonstrate the practicality and effectiveness of the proposed method.;;;https://dl.acm.org/doi/10.1145/3508546.3508647;;;Software AND Engineering
Achieving Fast Loop-Free Updates With Ingress Port in Software-Defined Networks;;;['Guanhao Wu', 'Xiaofeng Gao', 'Jiaqi Zheng', 'Guihai Chen'];;;None;;;IEEE/ACM Transactions on Networking;;;Due to the distributed and asynchronous nature in data plane, the packets can be forwarded into a loop during routing updates. Software-Defined Networks (SDNs) enable a controller to schedule the update operations of routing rules in a loop-free manner. However, the existing rule replacement mechanism cannot give an efficient solution for large-scale update scenarios. In this paper, we make use of the ingress port field in forwarding rules to design a loop-free update scheme, Inport-Matching Update (IMU), for per-flow and destination-based unicast, which significantly improves efficiency of solving update scenarios and reduces update rounds. In both our proposed and previous mechanisms, a subproblem called Rule Replacement Scheduling (RRS) problem needs to be solved and we prove that the scale of RRS problem can be reduced at least by half. Moreover, we use the inclusion-exclusion principle to rigorously prove that the probability that an RRS problem under IMU has a trivial solution, i.e., one round, is always higher than 83.7&#x0025;, given a random per-flow unicast update scenario with ingress port rules. Experimental results show that our proposed Inport-Matching Update mechanism remarkably reduces the average number of rounds and runtime for solving the RRS problem compared to the existing rule replacement mechanism.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3068177;;;Software AND Engineering
Graph-based Fuzz Testing for Deep Learning Inference Engines;;;['Weisi Luo', 'Dong Chai', 'Xiaoyue Run', 'Jiang Wang', 'Chunrong Fang', 'Zhenyu Chen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;With the wide use of Deep Learning (DL) systems, academy and industry begin to pay attention to their quality. Testing is one of the major methods of quality assurance. However, existing testing techniques focus on the quality of DL models but lacks attention to the core underlying inference engines (i.e., frameworks and libraries). Inspired by the success stories of fuzz testing, we design a graph-based fuzz testing method to improve the quality of DL inference engines. This method is naturally followed by the graph structure of DL models. A novel operator-level coverage criterion based on graph theory is introduced and six different mutations are implemented to generate diversified DL models by exploring combinations of model structures, parameters, and data inputs. The Monte Carlo Tree Search (MCTS) is used to drive DL model generation without a training process. The experimental results show that the MCTS outperforms the random method in boosting operator-level coverage and detecting exceptions. Our method has discovered more than 40 different exceptions in three types of undesired behaviors: model conversion failure, inference failure, output comparison failure. The mutation strategies are useful to generate new valid test inputs, by up to an 8.2% more operator-level coverage on average and 8.6 more exceptions captured.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00037;;;Software AND Engineering
A methodology and framework for software memoization of functions;;;['Pedro Pinto', 'João M. P. Cardoso'];;;May 2021;;;CF '21: Proceedings of the 18th ACM International Conference on Computing Frontiers;;;Enhancing performance is crucial when developing applications for high-performance and embedded computing. It requires sophisticated techniques and in-depth knowledge of the application domain and target architecture. Typically, developers prioritize the application's functional requirements over extra-functional requirements. Thus, a large part of the optimization effort is shifted to performance engineers, who rely on manual effort, alongside many analysis and optimization tools that need integration. This paper focuses on memoization, which caches results of pure computations and retrieves them if a function is called with repeating arguments. We propose a methodology for allowing developers and performance engineers to apply memoization straightforwardly by automating code analysis, code transformations, and memoization-specific profiling. It helps developers with no optimization expertise to quickly set up memoization and, simultaneously, it provides performance engineers with highly customizable analysis and memoization. We provide a concrete implementation supported by a DSL, a source-to-source compiler, and a memoization framework. We evaluate the methodology and framework with publicly available benchmarks. We show how one can analyze applications to select functions with performance improvement potential, which the experiments reveal might be challenging to find, and improve some applications with minimal effort.;;;https://dl.acm.org/doi/10.1145/3457388.3458668;;;Software AND Engineering
Datasheets for Datasets help ML Engineers Notice and Understand Ethical Issues in Training Data;;;['Karen L. Boyd'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;The social computing community has demonstrated interest in the ethical issues sometimes produced by machine learning (ML) models, like violations of privacy, fairness, and accountability. This paper discovers what kinds of ethical considerations machine learning engineers recognize, how they build understanding, and what decisions they make when working with a real-world dataset. In particular, it illustrates ways in which Datasheets for Datasets, an accountability intervention designed to help engineers explore unfamiliar training data, scaffolds the process of issue discovery, understanding, and ethical decision-making. Participants were asked to review an intentionally ethically problematic dataset and asked to think aloud as they used it to solve a given ML problem. Out of 23 participants, 11 were given a Datasheet they could use while completing the task. Participants were ethically sensitive enough to identify concerns in the dataset; participants who had a Datasheet did open and refer to it; and those with Datasheets mentioned ethical issues during the think-aloud earlier and more often than than those without. The think-aloud protocol offered a grounded description of how participants recognized, understood, and made a decision about ethical problems in an unfamiliar dataset. The method used in this study can test other interventions that claim to encourage recognition, promote understanding, and support decision-making among technologists.;;;https://dl.acm.org/doi/10.1145/3479582;;;Software AND Engineering
A Systematic Framework to Identify Violations of Scenario-dependent Driving Rules in Autonomous Vehicle Software;;;['Qingzhao Zhang', 'David Ke Hong', 'Ze Zhang', 'Qi Alfred Chen', 'Scott Mahlke', 'Z. Morley Mao'];;;None;;;Proceedings of the ACM on Measurement and Analysis of Computing Systems;;;Safety compliance is paramount to the safe deployment of autonomous vehicle (AV) technologies in real-world transportation systems. As AVs will share road infrastructures with human drivers and pedestrians, it is an important requirement for AVs to obey standard driving rules. Existing AV software testing methods, including simulation and road testing, only check fundamental safety rules such as collision avoidance and safety distance. Scenario-dependent driving rules, including crosswalk and intersection rules, are more complicated because the expected driving behavior heavily depends on the surrounding circumstances. However, a testing framework is missing for checking scenario-dependent driving rules on various AV software.In this paper, we design and implement a systematic framework AVChecker for identifying violations of scenario-dependent driving rules in AV software using formal methods. AVChecker represents both the code logic of AV software and driving rules in proposed formal specifications and leverages satisfiability modulo theory (SMT) solvers to identify driving rule violations. To improve the automation of systematic rule-based checking, AVChecker provides a powerful user interface for writing driving rule specifications and applies static code analysis to extract rule-related code logic from the AV software codebase. Evaluations on two open-source AV software platforms, Baidu Apollo and Autoware, uncover 19 true violations out of 28 real-world driving rules covering crosswalks, traffic lights, stop signs, and intersections. Seven of the violations can lead to severe risks of a collision with pedestrians or blocking traffic.;;;https://dl.acm.org/doi/10.1145/3460082;;;Software AND Engineering
Artifact for enhancing genetic improvement of software with regression test selection;;;['Giovani Guizzo', 'Justyna Petke', 'Federica Sarro', 'Mark Harman'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;We present in this document the basic information needed to download, unpack, and then interpret the instructions we provide as requested in the ICSE 2021 Artifact Submission Guidelines. The artifact contains all the subject programs, scripts, tools, results, and a series of guidelines on how to use them.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00099;;;Software AND Engineering
Improving software fault prediction in imbalanced datasets using the under-sampling approach;;;['Golnoush Abaei', 'Wen Zhong Tah', 'Jason Zhern Wee Toh', 'Ethan Sheng Jian Hor'];;;February 2022;;;ICSCA '22: Proceedings of the 2022 11th International Conference on Software and Computer Applications;;;To make most software defect-free, a considerable amount of budget needs to be allocated to the software testing phase. As each day goes by, this budget slowly rises, as most software grows in size and complexity, which causes an issue for specific companies that cannot allocate sufficient resources towards testing. To tackle this, many researchers use machine learning methods to create software fault prediction models that can help detect defect-prone modules so that resources can be allocated more efficiently during testing. Although this is a feasible plan, the effectiveness of these machine learning models also depends on a few factors, such as the issue of data imbalance. There are many known techniques in class imbalance research that can potentially improve the performance of prediction models through processing the dataset before providing it as input. However, not all methods are compatible with one another. Before building a prediction model, the dataset undergoes the preprocessing step, the under-sampling, and the feature selection process. This study uses an under-sampling process by employing the Instance Hardness Threshold (IHT), which reduces the number of data present in the majority class. The performance of the proposed approach is evaluated based on eight machine learning algorithms by applying it to eight moderate and highly imbalanced NASA datasets. The results of our proposed approach show improvement in AUC and F1-Score by 33% and 26%, respectively, compared to other research work in some datasets.;;;https://dl.acm.org/doi/10.1145/3524304.3524310;;;Software AND Engineering
Research on Fuzzing Technology for JavaScript Engines;;;['Ye Tian', 'Xiaojun Qin', 'Shuitao Gan'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;JavaScript engine is the core component of web browsers, whose security issues are one of the critical aspects of the overall Web Eco-Security. Fuzzing technology, as an efficient software testing approach, has been widely applied to detecting vulnerabilities in different JavaScript engines, which is a security research hotspot at present. Based on systematical dissection of existing fuzzing methods, this paper reviews the development and technical ideas of JavaScript Engine Fuzzing combined with taxonomy, proposes a general framework of JavaScript Engine Fuzzing and analyzes the key techniques involved. Finally, we discuss the core issues that restrict efficiency in current research and present an outlook on the future trends of JavaScript Engine Fuzzing.;;;https://dl.acm.org/doi/10.1145/3487075.3487107;;;Software AND Engineering
PLD: fast FPGA compilation to make reconfigurable acceleration compatible with modern incremental refinement software development;;;['Yuanlong Xiao', 'Eric Micallef', 'Andrew Butt', 'Matthew Hofmann', 'Marc Alston', 'Matthew Goldsmith', 'Andrew Merczynski-Hait', 'André DeHon'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;FPGA-based accelerators are demonstrating significant absolute performance and energy efficiency compared with general-purpose CPUs. While FPGA computations can now be described in standard, programming languages, like C, development for FPGAs accelerators remains tedious and inaccessible to modern software engineers. Slow compiles (potentially taking tens of hours) inhibit the rapid, incremental refinement of designs that is the hallmark of modern software engineering. To address this issue, we introduce separate compilation and linkage into the FPGA design flow, providing faster design turns more familiar to software development. To realize this flow, we provide abstractions, compiler options, and compiler flow that allow the same C source code to be compiled to processor cores in seconds and to FPGA regions in minutes, providing the missing -O0 and -O1 options familiar in software development. This raises the FPGA programming level and standardizes the programming experience, bringing FPGA-based accelerators into a more familiar software platform ecosystem for software engineers.;;;https://dl.acm.org/doi/10.1145/3503222.3507740;;;Software AND Engineering
A Tale of Two Cities: Software Developers Working from Home during the COVID-19 Pandemic;;;['Denae Ford', 'Margaret-Anne Storey', 'Thomas Zimmermann', 'Christian Bird', 'Sonia Jaffe', 'Chandra Maddila', 'Jenna L. Butler', 'Brian Houck', 'Nachiappan Nagappan'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;The COVID-19 pandemic has shaken the world to its core and has provoked an overnight exodus of developers who normally worked in an office setting to working from home. The magnitude of this shift and the factors that have accompanied this new unplanned work setting go beyond what the software engineering community has previously understood to be remote work. To find out how developers and their productivity were affected, we distributed two surveys (with a combined total of 3,634 responses that answered all required questions) weeks apart to understand the presence and prevalence of the benefits, challenges, and opportunities to improve this special circumstance of remote work. From our thematic qualitative analysis and statistical quantitative analysis, we find that there is a dichotomy of developer experiences influenced by many different factors (that for some are a benefit, while for others a challenge). For example, a benefit for some was being close to family members but for others having family members share their working space and interrupting their focus, was a challenge. Our surveys led to powerful narratives from respondents and revealed the scale at which these experiences exist to provide insights as to how the future of (pandemic) remote work can evolve.;;;https://dl.acm.org/doi/10.1145/3487567;;;Software AND Engineering
Pioneering the tide and enabling the future: Research on the innovation of the training mode of new engineering talents in universities from the perspective of artificial intelligence;;;['Yunli Cheng', 'Min Huang', 'Yaohua Lei', 'Xueqin Tan'];;;June 2021;;;ICCIR '21: Proceedings of the 2021 1st International Conference on Control and Intelligent Robotics;;;With deep learning as the representative of machine learning algorithms, gradually achieved great success in the fields of machine vision and speech recognition. In addition, cloud computing and big data provide abundant and continuous big data resources, and artificial intelligence has entered an unprecedented period of rapid development. And is profoundly changing all sectors of society, the corresponding national requirements to carry out intelligent education in order to inspire artificial intelligence teaching application ideas, so as to promote the intelligent development of education and teaching. Artificial intelligence is gradually integrated into the field of education, providing new possibilities to meet the needs of teachers and students for high-quality learning resources, intelligent learning environment and personalized teaching. Under the background of the rapid development of artificial intelligence, a new round of technological change education will be led by intelligent education, inject new ideas into education and teaching, provide new methods and tools, drive the fundamental transformation of education and teaching mode, and promote the improvement of teaching effect. In such an era, the education field should follow the development of artificial intelligence, promote its own teaching reform and innovation, "use intelligent technology to accelerate the reform of talent training mode and teaching methods, and build a new education system that includes intelligent learning and interactive learning.";;;https://dl.acm.org/doi/10.1145/3473714.3473827;;;Software AND Engineering
Technical briefing: Hands-on session on the development of trustworthy AI software;;;['Ville Vakkuri', 'Kai-Kristian Kemell', 'Pekka Abrahamsson'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Following various real-world incidents involving both purely digital and cyber-physical Artificial Intelligence (AI) systems, AI Ethics has become a prominent topic of discussion in both research and practice, accompanied by various calls for trustworthy AI systems. Failures are often costly, and many of them stem from issues that could have been avoided during development. For example, AI ethics issues, such as data privacy are currently highly topical. However, implementing AI ethics in practice remains a challenge for organizations. Various guidelines have been published to aid companies in doing so, but these have not seen widespread adoption and may feel impractical. In this technical briefing, we discuss how to implement AI ethics. We showcase a method developed for this purpose, ECCOLA, which is based on academic research. ECCOLA is intended to make AI ethics more practical for developers in order to make it easier to incorporate into AI development to create trustworthy AI systems. It is a sprint-based and adaptive tool designed for agile development that facilitates reflection within the development team and helps developers make ethics into tangible product backlog items.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00142;;;Software AND Engineering
Software professionals' information needs in continuous integration and delivery;;;['Azeem Ahmad', 'Ola Leifler', 'Kristian Sandahl'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Continuous integration and delivery consolidate several activities, ranging from frequent code changes to compiling, building, testing, and deployment to customers. During these activities, software professionals seek additional information to perform the task at hand. Developers that spend a considerable amount of time and effort to identify such information can be distracted from doing productive work. By identifying the types of information that software professionals seek, we can better understand the processes, practices, and tools that are required to develop a quality product on time. A better understanding of the information needs of software practitioners has several benefits, such as staying competitive, increasing awareness of the issues that can hinder a timely release, and building a visualization tool that can help practitioners to address their information needs. We conducted a multiple-case holistic study with 5 different companies (34 unique participants) to identify information needs in continuous integration and delivery. This study attempts to capture the importance, frequency, required effort (e.g., sequence of actions required to collect information), current approach to handling, and associated stakeholders with respect to identified needs. We identified 27 information needs associated with different stakeholders (i.e., developers, testers, project managers, release team, and compliance authority). The identified needs were categorized as testing, code & commit, confidence, bug, and artifacts. We discussed whether the information needs were aligned with the tools used to address them.;;;https://dl.acm.org/doi/10.1145/3412841.3442026;;;Software AND Engineering
SATune: a study-driven auto-tuning approach for configurable software verification tools;;;['Ugur Koc', 'Austin Mordahl', 'Shiyi Wei', 'Jeffrey S. Foster', 'Adam A. Porter'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Many program verification tools can be customized via run-time configuration options that trade off performance, precision, and soundness. However, in practice, users often run tools under their default configurations, because understanding these tradeoffs requires significant expertise. In this paper, we ask how well a single, default configuration can work in general, and we propose SATUNE, a novel tool for automatically configuring program verification tools for given target programs. To answer our question, we gathered a dataset that runs four well-known program verification tools against a range of C and Java benchmarks, with results labeled as correct, incorrect, or inconclusive (e.g., timeout). Examining the dataset, we find there is generally no one-size-fits-all best configuration. Moreover, a statistical analysis shows that many individual configuration options do not have simple tradeoffs: they can be better or worse depending on the program. Motivated by these results, we developed SATUNE, which constructs configurations using a meta-heuristic search. The search is guided by a surrogate fitness function trained on our dataset. We compare the performance of SATUNE to three baselines: a single configuration with the most correct results in our dataset; the most precise configuration followed by the most correct configuration (if needed); and the most precise configuration followed by random search (also if needed). We find that SATUNE outperforms these approaches by completing more correct tasks with high precision. In summary, our work shows that good configurations for verification tools are not simple to find, and SATUNE takes an important step towards automating the process of finding them.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678761;;;Software AND Engineering
Machine learning steered symbolic execution framework for complex software code;;;['Lei Bu', 'Yongjuan Liang', 'Zhunyi Xie', 'Hong Qian', 'Yi-Qi Hu', 'Yang Yu', 'Xin Chen', 'Xuandong Li'];;;None;;;Formal Aspects of Computing;;;AbstractDuring program traversing, symbolic execution collects path
conditions and feeds them to a constraint solver to obtain feasible
solutions. However, complex path conditions, like nonlinear
constraints, which widely appear in programs, are hard to be handled
efficiently by the existing solvers. In this paper, we adapt the
classical symbolic execution framework with a machine learning
approach for constraint satisfaction. The approach samples and
learns from different solutions to identify potentially feasible
area. This sampling-learning style solving can be applied in
different class of complex problems easily. Therefore, incorporating
this approach, our framework, MLBSE, supports the symbolic
execution of not only simple linear path conditions, but also
nonlinear arithmetic operations, and even black-box function calls
of library methods. Meanwhile, thanks to the theoretical foundation
of the machine learning based approach, when the solver fails to
solve a path condition, we can have an estimation of the confidence
in the satisfiability (ECS) of the problem to give users insights
about how the problem is analyzed and whether they could ultimately
find a solution. We implement MLBSE on the basis of Symbolic
Path Finder (SPF) into a fully automatic Java symbolic execution
engine. Users can feed their code to MLBSE directly, which is
very convenient to use. To evaluate its performance, 22 real case
programs are used as the benchmarks for MLBSE to generate test
cases, which involve a total number of 1042 methods that are full of
nonlinear operations, floating-point arithmetic as well as native
method calls. Experiment results show that the coverage achieved by
MLBSE is much higher than the state-of-the-art tools.;;;https://dl.acm.org/doi/10.1007/s00165-021-00538-3;;;Software AND Engineering
A Lightware Attribute Based Access Control Mechanism in Software Defined Internet of Things;;;['Xu Han', 'Xincheng Yan', 'Na Zhou', 'Zhihong Jiang', 'Ranshuang Li', 'Ying Liu'];;;December 2021;;;ACM ICEA '21: Proceedings of the 2021 ACM International Conference on Intelligent Computing and its Emerging Applications;;;Software-defined Internet of Things (SD-IoT) is a hot topic in the next generation of network technology. However, the diverse online services have led to large-scale service connections, which poses a challenge to the carrying capacity of currently access control mechanisms. Therefore, this paper proposes a lightweight access control mechanism located in the data plane based on the flexibility of programmable switches. First, we analyzed the massive connectivity and openness requirements of SD-IoT, and determined the key indicators for evaluating the access control performance. Second, we designed and implemented attribute-based access control on the data plane, and optimized the authentication period on the user side based on the network status. Third, we evaluated the proposed mechanism through reasonable experiments, and the results showed that our solution can achieve low-latency service authorization.;;;https://dl.acm.org/doi/10.1145/3491396.3506533;;;Software AND Engineering
Network Performance Influences of Software-defined Networks on Micro-service Architectures;;;['Axel Busch', 'Martin Kammerer'];;;April 2021;;;ICPE '21: Proceedings of the ACM/SPEC International Conference on Performance Engineering;;;Modern business applications are increasingly developed as micro-services and deployed in the cloud. Due to many components involved micro-services need a flexible and high-performance network infrastructure. To ensure highly available and high performance applications, operators are increasingly relying on cloud service platforms such as the OpenShift Container Platform on Z. In such environments modern software-defined network technologies such as Open vSwitch (OVS) are used. However, the impact of their architecture on network performance has not yet been sufficiently researched although networking performance is particularly critical for the quality of the service. In this paper, we analyse the impact of the OVS pipeline and selected OVS operations in detail. We define different scenarios used in the industry and analyse the performance of different OVS configurations using an IBM z14 mainframe system. Our analysis showed the OVS pipeline and its operations can affect network performance by up to factor 3. Our results show that even the use of virtual switches such as OVS, network performance can be significantly improved by optimizing the OVS pipeline architecture.;;;https://dl.acm.org/doi/10.1145/3427921.3450236;;;Software AND Engineering
Implementation of GPS Tracking Route Software of SAGIP Application as Conventional Emergency Response;;;['Aira Laurencia T. Navarro', 'Dave Rafazel D. Diez', 'Meizhen Osmund L. Andres', 'Pierce Denver Dayot', 'Michael N. Young'];;;September 2021;;;ICIBE '21: Proceedings of the 7th International Conference on Industrial and Business Engineering;;;Safety is essential in every individual's life. Incidents may occur no matter where and no matter what time it is of the day. In this study, researchers will discuss the common problems of safety response of different departments for every emergency occurring. Through various related literature, the researchers propose a way to resolve issues in emergency response utilizing technology. The proponents deployed survey questionnaires for the target audience of the proposed project for data gathering purposes. Structural Equation Modelling was used to interpret the correlation between the four factors to display eligible information regarding the product's refinement. This was achieved through the significant number of 268 respondents. Upon doing so, promising results showed that the proposed project would be an effective way to provide efficiency for emergency response and safety assurance for civilians..;;;https://dl.acm.org/doi/10.1145/3494583.3494596;;;Software AND Engineering
Retrieval from software libraries for bug localization: A comparative study of generic and composite text models - A Retrospective;;;['Shivani Rao', 'Avinash Kak'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;This retrospective on our 2011 MSR publication starts with the research milieu that led to the work reported in our paper. We brie y review the competing ideas of a decade ago that could be applied to solving the problem of identifying the les in a software library related to a query. We were especially interested in nding out if the more complex text retrieval methods of that time would be e ective in the software context. A surprising conclusion of our paper was that the reality was exactly the opposite: the more traditional simpler methods outperformed the complex methods. In addition to this surprising result, our paper was also the rst to report what was considered at that time a large-scale quantitative evaluation of the IR-based approaches to automatic bug localization. Over the years, such quantitative evaluations have become the norm. We believe that these contributions were largely responsible for the popularity of this paper in the research literature.;;;https://dl.acm.org/doi/10.1145/3468744.3468755;;;Software AND Engineering
Towards cyber-resilient telecontrol commands using software-defined networking;;;['Anthony Kemmeugne', 'Amir Abiri Jahromi', 'Deepa Kundur', 'Marthe Kassouf'];;;May 2021;;;MSCPES '21: Proceedings of the 9th Workshop on Modeling and Simulation of Cyber-Physical Energy Systems;;;Cybersecurity enhancement of power systems has become one of the main objectives of utility managers and regulatory agencies because of the increasing number of cyberattacks against critical infrastructures. In this paper, we investigate the application of software-defined networking for improving the cyber-resilience of power systems in the presence of cyberattacks using false telecontrol commands. It is first demonstrated that cyberattackers can use false telecontrol commands to separate a power plant from a power grid or trip a major transmission line. Next, it is shown that software-defined networking can significantly enhance the cyber-resilience of power systems in the presence of cyberattacks using false telecontrol commands compared to legacy communication networks. This is because the source, destination and protocol of telecontrol commands can be examined and verified in software-defined networking before communication packet forwarding actions take place. Moreover, primary and back-up routes of telecontrol commands can be pre-engineered in software-defined networking to counteract potential cyberattacks.;;;https://dl.acm.org/doi/10.1145/3470481.3472707;;;Software AND Engineering
A Survey on the Verification of Adversarial Data Planes in Software-Defined Networks;;;['Conor Black', 'Sandra Scott-Hayward'];;;April 2021;;;SDN-NFV Sec'21: Proceedings of the 2021 ACM International Workshop on Software Defined Networks &amp; Network Function Virtualization Security;;;As network policies are becoming increasingly nuanced and complex, so too are the mechanisms required to ensure that the network is functioning as intended. In particular, since the dawn of software-defined networking and the shift towards high-level descriptions of intended network policy, traditional tools such as ping and traceroute have been insufficient to test that complex data plane configurations have been correctly implemented. As a result, novel data plane verification solutions have been proposed that use formal methods to ensure that network policies are adhered to and that the data plane is free of bugs. While the number of these verification solutions continues to grow, only a few are equipped to verify the data plane when a malicious adversary is present. As research continues to expand the remit of data plane functionality, these solutions may become key to securing an increasingly valuable attack target. In this survey, we review the work that has been dedicated to preventing and detecting attacks on data planes in software-defined networks and discuss some of the unsolved problems in this field that must be addressed in future adversarial verification solutions.;;;https://dl.acm.org/doi/10.1145/3445968.3452092;;;Software AND Engineering
Operating Systems for Resource-adaptive Intelligent Software: Challenges and Opportunities;;;['Xuanzhe Liu', 'Shangguang Wang', 'Yun Ma', 'Ying Zhang', 'Qiaozhu Mei', 'Yunxin Liu', 'Gang Huang'];;;None;;;ACM Transactions on Internet Technology;;;The past decades witnessed the fast and wide deployment of Internet. The Internet has bred the ubiquitous computing environment that is spanning the cloud, edge, mobile devices, and IoT. Software running over such a ubiquitous computing environment environment is eating the world. A recently emerging trend of Internet-based software systems is “resource adaptive,” i.e., software systems should be robust and intelligent enough to the changes of heterogeneous resources, both physical and logical, provided by their running environment. To keep pace of such a trend, we argue that some considerations should be taken into account for the future operating system design and implementation. From the structural perspective, rather than the “monolithic OS” that manages the aggregated resources on the single machine, the OS should be dynamically composed over the distributed resources and flexibly adapt to the resource and environment changes. Meanwhile, the OS should leverage advanced machine/deep learning techniques to derive configurations and policies and automatically learn to tune itself and schedule resources. This article envisions our recent thinking of the new OS abstraction, namely, ServiceOS, for future resource-adaptive intelligent software systems. The idea of ServiceOS is inspired by the delivery model of “Software-as-a-Service” that is supported by the Service-Oriented Architecture (SOA). The key principle of ServiceOS is based on resource disaggregation, resource provisioning as a service, and learning-based resource scheduling and allocation. The major goal of this article is not providing an immediately deployable OS. Instead, we aim to summarize the challenges and potentially promising opportunities and try to provide some practical implications for researchers and practitioners.;;;https://dl.acm.org/doi/10.1145/3425866;;;Software AND Engineering
The Use of CABRI Software in Mathematics Learning for Cultivating Geometrical Conceptual Understanding: A Meta-Analysis;;;['Amal Jaya', 'Suparman Suparman'];;;December 2021;;;ICETM '21: Proceedings of the 2021 4th International Conference on Education Technology Management;;;This study aims to estimate and examine the effect of the use of CABRI software in cultivating students' geometrical conceptual understanding across participants' country, education level, mathematics material, class capacity, and treatment duration. A meta-analysis by selecting the random effect model was employed to carry out this study. The literature search utilizing Google Scholar and Semantic Scholar found 81 documents. The final document selection established 11 journal articles published from 2009 to 2020 and indexed by Scopus and Google Scholar. The Z and Q Cochrane test were used to analyze the data. Results showed that the use of CABRI software had a moderate positive effect (g = 0,573) on students’ geometrical conceptual understanding. Moreover, the use of CABRI software cultivated students’ geometrical conceptual understanding. Furthermore, some factors such as participant's country, class capacity, and treatment duration moderated the gap of students' geometrical conceptual understanding levels. This study suggests mathematics teachers or lecturers use CABRI Software as a tool to cultivate students' geometrical conceptual understanding.;;;https://dl.acm.org/doi/10.1145/3510309.3510316;;;Software AND Engineering
The Mind Is a Powerful Place: How Showing Code Comprehensibility Metrics Influences Code Understanding;;;['Marvin Wyrich', 'Andreas Preikschat', 'Daniel Graziotin', 'Stefan Wagner'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Static code analysis tools and integrated development environments present developers with quality-related software metrics, some of which describe the understandability of source code. Software metrics influence overarching strategic decisions that impact the future of companies and the prioritization of everyday software development tasks. Several software metrics, however, lack in validation: we just choose to trust that they reflect what they are supposed to measure. Some of them were even shown to not measure the quality aspects they intend to measure. Yet, they influence us through biases in our cognitive-driven actions. In particular, they might anchor us in our decisions. Whether the anchoring effect exists with software metrics has not been studied yet. We conducted a randomized and double-blind experiment to investigate the extent to which a displayed metric value for source code comprehensibility anchors developers in their subjective rating of source code comprehensibility, whether performance is affected by the anchoring effect when working on comprehension tasks, and which individual characteristics might play a role in the anchoring effect. We found that the displayed value of a comprehensibility metric has a significant and large anchoring effect on a developer's code comprehensibility rating. The effect does not seem to affect the time or correctness when working on comprehension questions related to the code snippets under study. Since the anchoring effect is one of the most robust cognitive biases, and we have limited understanding of the consequences of the demonstrated manipulation of developers by non-validated metrics, we call for an increased awareness of the responsibility in code quality reporting and for corresponding tools to be based on scientific evidence.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00055;;;Software AND Engineering
Applying Cognitive and Neural Network Approach over Control Flow Graph for Software Defect Prediction;;;['Kumar Rajnish', 'Vandana Bhattacharjee', 'Vishnu Chandrabanshi'];;;August 2021;;;IC3-2021: Proceedings of the 2021 Thirteenth International Conference on Contemporary Computing;;;None;;;https://dl.acm.org/doi/10.1145/3474124.3474127;;;Software AND Engineering
Design Workflows and Algorithm Diagrams Interpretation Method in Software Development;;;['Nikolay Nikolaevich Voit', 'Semen Igorevich Bochkov', 'Sergey Yuryevich Kirillov', 'Maria Ukhanova'];;;July 2021;;;ICCTA '21: Proceedings of the 2021 7th International Conference on Computer Technology Applications;;;One of the challenges of the modern business process management theory is that it lacks a formal method for analyzing the design workflows and algorithms presented based on the graphic languages, which could have linear computational complexity and take into account the concept of "time". The authors present an automated method for interpreting the design workflows in the software development field. The method is based on the temporal automaton RVTI-grammar, which takes into account the "time" and "clock" concepts. It differs from the existing methods in a linear design workflows interpretation time based on the visual language and allows for a finite time to perform step-by-step workflow analysis, represented in the form of algorithm diagrams. An example of such a diagram in the EPC language is given, its step-by-step interpretation is described.;;;https://dl.acm.org/doi/10.1145/3477911.3477916;;;Software AND Engineering
Domain specific run time optimization for software data planes;;;['Sebastiano Miano', 'Alireza Sanaee', 'Fulvio Risso', 'Gábor Rétvári', 'Gianni Antichi'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;State-of-the-art approaches to design, develop and optimize software packet-processing programs are based on static compilation: the compiler's input is a description of the forwarding plane semantics and the output is a binary that can accommodate any control plane configuration or input traffic.   In this paper, we demonstrate that tracking control plane actions and packet-level traffic dynamics at run time opens up new opportunities for code specialization. We present Morpheus, a system working alongside static compilers that continuously optimizes the targeted networking code. We introduce a number of new techniques, from static code analysis to adaptive code instrumentation, and we implement a toolbox of domain specific optimizations that are not restricted to a specific data plane framework or programming language. We apply Morpheus to several eBPF and DPDK programs including Katran, Facebook's production-grade load balancer. We compare Morpheus against state-of-the-art optimization frameworks and show that it can bring up to 2x throughput improvement, while halving the 99th percentile latency.;;;https://dl.acm.org/doi/10.1145/3503222.3507769;;;Software AND Engineering
Collaborative Behavior and Winning Challenges in Competitive Software Crowdsourcing;;;['Leticia S. Machado', 'Ricardo Rodrigo M. Melo', 'Cleidson R. B. de Souza', 'Rafael Prikladnicki'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Software Crowdsourcing (SW CS) allows a requester to increase the speed of its software development efforts by submitting a task to be performed by the crowd. SW CS is usually structured around software platforms, which are used by crowd members to identify a task suited for them, gather information about this task, and finally, submit a solution for it. In competitive software crowdsourcing, members of the crowd independently create solutions while competing against each other by monetary rewards for task completion. While competition usually reduces collaboration, in this paper, we investigated how crowd members create a collaborative behavior during programming challenges using online forums to help each other, share useful information, and discuss important documents and artifacts. We also investigated different collaborative behaviours by crowd members and and how this collaboration is associated with crowd members' improved outcome in the challenges. These results are based on analysis of the online forums from Topcoder, one of the largest competitive SW CS platforms;;;https://dl.acm.org/doi/10.1145/3463932;;;Software AND Engineering
Automatically detecting and fixing concurrency bugs in go software systems;;;['Ziheng Liu', 'Shuofei Zhu', 'Boqin Qin', 'Hao Chen', 'Linhai Song'];;;April 2021;;;ASPLOS '21: Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Go is a statically typed programming language designed for efficient and reliable concurrent programming. For this purpose, Go provides lightweight goroutines and recommends passing messages using channels as a less error-prone means of thread communication. Go has become increasingly popular in recent years and has been adopted to build many important infrastructure software systems. However, a recent empirical study shows that concurrency bugs, especially those due to misuse of channels, exist widely in Go. These bugs severely hurt the reliability of Go concurrent systems. To fight Go concurrency bugs caused by misuse of channels, this paper proposes a static concurrency bug detection system, GCatch, and an automated concurrency bug fixing system, GFix. After disentangling an input Go program, GCatch models the complex channel operations in Go using a novel constraint system and applies a constraint solver to identify blocking bugs. GFix automatically patches blocking bugs detected by GCatch using Go’s channel-related language features. We apply GCatch and GFix to 21 popular Go applications, including Docker, Kubernetes, and gRPC. In total, GCatch finds 149 previously unknown blocking bugs due to misuse of channels and GFix successfully fixes 124 of them. We have reported all detected bugs and generated patches to developers. So far, developers have fixed 125 blocking misuse-of-channel bugs based on our reporting. Among them, 87 bugs are fixed by applying GFix’s patches directly.;;;https://dl.acm.org/doi/10.1145/3445814.3446756;;;Software AND Engineering
Analysis of the Influence of Total Number of Software Faults on SRGM Performance;;;['Zhichao Sun', 'Ce Zhang', 'YuFei Yuan', 'Wenqian Jiang', 'Miaomiao Fan', 'Wenyu Li', 'Yafei Wen', 'Wen Song', 'Kaiwei Liu'];;;May 2021;;;ICFEICT 2021: International Conference on Frontiers of Electronics, Information and Computation Technologies;;;The total number of software failures is an important parameter in the software reliability growth model SRGM (Software Reliability Growth Model), which plays an important role in guiding software reliability estimation, software testing management and software release strategies. In this paper, the five types of software failure total models are summarized and analyzed, and four total failure functions under imperfect troubleshooting are selected: the optimistic type with limited growth (exponential growth), and the pessimistic type with unlimited growth (linear growth and linear growth). Exponential growth) and compromise types, and conducted experiments on 9 public real failure data sets to explore the impact of the software total failure model on the fitting performance and prediction performance of SRGM. The results show that the fitting and prediction performance of the software total failure a(t) function to SRGM depends on the consistency of the a(t) model based on subjective assumptions and the objective real failure data set. Finally, it summarizes the full text and points out the future research direction of total software failure.;;;https://dl.acm.org/doi/10.1145/3474198.3478160;;;Software AND Engineering
Towards the no-code era: a vision and plan for the future of software development;;;['Ahmed ElBatanony', 'Giancarlo Succi'];;;October 2021;;;BCNC 2021: Proceedings of the 1st ACM SIGPLAN International Workshop on Beyond Code: No Code;;;This paper provides a highly opinionated and biased vision and a two-stage plan with guidelines to reach a new era of software development, where anyone can create software without bothering to write code. Moreover, this paper explores in depth the first of these stages, which consists of creating a no-code tool based on six principles: configuration driven development, APIs, open-source, cross-platform, cloud computing, and design systems. An examination of each principle is presented and a case is made for why such a combination of principles would lay the foundation for future development efforts. Possible enquiries are addressed and a path is laid out for future works.;;;https://dl.acm.org/doi/10.1145/3486949.3486965;;;Software AND Engineering
Skills Gaps in the Industry: Opinions of Embedded Software Practitioners;;;['Deniz Akdur'];;;None;;;ACM Transactions on Embedded Computing Systems;;;Many practitioners in the software-intensive embedded industry often face difficulties after beginning their careers due to misalignment of the skills learned at the university with what is required in the workplace. Companies spend crucial resources to train personnel whose academic backgrounds are not only based on “computing disciplines” but also on non-computing ones. Analyzing the gap between the software industry and academia is important for three reasons: (1) for employers, hiring properly trained practitioners allows them to spend less time in training them while incorporating them more efficiently into the workforce; (2) for practitioners, knowing the most important skillset is helpful to increase their chance of employability; and (3) for academia, understanding the necessary skillset is critical to making curriculum changes. To achieve these objectives, we conducted a survey that yielded responses from 659 software professionals working worldwide in different roles. In this study, we only included the responses of 393 embedded software practitioners whose undergraduate degree was completed in Turkey, working in 10 countries. This article sheds light on the most important skills in the embedded software industry by presenting various cross-factor analyses. Understanding the coverage of these skills in the curriculum (mostly in Turkish universities) helps bridge the gaps, which can and should be achieved through more Industry Academia Collaborations (IACs).;;;https://dl.acm.org/doi/10.1145/3463340;;;Software AND Engineering
Researching expensive software bugs: a writing assignment and activity for computing students;;;['Tammy VanDeGrift'];;;None;;;Journal of Computing Sciences in Colleges;;;This paper describes a writing and reflection activity about expensive software bugs. The assignment was designed with goals of building personal curiosity, resiliency, and responsibility, while creating connections to real world computing systems. In the reflection activity, students reported changes in their perspectives. Some of the reported updated perspectives were high-level - responsibility of software engineers in terms of safety, the impact of bugs on people and society - and some other lessons were more practical software development practices - take time to test and debug code, write good comments, ask others to review work, and expect the worst from users.;;;https://dl.acm.org/doi/10.5555/3512469.3512473;;;Software AND Engineering
Software model-checking as cyclic-proof search;;;['Takeshi Tsukada', 'Hiroshi Unno'];;;None;;;Proceedings of the ACM on Programming Languages;;;This paper shows that a variety of software model-checking algorithms can be seen as proof-search strategies for a non-standard proof system, known as a cyclic proof system. Our use of the cyclic proof system as a logical foundation of software model checking enables us to compare different algorithms, to reconstruct well-known algorithms from a few simple principles, and to obtain soundness proofs of algorithms for free. Among others, we show the significance of a heuristics based on a notion that we call maximal conservativity; this explains the cores of important algorithms such as property-directed reachability (PDR) and reveals a surprising connection to an efficient solver of games over infinite graphs that was not regarded as a kind of PDR.;;;https://dl.acm.org/doi/10.1145/3498725;;;Software AND Engineering
Gender parity in peer assessment of team software development projects;;;['Tom Crick', 'Tom Prickett', 'Jill Bradnum', 'Alan Godfrey'];;;January 2022;;;CEP '22: Proceedings of 6th Conference on Computing Education Practice;;;Development projects in which small teams of learners develop software/digital artefacts are common features of computing-related degree programmes. Within these team projects, it can be problematic ensuring students are fairly recognised and rewarded for the contribution they make to the collective team effort and outputs. Peer assessment is a commonly used approach to promote fairness and due recognition. Maintaining parity within assessment processes is also a critical aspect of fairness. This paper presents the processes employed for the operation of one such team project at a UK higher education institution, using the Team-Q rubric and analysing the impact of the (self-identified) gender of learner marking and the learner being marked on the scores obtained. The results from this institutional sample (N=121) using the Team-Q metric offers evidence of gender parity in this context. This study also makes the case for continued vigilance to ensure Team-Q and other rubrics are used in a manner that supports gender parity in computing.;;;https://dl.acm.org/doi/10.1145/3498343.3498346;;;Software AND Engineering
Towards Secure and Robust Autonomy Software in Autonomous Driving and Smart Transportation;;;['Alfred Qi Chen'];;;May 2021;;;CPSS '21: Proceedings of the 7th ACM on Cyber-Physical System Security Workshop;;;Autonomous Driving (AD) technology has always been an international pursuit due to its significant benefit in driving safety, efficiency, and mobility. Over 15 years after the first DARPA Grand Challenge, its development and deployment are becoming increasingly mature and practical, with some AD vehicles already providing services on public roads (e.g., Google Waymo One in Phoenix and Baidu Apollo Go in China). In AD technology, the autonomy software stack, or the AD software, is highly security critical: it is in charge of safety-critical driving decisions such as collision avoidance and lane keeping, and thus any security problems in it can directly impact road safety. In this talk, I will describe my recent research that initiates the first systematic effort towards understanding and addressing the security problems in production AD software. I will be focusing on two critical modules: perception and localization, and talk about how we are able to discover novel and practical sensor/physical-world attacks that can cause end-to-end safety impacts such as crashing into obstacles or driving off road. Besides AD software, I will also briefly talk about my recent research on autonomy software security in smart transportation in general, especially those enabled by Connected Vehicle (CV) technology. I will conclude with a discussion on defense and future research directions.;;;https://dl.acm.org/doi/10.1145/3457339.3457978;;;Software AND Engineering
The 13th CASCON workshop on cloud computing: engineering AIOps;;;['Marin Litoiu', 'Ian Watts', 'Joe Wigglesworth'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;AIOps, or Artificial Intelligence for IT Operations, is the application of AI to enhance IT operations. AIOps include activities such as collection and aggregation of data from services, applications and infrastructure; identification of events, such as anomalies, workload trends and patterns related to system and application quality of services; diagnosis of root causes and remediation recommendation for IT runtime issues. This workshop brought together researchers and practitioners to present and discuss the state of the art and practice in AIOps, to identify challenges and opportunities for further research and commercialization. The workshop agenda consisted of industrial talks that presented the state of the practice; research talks that presented current research projects; and a round table that discussed the research challenges and opportunities.;;;https://dl.acm.org/doi/10.5555/3507788.3507838;;;Software AND Engineering
Towards a Pattern Language to Embed UX Information in Agile Software Requirements;;;['Anathan Pereira', 'Abner Cleto Filho', 'Eduardo Guerra', 'Luciana Zaina'];;;July 2021;;;EuroPLoP'21: 26th European Conference on Pattern Languages of Programs;;;The concern on how to handle agile software requirements have been explored from different perspectives. User stories (US) are being used as valuable artifacts to agile teams, being a short requirement description with its details complemented by other artifacts. Recently, agile professionals have demonstrated a great interest in integrating User eXperience (UX) information into agile practices because UX is an important cross-cutting quality requirement. These professionals still face difficulties in organizing and linking the UX information to User Stories which can introduce navigational distance, which is characterized by the effort to reach an information. This paper presents a set of patterns intending to support agile teams to embed the UX information in agile software requirements. Our patterns were proposed based on a case study conducting in an industrial setting. From this study results, we found out that by organizing the requirements and other UX information the agile teams introduced navigational distances between that information and the US’s bringing difficulties to accessing the information in virtual tools. These patterns describe practices to motivate agile teams to rethink their ways of organizing agile software requirements and the UX information in virtual tools to support the teams to find and retrieve the UX and requirement information easily. The practices cover the UX information in most of the abstraction layers, from the UX in more practical activities, for example in tasks, to more general UX information that can be used by several US’s.;;;https://dl.acm.org/doi/10.1145/3489449.3489991;;;Software AND Engineering
ModelGame: A Quality Model for Gamified Software Modeling Learning;;;['Ed Júnior', 'Kleinner Farias'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;Gamification has been adopted in software development tasks in recent years. This adoption seeks, for example, to improve the engagement of developers while creating UML models or writing code. Empirical studies report that UML models suffer from incompleteness and inconsistency problems. This study conjectures that gamification mechanics can improve learner engagement while learning software modeling, mitigating such problems concerning UML models. The current literature lacks studies that explore gamification and UML model quality in the context of software modeling learning. This article, therefore, proposes ModelGame, which is a quality model to support software modeling learning in a gamified way. It serves as a reference framework so that instructors can obtain a parameterized way to evaluate UML models created by learners. The quality of UML models can be improved by applying gamified activities and providing guidelines aware of quality issues. A qualitative questionnaire was answered by 19 instructors who teach software modeling at higher education institutions. The results show that (1) 94.7% recognize that the proposed model can improve the quality of UML models, indicating that they would adopt the ModelGame in their learning practices; and (2) 47.4% do not use any gamification mechanics in their classes. The results are encouraging, showing the potential for applying and improving the teaching and learning of software modeling.;;;https://dl.acm.org/doi/10.1145/3483899.3483910;;;Software AND Engineering
ControlFlag: a self-supervised idiosyncratic pattern detection system for software control structures;;;['Niranjan Hasabnis', 'Justin Gottschlich'];;;June 2021;;;MAPS 2021: Proceedings of the 5th ACM SIGPLAN International Symposium on Machine Programming;;;Software debugging has been shown to utilize upwards of half of developers’ time. Yet, machine programming (MP), the field concerned with the automation of software (and hardware) development, has recently made strides in both research and production-quality automated debugging systems. In this paper we present ControlFlag, a self-supervised MP system that aims to improve debugging by attempting to detect idiosyncratic pattern violations in software control structures. ControlFlag also suggests possible corrections in the event an anomalous pattern is detected. We present ControlFlag’s design and provide an experimental evaluation and analysis of its efficacy in identifying potential programming errors in production-quality software. As a first concrete evidence towards improving software quality, ControlFlag has already found an anomaly in CURL that has been acknowledged and fixed by its developers. We also discuss future extensions of ControlFlag.;;;https://dl.acm.org/doi/10.1145/3460945.3464954;;;Software AND Engineering
Using regression learners to predict performance problems on software updates: a case study on elevators dispatching algorithms;;;['Aitor Gartziandia', 'Aitor Arrieta', 'Aitor Agirre', 'Goiuria Sagardui', 'Maite Arratibel'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Remote software deployment and updating has long been commonplace in many different fields, but now, the increasing expansion of IoT and CPSoS (Cyber-Physcal System of Systems) has highlighted the need for additional mechanisms in these systems, to ensure the correct behaviour of the deployed software version after deployment. In this sense, this paper investigates the use of Machine Learning algorithms to predict acceptable behaviour in system performance of a new software release. By monitoring the real performance, eventual unexpected problems can be identified. Based on previous knowledge and actual run-time information, the proposed approach predicts the response time that can be considered acceptable for the new software release, and this information is used to identify problematic releases. The mechanism has been applied to the post-deployment monitoring of traffic algorithms in elevator systems. To evaluate the approach, we have used performance mutation testing, obtaining good results. This paper makes two contributions. First, it proposes several regression learners that have been trained with different types of traffic profiles to efficiently predict response time of the traffic dispatching algorithm. This prediction is then compared with the actual response time of the new algorithm release, and provides a verdict about its performance. Secondly, a comparison of the different learners is performed.;;;https://dl.acm.org/doi/10.1145/3412841.3441894;;;Software AND Engineering
Userspace Software Integrity Measurement;;;['Michael Eckel', 'Tim Riemann'];;;August 2021;;;ARES '21: Proceedings of the 16th International Conference on Availability, Reliability and Security;;;Todays computing systems are more interconnected and sophisticated than ever before. Especially in healthcare 4.0, services and infrastructures rely on cyber-physical systemss (CPSess) and Internet of Things (IoT) devices. This adds to the complexity of these highly connected systems and their manageability. Even worse, the variety of emerging cyber attacks is becoming more severe and sophisticated, making healthcare one of the most important sectors with major security risks. The development of appropriate countermeasures constitutes one of the most complex and difficult challenges in cyber security research. Research areas include, among others, anomaly detection, network security, multi-layer event detection, cyber resiliency, and integrity protection.  Securing the integrity of software running on a device is a desirable protection goal in the context of systems security. With a Trusted Platform Module (TPM), measured boot, and remote attestation there exist technologies to ensure that a system has booted up correctly and runs only authentic software. The Linux Integrity Measurement Architecture (IMA) extends these principles into the operating systems (OSes), measuring native binaries before they are loaded. However, interpreted language files, such as Java classes and Python scripts, are not considered executables and are not measured as such. Contemporary OSess ship with many of these and it is vital to consider them as security-critical as native binaries.  In this paper, we introduce Userspace Software Integrity Measurement (USIM) for the Linux OSes. Userspace Software Integrity Measurement (USIM) enables interpreters to measure, log, and irrevocably anchor critical events in the TPM. We develop a software library in C which provides TPM-based measurement functionality as well as the USIM service, which provides concurrent access handling to the TPM based event logging. Further, we develop and implement a concept to realize highly frequent event logging on the slow TPM. We integrate this library into the Java Virtual Machine (JVM) to measure Java classes and show that it can be easily integrated into other interpreters. With performance measurements we demonstrate that our contribution is feasible and that overhead is negligible.;;;https://dl.acm.org/doi/10.1145/3465481.3470018;;;Software AND Engineering
On the Co-Design of Quantum Software and Hardware;;;['Gushu Li', 'Anbang Wu', 'Yunong Shi', 'Ali Javadi-Abhari', 'Yufei Ding', 'Yuan Xie'];;;September 2021;;;NANOCOM '21: Proceedings of the Eight Annual ACM International Conference on Nanoscale Computing and Communication;;;A quantum computing system naturally consists of two components, the software system and the hardware system. Quantum applications are programmed using the quantum software and then executed on the quantum hardware. However, the performance of existing quantum computing system is still limited. Solving a practical problem that is beyond the capability of classical computers on a quantum computer has not yet been demonstrated. In this review, we point out that the quantum software and hardware systems should be designed collaboratively to fully exploit the potential of quantum computing. We first review three related works, including one hardware-aware quantum compiler optimization, one application-aware quantum hardware architecture design flow, and one co-design approach for the emerging quantum computational chemistry. Then we discuss some potential future directions following the co-design principle.;;;https://dl.acm.org/doi/10.1145/3477206.3477464;;;Software AND Engineering
The life cycle of features in highly-configurable software systems evolving in space and time;;;['Gabriela K. Michelon', 'Wesley K. G. Assunção', 'David Obermann', 'Lukas Linsbauer', 'Paul Grünbacher', 'Alexander Egyed'];;;October 2021;;;GPCE 2021: Proceedings of the 20th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;;;Feature annotation based on preprocessor directives is the most common mechanism in Highly-Configurable Software Systems (HCSSs) to manage variability. However, it is challenging to understand, maintain, and evolve feature fragments guarded by #ifdef directives. Yet, despite HCSSs being implemented in Version Control Systems, the support for evolving features in space and time is still limited. To extend the knowledge on this topic, we analyze the feature life cycle in space and time. Specifically, we introduce an automated mining approach and apply it to four HCSSs, analyzing commits of their entire development life cycle (13 to 20 years and 37,500 commits). This goes beyond existing studies, which investigated only differences between specific releases or entire systems. Our results show that features undergo frequent changes, often with substantial modifications of their code. The findings of our empirical analyses stress the need for better support of system evolution in space and time at the level of features. In addition to these analyses, we contribute an automated mining approach for the analysis of system evolution at the level of features. Furthermore, we also make available our dataset to foster new studies on feature evolution in HCSSs.;;;https://dl.acm.org/doi/10.1145/3486609.3487195;;;Software AND Engineering
Ten Million Users and Ten Years Later: Python Tutor’s Design Guidelines for Building Scalable and Sustainable Research Software in Academia;;;['Philip Guo'];;;October 2021;;;UIST '21: The 34th Annual ACM Symposium on User Interface Software and Technology;;;Research software is often built as prototypes that never get widespread usage and are left unmaintained after a few papers get published. To counteract this trend, we propose a method for building research software with scale and sustainability in mind so that it can organically grow a large userbase and enable longer-term research. To illustrate this method, we present the design and implementation of Python Tutor (pythontutor.com), a code visualization tool that is, to our knowledge, one of the most widely-used pieces of research software developed within a university lab. Over the past decade, it has been used by over ten million people in over 180 countries. It has also contributed to 55 publications from 35 research groups in 13 countries. We distilled lessons from working on Python Tutor into three sets of design guidelines: 1) user experience design for scale and sustainability, 2) software architecture design for long-term sustainability, and 3) designing a sustainable software development workflow within academia. These guidelines can enable a student to create long-lasting software that reaches many users and facilitates research from many independent groups.;;;https://dl.acm.org/doi/10.1145/3472749.3474819;;;Software AND Engineering
CubicleOS: a library OS with software componentisation for practical isolation;;;['Vasily A. Sartakov', 'Lluís Vilanova', 'Peter Pietzuch'];;;April 2021;;;ASPLOS '21: Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Library OSs have been proposed to deploy applications isolated inside containers, VMs, or trusted execution environments. They often follow a highly modular design in which third-party components are combined to offer the OS functionality needed by an application, and they are customised at compilation and deployment time to fit application requirements. Yet their monolithic design lacks isolation across components: when applications and OS components contain security-sensitive data (e.g., cryptographic keys or user data), the lack of isolation renders library OSs open to security breaches via malicious or vulnerable third-party components.  We describe CubicleOS, a library OS that isolates components in the system while maintaining the simple, monolithic development approach of library composition. CubicleOS allows isolated components, called cubicles , to share data dynamically with other components. It provides spatial memory isolation at the granularity of function calls by using Intel MPK at user-level to isolate components. At the same time, it supports zero-copy data access across cubicles with feature-rich OS functionality. Our evaluation shows that CubicleOS introduces moderate end-to-end performance overheads in complex applications: 2× for the I/O-intensive NGINX web server with 8 partitions, and 1.7–8× for the SQLite database engine with 7 partitions.;;;https://dl.acm.org/doi/10.1145/3445814.3446731;;;Software AND Engineering
Enzian: an open, general, CPU/FPGA platform for systems software research;;;['David Cock', 'Abishek Ramdas', 'Daniel Schwyn', 'Michael Giardino', 'Adam Turowski', 'Zhenhao He', 'Nora Hossle', 'Dario Korolija', 'Melissa Licciardello', 'Kristina Martsenko', 'Reto Achermann', 'Gustavo Alonso', 'Timothy Roscoe'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Hybrid computing platforms, comprising CPU cores and FPGA logic, are increasingly used for accelerating data-intensive workloads in cloud deployments, and are a growing topic of interest in systems research. However, from a research perspective, existing hardware platforms are limited: they are often optimized for concrete, narrow use-cases and, therefore lack the flexibility needed to explore other applications and configurations.   We show that a research group can design and build a more general, open, and affordable hardware platform for hybrid systems research. The platform, Enzian, is capable of duplicating the functionality of existing CPU/FPGA systems with comparable performance but in an open, flexible system. It couples a large FPGA with a server-class CPU in an asymmetric cache-coherent NUMA system. Enzian also enables research not possible with existing hybrid platforms, through explicit access to coherence messages, extensive thermal and power instrumentation, and an open, programmable baseboard management processor.   Enzian is already being used in multiple projects, is open source (both hardware and software), and available for remote use. We present the design principles of Enzian, the challenges in building it, and evaluate it with a range of existing research use-cases alongside other, more specialized platforms, as well as demonstrating research not possible on existing platforms.;;;https://dl.acm.org/doi/10.1145/3503222.3507742;;;Software AND Engineering
RAP: A Software Framework of Developing Convolutional Neural Networks for Resource-constrained Devices Using Environmental Monitoring as a Case Study;;;['Chia-Heng Tu', 'Qihui Sun', 'Hsiao-Hsuan Chang'];;;None;;;ACM Transactions on Cyber-Physical Systems;;;Monitoring environmental conditions is an important application of cyber-physical systems. Typically, the monitoring is to perceive surrounding environments with battery-powered, tiny devices deployed in the field. While deep learning-based methods, especially the convolutional neural networks (CNNs), are promising approaches to enriching the functionalities offered by the tiny devices, they demand more computation and memory resources, which makes these methods difficult to be adopted on such devices. In this article, we develop a software framework, RAP, that permits the construction of the CNN designs by aggregating the existing, lightweight CNN layers, which are able to fit in the limited memory (e.g., several KBs of SRAM) on the resource-constrained devices satisfying application-specific timing constrains. RAP leverages the Python-based neural network framework Chainer to build the CNNs by mounting the C/C++ implementations of the lightweight layers, trains the built CNN models as the ordinary model-training procedure in Chainer, and generates the C version codes of the trained models. The generated programs are compiled into target machine executables for the on-device inferences. With the vigorous development of lightweight CNNs, such as binarized neural networks with binary weights and activations, RAP facilitates the model building process for the resource-constrained devices by allowing them to alter, debug, and evaluate the CNN designs over the C/C++ implementation of the lightweight CNN layers. We have prototyped the RAP framework and built two environmental monitoring applications for protecting endangered species using image- and acoustic-based monitoring methods. Our results show that the built model consumes less than 0.5 KB of SRAM for buffering the runtime data required by the model inference while achieving up to 93% of accuracy for the acoustic monitoring with less than one second of inference time on the TI 16-bit microcontroller platform.;;;https://dl.acm.org/doi/10.1145/3472612;;;Software AND Engineering
Enzian: an open, general, CPU/FPGA platform for systems software research;;;['David Cock', 'Abishek Ramdas', 'Daniel Schwyn', 'Michael Giardino', 'Adam Turowski', 'Zhenhao He', 'Nora Hossle', 'Dario Korolija', 'Melissa Licciardello', 'Kristina Martsenko', 'Reto Achermann', 'Gustavo Alonso', 'Timothy Roscoe'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Hybrid computing platforms, comprising CPU cores and FPGA logic, are increasingly used for accelerating data-intensive workloads in cloud deployments, and are a growing topic of interest in systems research. However, from a research perspective, existing hardware platforms are limited: they are often optimized for concrete, narrow use-cases and, therefore lack the flexibility needed to explore other applications and configurations.   We show that a research group can design and build a more general, open, and affordable hardware platform for hybrid systems research. The platform, Enzian, is capable of duplicating the functionality of existing CPU/FPGA systems with comparable performance but in an open, flexible system. It couples a large FPGA with a server-class CPU in an asymmetric cache-coherent NUMA system. Enzian also enables research not possible with existing hybrid platforms, through explicit access to coherence messages, extensive thermal and power instrumentation, and an open, programmable baseboard management processor.   Enzian is already being used in multiple projects, is open source (both hardware and software), and available for remote use. We present the design principles of Enzian, the challenges in building it, and evaluate it with a range of existing research use-cases alongside other, more specialized platforms, as well as demonstrating research not possible on existing platforms.;;;https://dl.acm.org/doi/10.1145/3503222.3507742;;;Software AND Engineering
Research tools, survey responses, and interview analysis from a case study of onboarding software teams at Microsoft;;;['An Ju', 'Hitesh Sajnani', 'Scot Kelly', 'Kim Herzig'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;The artifacts is publicly available at [1] https://doi.org/10.5281/zenodo.4455936 This repository contains the supplementary material for the paper [2]. It contains • Interview guides • Surveys • Anonymized survey responses • Interview analysis and quotes We have removed open-ended questions from survey responses to protect participants' privacy.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00102;;;Software AND Engineering
Risk-Oriented Design Approach For Forensic-Ready Software Systems;;;['Lukas Daubner', 'Raimundas Matulevičius'];;;August 2021;;;ARES '21: Proceedings of the 16th International Conference on Availability, Reliability and Security;;;Digital forensic investigation is a complex and time-consuming activity in response to a cybersecurity incident or cybercrime to answer questions related to it. These typically are what happened, when, where, how, and who is responsible. However, answering them is often very laborious and sometimes outright impossible due to a lack of useable data. The forensic-ready software systems are designed to produce valuable on-point data for use in the investigation with potentially high evidence value. Still, the particular ways to develop these systems are currently not explored.  This paper proposes consideration of forensic readiness within security risk management to refine specific requirements on forensic-ready software systems. The idea is to re-evaluate the taken security risk decisions with the aim to provide trustable data when the security measures fail. Additionally, it also considers possible disputes, which the digital evidence can solve. Our proposed approach, risk-oriented forensic-ready design, composes of two parts: (1) process guiding the identification of the requirements in the form of potential evidence sources, and (2) supporting BPMN notation capturing the potential evidence sources and their relationship. Together they are aimed to provide a high-level overview of the forensic-ready requirements within the system. Finally, the approach is demonstrated on an automated valet parking scenario, followed by a discussion regarding its impact and usefulness within the forensic readiness effort.;;;https://dl.acm.org/doi/10.1145/3465481.3470052;;;Software AND Engineering
Understanding and Detecting Software Upgrade Failures in Distributed Systems;;;['Yongle Zhang', 'Junwen Yang', 'Zhuqi Jin', 'Utsav Sethi', 'Kirk Rodrigues', 'Shan Lu', 'Ding Yuan'];;;October 2021;;;SOSP '21: Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles;;;Upgrade is one of the most disruptive yet unavoidable maintenance tasks that undermine the availability of distributed systems. Any failure during an upgrade is catastrophic, as it further extends the service disruption caused by the upgrade. The increasing adoption of continuous deployment further increases the frequency and burden of the upgrade task. In practice, upgrade failures have caused many of today's high-profile cloud outages. Unfortunately, there has been little understanding of their characteristics. This paper presents an in-depth study of 123 real-world upgrade failures that were previously reported by users in 8 widely used distributed systems, shedding lights on the severity, root causes, exposing conditions, and fix strategies of upgrade failures. Guided by our study, we have designed a testing framework DUPTester that revealed 20 previously unknown upgrade failures in 4 distributed systems, and applied a series of static checkers DUPChecker that discovered over 800 cross-version data-format incompatibilities that can lead to upgrade failures. DUPChecker has been requested by HBase developers to be integrated into their toolchain.;;;https://dl.acm.org/doi/10.1145/3477132.3483577;;;Software AND Engineering
A Software/Hardware Co-Design of Crystals-Dilithium Signature Scheme;;;['Zhen Zhou', 'Debiao He', 'Zhe Liu', 'Min Luo', 'Kim-Kwang Raymond Choo'];;;None;;;ACM Transactions on Reconfigurable Technology and Systems;;;As quantum computers become more affordable and commonplace, existing security systems that are based on classical cryptographic primitives, such as RSA and Elliptic Curve Cryptography (ECC), will no longer be secure. Hence, there has been interest in designing post-quantum cryptographic (PQC) schemes, such as those based on lattice-based cryptography (LBC). The potential of LBC schemes is evidenced by the number of such schemes passing the selection of NIST PQC Standardization Process Round-3. One such scheme is the Crystals-Dilithium signature scheme, which is based on the hard module-lattice problem. However, there is no efficient implementation of the Crystals-Dilithium signature scheme. Hence, in this article, we present a compact hardware architecture containing elaborate modular multiplication units using the Karatsuba algorithm along with smart generators of address sequence and twiddle factors for NTT, which can complete polynomial addition/multiplication with the parameter setting of Dilithium in a short clock period. Also, we propose a fast software/hardware co-design implementation on Field Programmable Gate Array (FPGA) for the Dilithium scheme with a tradeoff between speed and resource utilization. Our co-design implementation outperforms a pure C implementation on a Nios-II processor of the platform Altera DE2-115, in the sense that our implementation is 11.2 and 7.4 times faster for signature and verification, respectively. In addition, we also achieve approximately 51% and 31% speed improvement for signature and verification, in comparison to the pure C implementation on processor ARM Cortex-A9 of ZYNQ-7020 platform.;;;https://dl.acm.org/doi/10.1145/3447812;;;Software AND Engineering
Mutation testing and self/peer assessment: analyzing their effect on students in a software testing course;;;['Pedro Delgado-Pérez', 'Inmaculada Medina-Bulo', 'Miguel Ángel Álvarez-García', 'Kevin J. Valle-Gómez'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Testing is a crucial activity in the development of software systems. With the increasing complexity of software projects, the industry requires incorporating graduates with adequate testing skills and preparation in this field. A challenge in software testing education is to make students perceive the benefits of writing tests and assess their quality with advanced testing techniques. In this paper, we present an experience integrating both mutation testing and self/peer assessment ---two of the most used techniques to that end in the past--- into a software testing course during three years. This experience allowed us to analyze the effect of applying these strategies on the students' perception of their manually-written test suites. Noticeably, the computation of the mutation score significantly undermined the initial expectations they had on the developed test suites. Also, the application of peer testing helped them estimate the relative quality of two comparable test suites, as we found a notable correspondence with their respective mutation coverage. Besides, a more in-depth analysis revealed that the students' test suites with more test cases did not always achieve the highest scores, that they found more readable their own tests, and that they tended to cover the basic operations while forgetting about more advanced features. An opinion survey confirmed the impact that the use of mutants had on their perception about testing, and they mostly supported paying a higher level of attention to testing concepts in software engineering degree plans.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00033;;;Software AND Engineering
Software-Managed Read and Write Wear-Leveling for Non-Volatile Main Memory;;;['Christian Hakert', 'Kuan-Hsun Chen', 'Horst Schirmeier', 'Lars Bauer', 'Paul R. Genssler', 'Georg von der Brüggen', 'Hussam Amrouch', 'Jörg Henkel', 'Jian-Jia Chen'];;;None;;;ACM Transactions on Embedded Computing Systems;;;In-memory wear-leveling has become an important research field for emerging non-volatile main memories over the past years. Many approaches in the literature perform wear-leveling by making use of special hardware. Since most non-volatile memories only wear out from write accesses, the proposed approaches in the literature also usually try to spread write accesses widely over the entire memory space. Some non-volatile memories, however, also wear out from read accesses, because every read causes a consecutive write access. Software-based solutions only operate from the application or kernel level, where read and write accesses are realized with different instructions and semantics. Therefore different mechanisms are required to handle reads and writes on the software level. First, we design a method to approximate read and write accesses to the memory to allow aging aware coarse-grained wear-leveling in the absence of special hardware, providing the age information. Second, we provide specific solutions to resolve access hot-spots within the compiled program code (text segment) and on the application stack. In our evaluation, we estimate the cell age by counting the total amount of accesses per cell. The results show that employing all our methods improves the memory lifetime by up to a factor of 955×.;;;https://dl.acm.org/doi/10.1145/3483839;;;Software AND Engineering
Design and Development of a Technology-Agnostic NFR Testing Framework: Introducing the framework and discussing the future of load testing in Agile software development;;;['Erik Whiting', 'Soma Datta'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;Testing the non-functional requirements (NFR) of a system is particularly complicated and time-consuming. Challenges in this area are compounded when the system is developed under some offspring of Agile methodologies, which favor iterative development and rapid feedback from extensive testing. The authors of this paper build upon previous work investigating the common challenges and solutions cited in recent peer-reviewed research on this topic to design and build a tool consolidating many of the concepts found in this investigation. The tool is known as LuluPerfTest (LPT) and is an NFR testing framework meant to plug into continuous integration (CI) systems to run NFR tests configured with a JSON script. This allows developers and testers to build maintainable and minimally complex automated NFR test scripts. This study explains the challenges inherent in NFR testing in Agile software development and presents how LPT confronts those challenges. It aims to explain LPT and invite collaboration among other testing, verification, and validation researchers to create an open sources software (OSS) solution to the problems of NFR testing in Agile software development projects.;;;https://dl.acm.org/doi/10.1145/3520084.3520092;;;Software AND Engineering
A Cross-role and Bi-national Analysis on Security Efforts and Constraints of Software Development Projects;;;['Fumihiro Kanei', 'Ayako Akiyama Hasegawa', 'Eitaro Shioji', 'Mitsuaki Akiyama'];;;December 2021;;;ACSAC '21: Proceedings of the 37th Annual Computer Security Applications Conference;;;Software security, which is often regarded as a non-functional requirement, tends to be less prioritized than other explicit requirements in development projects. For designing security measures that can be used in software development, we must understand the obstacles that prevent the adoption of secure software development practices. In this study, we quantitatively analyzed security efforts and constraints of software development projects through an online survey of software development professionals in the US and Japan (N=664). We revealed how certain characteristics of a development project, such as the project’s contractual relationships or the software’s target users, influence security efforts and constraints. In addition, by comparing the survey results of two groups (developers and managers), we revealed how the gap in their security efforts and constraints influences software security. We believe the results provide insights toward designing usable measures to assist security-related decision-making in software development and conducting appropriate surveys targeting software development professionals.;;;https://dl.acm.org/doi/10.1145/3485832.3485922;;;Software AND Engineering
A Serious Game Design Framework for Software Developers to Put GDPR into Practice;;;['Abdulrahman Alhazmi', 'Nalin A G Arachchilage'];;;August 2021;;;ARES '21: Proceedings of the 16th International Conference on Availability, Reliability and Security;;;The growth of the internet has significantly increased data breaches (i.e. privacy breaches) in software systems. It could be argued that software developers failed to implement privacy into software systems with the appropriate privacy guidelines or laws such as the General Data Protection Regulation (GDPR). GDPR has a set of guidelines that enables software developers to implement privacy into software systems. Nevertheless, these guidelines have been developed with lawyers in mind, rather than software developers. This could hinder developers from putting GDPR into practice and eventually lead to data breaches through the systems they develop. On the other hand, software developers also need help (e.g. tooling support or educational interventions). Therefore, this paper proposes a game design framework, as an educational intervention, to teach software developers to implement privacy-preserving software systems taking GDPR on-board. The proposed framework focuses on improving developers’ security coding behavior through their motivation. It also ensures software developers can put GDPR into practice when developing privacy-preserving software systems.;;;https://dl.acm.org/doi/10.1145/3465481.3470031;;;Software AND Engineering
Real-Time Update of Joint SFC and Routing in Software Defined Networks;;;['Xingpeng Fan', 'Hongli Xu', 'He Huang', 'Xuwei Yang'];;;None;;;IEEE/ACM Transactions on Networking;;;To meet the ever-increasing demands for high-quality network services, a software defined network (SDN) can support various virtual network functions (VNFs) using virtualization technology. Due to network dynamics, an SDN needs to be updated frequently to optimize various performance objectives, such as load balancing. Most previous solutions first determine a new network configuration (<italic>e.g.</italic>, target VNF placement and flow routing) based on the current workload, and then update the VNF placement and routing paths of the existing flows. However, due to massive VNF&#x2019;s state migration and slow update of the flow table, unacceptable update delay may occur, especially in large or frequently changed networks. In this paper, we address the real-time network update, which jointly considers the optimization of the service function chain (SFC) update and the routing update. We propose the delay-satisfied NFV-enabled network update (DSNU) problem, and prove its NP-Hardness. We design an algorithm with bounded approximation factor to solve this problem. To further reduce the delay, we also design an efficient algorithm for the update scheduling. The experimental results show that our method can reduce the network update delay by about 86&#x0025; compared with the previous network update methods while preserving a similar network performance, <italic>i.e.</italic>, the VNF instance load ratio increases by less than 5&#x0025;.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3095935;;;Software AND Engineering
Code of Conduct Conversations in Open Source Software Projects on Github;;;['Renee Li', 'Pavitthra Pandurangan', 'Hana Frluckaj', 'Laura Dabbish'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;The rapid growth of open source software necessitates a deeper understanding of moderation and governance methods currently used within these projects. The code of conduct, a set of rules articulating standard behavior and responsibilities for participation within a community, is becoming an increasingly common policy document in open source software projects for setting project norms of behavior and discouraging negative or harassing comments and conversation. This study describes the conversations around adopting and crafting a code of conduct as well as those utilizing code of conduct for community governance. We conduct a qualitative analysis of a random sample of GitHub issues that involve the code of conduct. We find that codes of conduct are used both proactively and reactively to govern community behavior in project issues. Oftentimes, the initial addition of a code of conduct does not involve much community participation and input. However, a controversial moderation act is capable of inciting mass community feedback and backlash. Project maintainers balance the tension between disciplining potentially offensive forms of speech and encouraging broad and inclusive participation. These results have implications for the design of inclusive and effective governance practices for open source software communities.;;;https://dl.acm.org/doi/10.1145/3449093;;;Software AND Engineering
Analyzing the Relationship between Software Metrics and Bad Smells Using Critical Metric Value (CMV);;;['Mansi Agnihotri', 'Anuradha Chug'];;;August 2021;;;IC3-2021: Proceedings of the 2021 Thirteenth International Conference on Contemporary Computing;;;User requirements for a software system frequently evolve with time, and developers sometimes make incorrect implementation choices while meeting such requirements. These choices tend to introduce system flaws, i.e., bad smells in the program's source code. Bad smells do not disturb the normal functioning of a system, but they might worsen the software quality by increasing its complexity. Software metrics play a significant role in the analysis of object-oriented properties of a system. Also, change in software metrics’ values are often used to predict bad smells in a code. In the current study, an investigation has been conducted on four open-source projects. The concept of Critical Metric Value (CMV) has been introduced in the current study, and its impact on the occurrence of five selected bad smells has been examined to establish a relationship between software metrics and bad smells. CMV is that value of any software metric that is considered an outlier when compared to the rest of the metric values. The selected bad smells have been categorized as Null, Only, and Multiple based on the presence of CMV in a class. This study shows that 37.3% of the total classes have been affected by bad smells. Long statement bad smell pre-dominantly affects the selected systems as it is present in 25.74% classes. The experiment's findings show that 82.5% of the total bad smells occur in a class that consists of at least one CMV. The current study helps to establish a relationship between the bad smells and critical software metrics.;;;https://dl.acm.org/doi/10.1145/3474124.3474193;;;Software AND Engineering
GraphGallery: a platform for fast benchmarking and easy development of graph neural networks based intelligent software;;;['Jintang Li', 'Kun Xu', 'Liang Chen', 'Zibin Zheng', 'Xiao Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Graph Neural Networks (GNNs) have recently shown to be powerful tools for representing and analyzing graph data. So far GNNs is becoming an increasingly critical role in software engineering including program analysis, type inference, and code representation. In this paper, we introduce GraphGallery, a platform for fast benchmarking and easy development of GNNs based software. GraphGallery is an easy-to-use platform that allows developers to automatically deploy GNNs even with less domain-specific knowledge. It offers a set of implementations of common GNN models based on mainstream deep learning frameworks. In addition, existing GNNs toolboxes such as PyG and DGL can be easily incorporated into the platform. Experiments demonstrate the reliability of implementations and superiority in fast coding. The official source code of GraphGallery is available at https://github.com/EdisonLeeeee/GraphGallery and a demo video can be found at https://youtu.be/mv7Zs1YeaYo.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00024;;;Software AND Engineering
Studying the Usage of Text-To-Text Transfer Transformer to Support Code-Related Tasks;;;['Antonio Mastropaolo', 'Simone Scalabrino', 'Nathan Cooper', 'David Nader Palacio', 'Denys Poshyvanyk', 'Rocco Oliveto', 'Gabriele Bavota'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Deep learning (DL) techniques are gaining more and more attention in the software engineering community. They have been used to support several code-related tasks, such as automatic bug fixing and code comments generation. Recent studies in the Natural Language Processing (NLP) field have shown that the Text-To-Text Transfer Transformer (T5) architecture can achieve state-of-the-art performance for a variety of NLP tasks. The basic idea behind T5 is to first pre-train a model on a large and generic dataset using a self-supervised task (e.g., filling masked words in sentences). Once the model is pre-trained, it is fine-tuned on smaller and specialized datasets, each one related to a specific task (e.g., language translation, sentence classification). In this paper, we empirically investigate how the T5 model performs when pre-trained and fine-tuned to support code-related tasks. We pre-train a T5 model on a dataset composed of natural language English text and source code. Then, we fine-tune such a model by reusing datasets used in four previous works that used DL techniques to: (i) fix bugs, (ii) inject code mutants, (iii) generate assert statements, and (iv) generate code comments. We compared the performance of this single model with the results reported in the four original papers proposing DL-based solutions for those four tasks. We show that our T5 model, exploiting additional data for the self-supervised pre-training phase, can achieve performance improvements over the four baselines.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00041;;;Software AND Engineering
Hypothesis Formalization: Empirical Findings, Software Limitations, and Design Implications;;;['Eunice Jun', 'Melissa Birchfield', 'Nicole De Moura', 'Jeffrey Heer', 'René Just'];;;None;;;ACM Transactions on Computer-Human Interaction;;;Data analysis requires translating higher level questions and hypotheses into computable statistical models. We present a mixed-methods study aimed at identifying the steps, considerations, and challenges involved in operationalizing hypotheses into statistical models, a process we refer to as hypothesis formalization. In a formative content analysis of 50 research papers, we find that researchers highlight decomposing a hypothesis into sub-hypotheses, selecting proxy variables, and formulating statistical models based on data collection design as key steps. In a lab study, we find that analysts fixated on implementation and shaped their analyses to fit familiar approaches, even if sub-optimal. In an analysis of software tools, we find that tools provide inconsistent, low-level abstractions that may limit the statistical models analysts use to formalize hypotheses. Based on these observations, we characterize hypothesis formalization as a dual-search process balancing conceptual and statistical considerations constrained by data and computation and discuss implications for future tools.;;;https://dl.acm.org/doi/10.1145/3476980;;;Software AND Engineering
A passion for security: intervening to help software developers;;;['Charles Weir', 'Ingolf Becker', 'Lynne Blair'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;While the techniques to achieve secure, privacy-preserving software are now well understood, evidence shows that many software development teams do not use them: they lack the 'security maturity' to assess security needs and decide on appropriate tools and processes; and they lack the ability to negotiate with product management for the required resources. This paper describes a measuring approach to assess twelve aspects of this security maturity; its use to assess the impact of a lightweight package of workshops designed to increase security maturity; and a novel approach within that package to support developers in resource negotiation. Based on trials in eight organizations, involving over 80 developers, this paper demonstrates that (1) development teams can notably improve their security maturity even in the absence of security specialists; and (2) suitably guided, developers can find effective ways to promote security to product management. Empowering developers to make their own decisions and promote security in this way offers a powerful grassroots approach to improving the security of software worldwide.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00011;;;Software AND Engineering
Software source code vulnerability detection using advanced deep convolutional neural network;;;['Mansour Alqarni', 'Akramul Azim'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;To improve the security of software, due to the high cost of failures at runtime, it is essential to detect all kinds of vulnerabilities of the source code during software development. However, identifying vulnerabilities have become challenging during software development, because test cases may not detect all types. To create a dataset containing vulnerabilities, machine learning algorithms are useful to analyze code patterns from previous software development. In this research effort, we address the data imbalance problem present in existing datasets by applying an undersampling technique, creating a large dataset of vulnerability detection. We also apply deep convolutional neural networks with extended layers and filters to detect source code vulnerabilities by training millions of source codes from our improved large and balanced dataset. We compare our experimental results with previous research and find that our proposed method outperforms existing results with 96.46% accuracy for the SATE IV Juliet dataset and 77.16% accuracy for the balanced dataset from github and debian.;;;https://dl.acm.org/doi/10.5555/3507788.3507822;;;Software AND Engineering
A Survey Research on Feedback Practices in Agile Software Development Teams;;;['Ana Beatriz Cavalcanti Ribeiro', 'Carina Frota Alves'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;The need for greater flexibility, autonomy and dynamism in software development has increased the adoption of agile methodologies. In order to support the recommended practices of these methodologies, maintaining good communication between team members and promoting a positive work environment that allows the individual growth of employees through autonomous learning and decision making have become key success factors. In this context, feedback is an important practice to provide each employee with an analysis of their performance, both personal and technical. The objective of this paper is to investigate the impact of feedback on motivational factors from the perspective of developers, testers and managers of agile development teams. We conducted a survey with 25 collaborators to assess motivational factors and possible points for improvement in the feedback process adopted by the teams. Among the obtained results, job satisfaction and productivity were positively influenced by the practice of feedback. In contrast, the periodicity of feedback and the absence of an evaluation among members were considered improvement points. Based on the survey results, we provided a set of recommendations to improve the quality of the feedback process in agile teams.;;;https://dl.acm.org/doi/10.1145/3493244.3493284;;;Software AND Engineering
Comparing the Popularity of Testing Careers among Canadian, Indian, Chinese, and Malaysian Students;;;['Luiz Fernando Capretz', 'Pradeep Waychal', 'Jingdong Jia', 'Shuib B. Basri'];;;November 2021;;;AISS '21: Proceedings of the 3rd International Conference on Advanced Information Science and System;;;This study attempts to understand motivators and de-motivators that influence the decisions of software students to take up and sustain software testing careers across four different countries, Canada, India, China, and Malaysia. Towards that end, we have developed a cross-sectional, but simple, survey-based instrument. In this study we investigated how software engineering and computer science students perceive and value what they do and their environmental settings. This study found that very few students are keen to take up software testing careers - why is this happening with such an important task in the software life cycle? The common advantages of a software testing career are learning opportunities and easiness of the job and the common drawbacks are tediousness, complexity, and missing the opportunity to do (software) development. Our findings highlight the importance of depicting software testing activities as a set of human-dependent tasks, and emphasizes the need for research that critically examines the way in which software testers view testing activities.;;;https://dl.acm.org/doi/10.1145/3503047.3503091;;;Software AND Engineering
Analysis of Software Accounting Effectiveness on Data Sales in Bliss Kitchen;;;['Meiryani Meiryani', 'Hanny Franciska', 'Rindang Widuri', 'Suryadiputra Liawatimena', 'Zaidi Mat Daut', 'Hana Ulinnuha'];;;December 2021;;;ICCNS '21: Proceedings of the 2021 11th International Conference on Communication and Network Security;;;The development of the increasingly advanced business world will certainly always be related to technological developments, especially in the current 4.0 era. In Indonesia, there are various types of companies such as services, manufacturing, food, and others. The development of the company will cause more and more complex transactions. It is very unlikely that the company has to record all forms of operations with a manual system, especially for large companies with so much data that they need a system to help process data quickly so that all transactions can be processed into reliable information. complete and accurate so that the company's goals can be realized. The purpose of this study was to determine the effectiveness of accurate accounting software for recording sales reports in one of the companies that engaged in food & beverage, namely Bliss Kitchen. The research that the writer did used is a quantitative approach with a survey method. This study finds that Accurate software that applied in Bliss kitchen is effective. Evidence shows the results of the questionnaire from Bliss Kitchen employees is positive about Accurate.;;;https://dl.acm.org/doi/10.1145/3507509.3507523;;;Software AND Engineering
Control Plane Reflection Attacks and Defenses in Software-Defined Networks;;;['Menghao Zhang', 'Guanyu Li', 'Lei Xu', 'Jiasong Bai', 'Mingwei Xu', 'Guofei Gu', 'Jianping Wu'];;;None;;;IEEE/ACM Transactions on Networking;;;Software-Defined Networking (SDN) continues to be deployed spanning from enterprise data centers to cloud computing with the proliferation of various SDN-enabled hardware switches and dynamic control plane applications. However, state-of-the-art SDN-enabled hardware switches have rather limited downlink message processing capability, especially for <italic>Flow-Mod</italic> and <italic>Statistic Query</italic>, which may not suffice the huge need of dynamic control plane applications. In this paper, we systematically study the interactions between the control plane applications and the data plane switches, and present two new attacks, namely Control Plane Reflection Attacks, to exploit the limited processing capability of SDN-enabled hardware switches. The reflection attacks adopt direct and indirect data plane events to force the control plane to issue massive expensive downlink messages towards SDN switches. Moreover, we propose a two-phase probing-triggering attack strategy, which makes the reflection attacks much more efficient and powerful. Experiments on a testbed with 3 different physical OpenFlow switches demonstrate that the attacks can lead to catastrophic results such as hurting the establishment of new flows and even disruption of connection between SDN controller and switches. To mitigate such attacks, we present several countermeasures from different perspectives. In particular, we propose a novel, systematical defense framework, SwitchGuard, to detect anomalies of downlink messages and prioritize these messages based on a novel monitoring granularity, i.e., host-application pair (HAP). Implementations and evaluations demonstrate that SwitchGuard can effectively reduce the latency for legitimate hosts and applications under the control plane reflection attacks with only minor overheads.;;;https://dl.acm.org/doi/10.1109/TNET.2020.3040773;;;Software AND Engineering
Predicting the existence of exploitation concepts linked to software vulnerabilities using text mining;;;['Konstantinos Charmanas', 'Nikolaos Mittas', 'Lefteris Angelis'];;;November 2021;;;PCI '21: Proceedings of the 25th Pan-Hellenic Conference on Informatics;;;Software vulnerabilities are weaknesses of specific products and versions that may lead in benefiting attackers to exploit such malfunctions, having a further goal to gain access to operating systems, devices and users’ data. As not all vulnerabilities constitute potential threats to such information, this research attempts to explore ways to the identify the ones that are possible to be exploited using only textual descriptions. The practical goal of the experiments is to examine future raw descriptions in order to predict whether the linked product is likely to be exploited or not. The ground truth examined is the existence or absence of references that report exploitation concepts of the related weaknesses. To meet our objectives, in this study, we make use of Natural Language Processing (NLP) techniques, feature evaluation filtering mechanisms and an oversampling method in order to adapt the raw texts into inputs to classification models and detect the most important terms. The results are promising as many constructed models provided an overall accepted accuracy based on the information of the collected dataset.;;;https://dl.acm.org/doi/10.1145/3503823.3503888;;;Software AND Engineering
RE-BERT: automatic extraction of software requirements from app reviews using BERT language model;;;['Adailton Ferreira de Araújo', 'Ricardo Marcondes Marcacini'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Traditionally, developers restricted themselves to collecting opinions from a small group of users by using techniques such as interviews, questionnaires, and meetings. With the popularization of social media and mobile applications, these professionals have to deal with crowd users' opinions, who want to voice the software's evolution. In this context, one of the main related tasks is the automatic identification of software requirements from app reviews. Recent studies show that existing methods fail at this task, since review texts usually contain informal language, contain grammatical and spelling errors, as well as the difficulty in filtering out irrelevant information that has no practical value for developers. In this paper, we present the RE-BERT (Requirements Engineering using Bidirectional Encoder Representations from Transformers). Our method innovates by using pre-trained neural language models to generate semantic textual representations with contextual word embeddings. Our RE-BERT performs fine-tuning of the BERT model with a focus on the local context of the software requirement tokens. A statistical analysis of the experimental results involving eight different apps showed that our RE-BERT outperforms existing state-of-the-art methods.;;;https://dl.acm.org/doi/10.1145/3412841.3442006;;;Software AND Engineering
Software-Defined Vector Processing on Manycore Fabrics;;;['Philip Bedoukian', 'Neil Adit', 'Edwin Peguero', 'Adrian Sampson'];;;October 2021;;;MICRO '21: MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture;;;We describe a tiled architecture that can fluidly transition between manycore (MIMD) and vector (SIMD) execution. The hardware provides a software-defined vector programming model that lets applications aggregate groups of manycore tiles into logical vector engines. In manycore mode, the machine behaves as a standard parallel processor. In vector mode, groups of tiles repurpose their functional units as vector execution lanes and scratchpads as vector memory banks. The key mechanism is an instruction forwarding network: a single tile fetches instructions and sends them to other trailing cores. Most cores disable their frontends and instruction caches, so vector groups amortize the intrinsic hardware costs of von Neumann control. Vector groups also use a decoupled access/execute scheme to centralize their memory requests and issue coalesced, wide loads.  We augment an existing RISC-V manycore design with a minimal hardware extension to implement software-defined vectors. Cycle-level simulation results show that software-defined vectors improve performance by an average of 1.7 × over standard MIMD execution while saving 22% of the energy. Compared to a similarly configured GPU, the architecture improves performance by 1.9 ×.;;;https://dl.acm.org/doi/10.1145/3466752.3480099;;;Software AND Engineering
Detection and Classification of Malicious Software based on Regional Matching of Temporal Graphs;;;['Helen-Maria Dounavi', 'Anna Mpanti', 'Stavros D. Nikolopoulos', 'Iosif Polenakis'];;;June 2021;;;CompSysTech '21: Proceedings of the 22nd International Conference on Computer Systems and Technologies;;;In this paper we present an integrated graph-based framework that utilizes relations between groups of System-calls, in order to detect whether an unknown software sample is malicious or benign, and to a further extent to classify it to a known malware family. A novel graph-based approach for the representation of software samples over the depiction of the structural evolution over time, the so-called Temporal Graphs, is discussed, and a method for measuring graph similarity among specific Regions of such graphs is proposed, the so-called Regional Matching. The partitioning of the Temporal Graphs that depicts their structural evolution over time is defined by specific time-slots, while the quantitative characteristics that depict the commonalities appeared over the weights of the vertices are measured by a similarity metric in order to conduct the malware detection and classification procedures. Finally, we evaluate the detection and classification ability of our proposed graph-based framework performing an experimental study over the achieved results utilizing a set of known malicious samples that are indexed into malware families.;;;https://dl.acm.org/doi/10.1145/3472410.3472417;;;Software AND Engineering
The Effect of Google Search on Software Security: Unobtrusive Security Interventions via Content Re-ranking;;;['Felix Fischer', 'Yannick Stachelscheid', 'Jens Grossklags'];;;November 2021;;;CCS '21: Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security;;;Google Search is where most developers start their Web journey looking for code examples to reuse. It is highly likely that code that is linked to the top results will be among those candidates that find their way into production software. However, as a large amount of secure and insecure code has been identified on the Web, the question arises how the providing webpages are ranked by Google and whether the ranking has an effect on software security. We investigate how secure and insecure cryptographic code examples from Stack Overflow are ranked by Google Search. Our results show that insecure code ends up in the top results and is clicked on more often. There is at least a 22.8% chance that one out of the top three Google Search results leads to insecure code. We introduce security-based re-ranking, where the rank of Google Search is updated based on the security and relevance of the provided source code in the results. We tested our re-ranking approach and compared it to Google's original ranking in an online developer study. Participants that used our modified search engine to look for help online submitted more secure and functional results, with statistical significance. In contrast to prior work on helping developers to write secure code, security-based re-ranking completely eradicates the requirement for any action performed by developers. Our intervention remains completely invisible, and therefore the probability of adoption is greatly increased. We believe security-based re-ranking allows Internet-wide improvement of code security and prevents the far-reaching spread of insecure code found on the Web.;;;https://dl.acm.org/doi/10.1145/3460120.3484763;;;Software AND Engineering
AutoGrad: Automated Grading Software for Mobile Game Assignments in SuaCode Courses;;;['Prince Steven Annor', 'Edwin Kayang', 'Samuel Boateng', 'George Boateng'];;;November 2021;;;CSERC '21: Proceedings of the 10th Computer Science Education Research Conference;;;Automatic grading systems have been in existence since the turn of the half-century. Several systems have been developed in the literature with either static analysis and dynamic analysis or a hybrid of both methodologies for computer science courses. This paper presents AutoGrad, a novel portable cross-platform automatic grading system for graphical Processing programs developed on Android smartphones during an online course. AutoGrad uses Processing, which is used in the emerging Interactive Media Arts, and pioneers grading systems utilized outside the sciences to assist tuition in the Arts. It also represents the first system built and tested in an African context across over thirty-five countries across the continent. This paper first explores the design and implementation of AutoGrad. AutoGrad employs APIs to download the assignments from the course platform, performs static and dynamic analysis on the assignment to evaluate the graphical output of the program, and returns the grade and feedback to the student. It then evaluates AutoGrad by analyzing data collected from the two online cohorts of 1000+ students of our SuaCode smartphone-based course. From the analysis and students’ feedback, AutoGrad is shown to be adequate for automatic assessment, feedback provision to students, and easy integration for both cloud and standalone usage by reducing the time and effort required in grading the 4 assignments required to complete the course.;;;https://dl.acm.org/doi/10.1145/3507923.3507954;;;Software AND Engineering
Optimizing Energy Efficiency of QoS-Based Routing in Software-Defined Networks;;;['Yu Zhang', 'Sergei Gorlatch'];;;November 2021;;;Q2SWinet '21: Proceedings of the 17th ACM Symposium on QoS and Security for Wireless and Mobile Networks;;;We address the routing optimization problem in Software-Defined Networks (SDN) to minimize the energy consumption while satisfying multiple QoS constraints of network services. In this paper, we: 1) formally define the problem of routing optimization in SDN under multiple QoS constraints, and 2) propose a novel routing optimization algorithm that improves the classical Shuffled Frog Leaping Algorithm (SFLA). We develop a two-phase procedure for implementing our proposed routing optimization algorithm in an SDN environment. We report the results of experiments using the Mininet simulation framework that confirm the advantages of our proposed QoS routing optimization algorithm as compared to the state-of-the-art solutions.;;;https://dl.acm.org/doi/10.1145/3479242.3487325;;;Software AND Engineering
An Archive of Interfaces: Exploring the Potential of Emulation for Software Research, Pedagogy, and Design;;;['Daniel Cardoso-Llach', 'Eric Kaltman', 'Emek Erdolu', 'Zachary Furste'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;This paper explores the potential of distributed emulation networks to support research and pedagogy into historical and sociotechnical aspects of software. Emulation is a type of virtualization that re-creates the conditions for a piece of legacy software to operate on a modern system. The paper first offers a review of Computer-Supported Cooperative Work (CSCW), Human-Computer Interaction (HCI), and Science and Technology Studies (STS) literature engaging with software as historical and sociotechnical artifacts, and with emulation as a vehicle of scholarly inquiry. It then documents the novel use of software emulations as a pedagogical resource and research tool for legacy software systems analysis. This is accomplished through the integration of the Emulation as a Service Infrastructure (EaaSI) distributed emulation network into a university-level course focusing on computer-aided design (CAD). The paper offers a detailed case study of a pedagogical experience oriented to incorporate emulations into software research and learning. It shows how emulations allow for close, user-centered analyses of software systems that highlight both their historical evolution and core interaction concepts, and how they shape the work practices of their users.;;;https://dl.acm.org/doi/10.1145/3476035;;;Software AND Engineering
Prioritizing the Software Development Methodologies in Online Gig Economy Project Using Analytic Hierarchy Process;;;['Yoga Afif Nurrahman', 'Yudho Giri Sucahyo', 'Arfive Gandhi'];;;April 2021;;;ICGDA '21: Proceedings of the 2021 4th International Conference on Geoinformatics and Data Analysis;;;Deciding on the software development methodology in the online gig economy project is critical due to indirect communication and limited time. Each methodology has its weaknesses and strengths in the design and operation. The accuracy in choosing the methodology will reduce time and costs, minimize excess and risk exposure, manage uncertainty, improve quality, improve client relationships, and provide better tracking and control projects. Inaccurate software development methodology selection can impact longer project development time, assignment mismatches, design errors, and project failure. This research performed Analytic Hierarchy Process (AHP) to decompose people's perception quantitatively through an online questionnaire with 15 gig workers in the software development area. This research found Requirement on a project as the highest priority when developing software in the online gig economy, followed by User Involvement, Documentation, and Personnel. Meanwhile, Requirement Clarity got the most prioritized sub-factors in Requirement. Therefore, clients and gig workers should clarify all project requirements since they will not physically meet during the project.;;;https://dl.acm.org/doi/10.1145/3465222.3465236;;;Software AND Engineering
Research on Design of Functional Safety Monitoring of Intelligent Driving Vehicle Software Architecture;;;['Yafei Zhang', 'Xiaojun Kuang', 'Wenxia Xi'];;;December 2021;;;ACAI '21: Proceedings of the 2021 4th International Conference on Algorithms, Computing and Artificial Intelligence;;;In order to ensure the high reliability and safety of the automotive software architecture, a functional safety monitoring system for OS and COM modules is proposed. In accordance with ISO 26262 functional safety development requirements, the system adds functional safety monitoring modules to traditional OS and COM modules. Each software component in the system is designed with functional safety monitoring and failure handling methods, which can fully identify the failure of software components and enter a safe state. Taking the MCU motor status signal as the research object, the working principle of the OS and COM module functional safety monitoring system are explained, showing that the OS and COM module functional safety monitoring system can effectively reduce the failure probability and achieve the requirements of high ASIL level for functional safety of intelligent driving vehicles.;;;https://dl.acm.org/doi/10.1145/3508546.3508562;;;Software AND Engineering
Effective simulation and debugging for a high-level hardware language using software compilers;;;['Clément Pit-Claudel', 'Thomas Bourgeat', 'Stella Lau', 'Arvind', 'Adam Chlipala'];;;April 2021;;;ASPLOS '21: Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Rule-based hardware-design languages (RHDLs) promise to enhance developer productivity by offering convenient abstractions. Advanced compiler technology keeps the cost of these abstractions low, generating circuits with excellent area and timing properties.   Unfortunately, comparatively little effort has been spent on building simulators and debuggers for these languages, so users often simulate and debug their designs at the RTL level. This is problematic because generated circuits typically suffer from poor readability, as compiler optimizations can break high-level abstractions. Worse, optimizations that operate under the assumption that concurrency is essentially free yield faster circuits but often actively hurt simulation performance on platforms with limited concurrency, like desktop computers or servers.   This paper demonstrates the benefits of completely separating the simulation and synthesis pipelines. We propose a new approach, yielding the first compiler designed for effective simulation and debugging of a language in the Bluespec family. We generate cycle-accurate C++ models that are readable, compatible with a wide range of traditional software-debugging tools, and fast (often two to three times faster than circuit-level simulation). We achieve these results by optimizing for sequential performance and using static analysis to minimize redundant work. The result is a vastly improved hardware-design experience, which we demonstrate on embedded processor designs and DSP building blocks using performance benchmarks and debugging case studies.;;;https://dl.acm.org/doi/10.1145/3445814.3446720;;;Software AND Engineering
LightSys: lightweight and efficient CI system for improving integration speed of software;;;['Geunsik Lim', 'MyungJoo Ham', 'Jijoong Moon', 'Wook Song'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;The complexity and size increase of software has extended the delay for developers as they wait for code analysis and code merge. With the larger and more complex software, more developers nowadays are developing software with large source code repositories. The tendency for software platforms to immediately update software packages with feature updates and bug-fixes is a significant obstacle. Continuous integration systems may help prevent software flaws during the active development of software packages, even when they are deployed and updated frequently. Herein, we present a portable and modular code review automation system that inspects incoming code changes such as code format and style, performance regression, static analysis, build and deployment tests, and dynamic analysis before merging and changing code. The proposed mechanisms are sufficiently lightweight to be hosted on a regular desktop computer even for numerous developers. The resulting reduced costs allow developers to apply the proposed mechanism to many source code repositories. Experimental results demonstrate that the proposed mechanism drastically reduces overheads and improves usability compared with conventional mechanisms: execution time (6x faster), CPU usage (40% lower), memory consumption (1/180), and no out-of-memory occurrence.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00009;;;Software AND Engineering
Programming and Synthesis for Software-defined FPGA Acceleration: Status and Future Prospects;;;['Yi-Hsiang Lai', 'Ecenur Ustun', 'Shaojie Xiang', 'Zhenman Fang', 'Hongbo Rong', 'Zhiru Zhang'];;;None;;;ACM Transactions on Reconfigurable Technology and Systems;;;FPGA-based accelerators are increasingly popular across a broad range of applications, because they offer massive parallelism, high energy efficiency, and great flexibility for customizations. However, difficulties in programming and integrating FPGAs have hindered their widespread adoption. Since the mid 2000s, there has been extensive research and development toward making FPGAs accessible to software-inclined developers, besides hardware specialists. Many programming models and automated synthesis tools, such as high-level synthesis, have been proposed to tackle this grand challenge. In this survey, we describe the progression and future prospects of the ongoing journey in significantly improving the software programmability of FPGAs. We first provide a taxonomy of the essential techniques for building a high-performance FPGA accelerator, which requires customizations of the compute engines, memory hierarchy, and data representations. We then summarize a rich spectrum of work on programming abstractions and optimizing compilers that provide different trade-offs between performance and productivity. Finally, we highlight several additional challenges and opportunities that deserve extra attention by the community to bring FPGA-based computing to the masses.;;;https://dl.acm.org/doi/10.1145/3469660;;;Software AND Engineering
Centris: A Precise and Scalable Approach for Identifying Modified Open-Source Software Reuse;;;['Seunghoon Woo', 'Sunghan Park', 'Seulbae Kim', 'Heejo Lee', 'Hakjoo Oh'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Open-source software (OSS) is widely reused as it provides convenience and efficiency in software development. Despite evident benefits, unmanaged OSS components can introduce threats, such as vulnerability propagation and license violation. Unfortunately, however, identifying reused OSS components is a challenge as the reused OSS is predominantly modified and nested. In this paper, we propose CENTRIS, a precise and scalable approach for identifying modified OSS reuse. By segmenting an OSS code base and detecting the reuse of a unique part of the OSS only, CENTRIS is capable of precisely identifying modified OSS reuse in the presence of nested OSS components. For scalability, CENTRIS eliminates redundant code comparisons and accelerates the search using hash functions. When we applied CENTRIS on 10,241 widely-employed GitHub projects, comprising 229,326 versions and 80 billion lines of code, we observed that modified OSS reuse is a norm in software development, occurring 20 times more frequently than exact reuse. Nonetheless, CENTRIS identified reused OSS components with 91% precision and 94% recall in less than a minute per application on average, whereas a recent clone detection technique, which does not take into account modified and nested OSS reuse, hardly reached 10% precision and 40% recall.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00083;;;Software AND Engineering
Application of back-translation: a transfer learning approach to identify ambiguous software requirements;;;['Ishan Mani Subedi', 'Maninder Singh', 'Vijayalakshmi Ramasamy', 'Gursimran Singh Walia'];;;April 2021;;;ACM SE '21: Proceedings of the 2021 ACM Southeast Conference;;;Ambiguous requirements are problematic in requirement engineering as various stakeholders can debate on the interpretation of the requirements leading to a variety of issues in the development stages. Since requirement specifications are usually written in natural language, analyzing ambiguous requirements is currently a manual process as it has not been fully automated to meet the industry standards. In this paper, we used transfer learning by using ULMFiT where we pre-trained our model to a general-domain corpus and then fine-tuned it to classify ambiguous vs unambiguous requirements (target task). We then compared its accuracy with machine learning classifiers like SVM, Linear Regression, and Multinomial Naive Bayes. We also used back translation (BT) as a text augmentation technique to see if it improved the classification accuracy. Our results showed that ULMFiT achieved higher accuracy than SVM (Support Vector Machines), Logistic Regression and Multinomial Naive Bayes for our initial data set. Further by augmenting requirements using BT, ULMFiT got a higher accuracy than SVM, Logistic Regression, and Multinomial Naive Bayes classifier, improving the initial performance by 5.371%. Our proposed research provides some promising insights on how transfer learning and text augmentation can be applied to small data sets in requirements engineering.;;;https://dl.acm.org/doi/10.1145/3409334.3452068;;;Software AND Engineering
Design of On-orbit Software Reconfiguration for a General Signal Processing Platform Based on SOC Chip;;;['Shengming Liang', 'Kang Wang', 'Haiyuan Wang', 'Ruichen Wang', 'Rui Guo'];;;April 2021;;;ICCAI '21: Proceedings of the 2021 7th International Conference on Computing and Artificial Intelligence;;;This paper proposes an on-orbit software reconfiguration method for a general signal processing platform based on SOC chip. The SOC-based reconfiguration technology can be flexibly switched or modified, depending upon different signal processing algorithms or front-end functions. It also provides rapidly on-orbit response ability, which depending on user's requirements. This method performs segment allocation for the configuration program partition and cache program partition, based on the Xilinx ZYNQ series SOC chip system architecture. And it separates the ARM0, ARM1, and FPGA uplink injection software program through the look-up table, then reprograms the bootloader which generates automatically by compiler. Finally, it completes the injection software storage and reconfiguration through the above operations. This method provides an autonomous controllable and functional scalable basis for the spacecraft software defined radio systems in the future.;;;https://dl.acm.org/doi/10.1145/3467707.3467765;;;Software AND Engineering
Application Threats to Exploit Northbound Interface Vulnerabilities in Software Defined Networks;;;['Bilal Rauf', 'Haider Abbas', 'Muhammad Usman', 'Tanveer A. Zia', 'Waseem Iqbal', 'Yawar Abbas', 'Hammad Afzal'];;;None;;;ACM Computing Surveys;;;Software Defined Networking (SDN) is an evolving technology that decouples the control functionality from the underlying hardware managed by the control plane. The application plane supports programmers to develop numerous applications (such as networking, management, security, etc.) that can even be executed from remote locations. Northbound interface (NBI) bridges the control and application planes to execute the third-party applications business logic. Due to the software bugs in applications and existing vulnerabilities such as illegal function calling, resource exhaustion, lack of trust, and so on, NBIs are susceptible to different attacks. Based on the extensive literature review, we have identified that the researchers and academia have mainly focused on the security of the control plane, data plane, and southbound interface (SBI). NBI, in comparison, has received far less attention. In this article, the security of the least explored, but a critical component of the SDN architecture, i.e., NBI, is analyzed. The article provides a brief overview of SDN, followed by a detailed discussion on the categories of NBI, vulnerabilities of NBI, and threats posed by malicious applications to NBI. Efforts of the researchers to counter malicious applications and NBI issues are then discussed in detail. The standardization efforts for the single acceptable NBI and security requirements of SDN by Open Networking Foundation (ONF) are also presented. The article concludes with the future research directions for the security of a single acceptable NBI.;;;https://dl.acm.org/doi/10.1145/3453648;;;Software AND Engineering
An ISO/IEC 25010 Based Software Quality Assessment of a Faculty Research Productivity Monitoring and Prediction System;;;['Ranie Baul Canlas', 'Keno Cruz Piad', 'Ace Carpio Lagman'];;;December 2021;;;ICIT '21: Proceedings of the 2021 9th International Conference on Information Technology: IoT and Smart City;;;A known primary indicator of performance of academic institutions is the productivity of their academic personnel in terms of research outputs. Monitoring the outputs of faculty requires systematic and technology-based methods for easy access and creation of repository. This study generally aimed to provide solution in monitoring the research undertakings of faculty through the development of a system for effective and efficient management of research outputs. Specifically, it tried to identify necessary features that can be integrated in the development of research productivity monitoring and prediction system; assess system performance based from the parameters of ISO/IEC 25010 Software Quality Model; and identify differences on the assessment of the respondents in terms of evaluation of software quality. The key features of the developed system include support submission of paper proposals, review and approval of proposal, monitoring of ongoing approved papers, utilization of research outputs, research outputs repository and predictive analysis. The assessment of the expert-respondents resulted to a grand mean of 3.87 which corresponds to a verbal interpretation of “Strongly Agree”. Results showed that the system has the necessary features in determining research productivity of faculty along with the high evaluation of system performance based from the assessment of expert-respondents.;;;https://dl.acm.org/doi/10.1145/3512576.3512619;;;Software AND Engineering
Application of Computer Software in Pop Music Teaching;;;['Haidan Cao'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;In recent years, with the rapid development of computer technology and multimedia technology, the information technology represented by it has been widely infiltrated into the teaching of various subjects, including the teaching of pop singing major in Chinese universities. Music is the art of sound and hearing. The particularity of music leads to the important position of information technology in the pop singing major. However, in terms of the application in the practical teaching of pop singing major, the audience of computer software teaching is not wide enough, and there are still many problems. This paper discusses the benefits of computer software to the teaching of pop music teachers, and puts forward the test method (a group of test questions to measure the actual situation of a certain educational phenomenon, so as to collect data for Research), mainly through the study and research of computer music software, this paper discusses some methods of using computer music software to assist pop singing teaching, so as to solve the shortcomings of traditional pop singing teaching methods. The purpose is to study the practicability of computer software teaching technology in pop singing major. This paper takes sibeliu, Cubase and logic computer music software as examples to explain the practical application of computer music software in the teaching of pop singing specialty, so that we can understand the practical methods of computer music software in pop singing teaching. This paper introduces the basic situation of some computer music software, the function and characteristics of computer music software, and the advantages of application in pop singing teaching. It also carries out the experimental analysis of the application of computer software teaching technology in the teaching of pop singing, and discusses the way and process of computer music software to assist the teaching of pop singing, experimental research shows that learners are most interested in "automatic accompaniment", accounting for 58.2%. The average score of the experimental group using Sibelius music teaching software is 78.66, and the average score of the control group using traditional teaching media is 74.32. The integration of this kind of software into classroom teaching can improve the enthusiasm of learners in learning pop singing major. The integration of computer software into pop singing teaching can not only expand the content of College pop singing teaching curriculum system, but also conform to the current wave of teaching reform widely carried out in Colleges and universities.;;;https://dl.acm.org/doi/10.1145/3482632.3483086;;;Software AND Engineering
Software-defined cooking using a microwave oven;;;['Haojian Jin', 'Jingxian Wang', 'Swarun Kumar', 'Jason Hong'];;;December 2021;;;Communications of the ACM;;;Despite widespread popularity, today's microwave ovens are limited in their cooking capabilities, given that they heat food blindly, resulting in a nonuniform and unpredictable heating distribution. We present software-defined cooking (SDC), a low-cost closed-loop microwave oven system that aims to heat food in a software-defined thermal trajectory. SDC achieves this through a novel high-resolution heat sensing and actuation system that uses microwave-safe components to augment existing microwaves. SDC first senses the thermal gradient by using arrays of neon lamps that are charged by the electromagnetic (EM) field a microwave produces. SDC then modifies the EM-field strength to desired levels by accurately moving food on a programmable turntable toward sensed hot and cold spots. To create a more skewed arbitrary thermal pattern, SDC further introduces two types of programmable accessories: A microwave shield and a susceptor. We design and implement one experimental test bed by modifying a commercial off-the-shelf microwave oven. Our evaluation shows that SDC can programmatically create temperature deltas at a resolution of 21°C with a spatial resolution of 3 cm without the programmable accessories, and 183°C with them. We further demonstrate how an SDC-enabled microwave can be enlisted to perform unexpected cooking tasks: Cooking meat and fat in bacon discriminatively and heating milk uniformly.;;;https://dl.acm.org/doi/10.1145/3491196;;;Software AND Engineering
AutoTrainer: An Automatic DNN Training Problem Detection and Repair System;;;['Xiaoyu Zhang', 'Juan Zhai', 'Shiqing Ma', 'Chao Shen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;With machine learning models especially Deep Neural Network (DNN) models becoming an integral part of the new intelligent software, new tools to support their engineering process are in high demand. Existing DNN debugging tools are either post-training which wastes a lot of time training a buggy model and requires expertises, or limited on collecting training logs without analyzing the problem not even fixing them. In this paper, we propose AutoTrainer, a DNN training monitoring and automatic repairing tool which supports detecting and auto-repairing five commonly seen training problems. During training, it periodically checks the training status and detects potential problems. Once a problem is found, AutoTrainer tries to fix it by using built-in state-of-the-art solutions. It supports various model structures and input data types, such as Convolutional Neural Networks (CNNs) for image and Recurrent Neural Networks (RNNs) for texts. Our evaluation on 6 datasets, 495 models show that AutoTrainer can effectively detect all potential problems with 100% detection rate and no false positives. Among all models with problems, it can fix 97.33% of them, increasing the accuracy by 47.08% on average.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00043;;;Software AND Engineering
Ants Doing Legwork: Investigating Motivators for Software Development Career Abandonment;;;['Ruan Oliveira', 'Tiago Massoni', 'Narallynne Araújo', 'Camila Sarmento', 'Francielle Santos'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Context: Career abandonment (turnaway) among software developers may be associated with many factors related to the profession. Identifying and understanding how these factors can affect those professionals is essential for organizations to design more effective retention policies and better understand the phenomenon. Objective: This study aims to identify motivators that may be associated with the turnaway phenomenon among software developers, in addition to dimensions with which those motivators are associated. Method: A qualitative study was conducted with 15 former software developers from different regions of Brazil. Results: We have identified 49 different motivators, among which the most cited were professional stagnation, lack of financial recognition, lack of professional regulation, and work overload, among others. We classified those motivators into seven software engineering dimensions, mainly: software engineering professional practice, management, and economics. Conclusion: The results of the study suggest, grounded on the collected qualitative data, a number of hypotheses to further research, relating turnaway to the types of activities of software development. We hope these results contribute to devise effective strategies for organizations to retain developers, additionally minimizing the social cost of turnaway to those developers.;;;https://dl.acm.org/doi/10.1145/3474624.3474644;;;Software AND Engineering
Finding Efficiency in Approach Selection in Software Development and Project Management in Bangladesh IT Industry;;;['Olive Mazumder', 'Marshia Mostafiz Mim', 'Abu Junaid Tanmay', 'Lutfa Noor Labony', 'Abhijit Bhowmik', 'Rashidul Hasan Nabil'];;;March 2022;;;ICCA '22: Proceedings of the 2nd International Conference on Computing Advancements;;;Here we have tried to find out suitable methods for IT companies of different ages. Some subject companies were chosen and given a survey form from which we got some data about different aged IT companies using different development methods. The models were between agile, agile process model, and other models. Through the survey, we found some data which can help different aged IT companies find the right model for their project development. The data analysis shows the suitable project method for different age companies. The subject companies also listed why they use their method and how long have been they using it. This survey result will help companies that are struggling to grow or companies which are about to start their project method. A good project method can bring success to a company.;;;https://dl.acm.org/doi/10.1145/3542954.3542992;;;Software AND Engineering
Application of Computer Software Simulation Technology in Physics Experiment Teaching;;;['Yanyun Zhang'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the advent of the information age, modern educational technology has been increasingly applied to all aspects of teaching and has become a powerful tool for carrying out teaching research and educational reform. The Physics Experiment Center of China University of Geosciences (Beijing) has been trying to apply computer simulation technology to all aspects of university physics experiment teaching in recent years, and these attempts have achieved good teaching results. Use information technology as a tool to achieve new changes in the course content, students’ learning methods, teachers’ teaching methods and interactive display between teachers and students after class, and optimize various factors and links in the education process. This is the essence of digital teaching. Taking into account the main problems of physics experiment education, experiment demonstration videos and animation simulation software were introduced into the pre-teaching course preview of physics experiment education, and small data processing software designed by computer software simulation technology was adopted by physics experiment. Based on the practical experience of the experiment center, this article introduces the characteristics of computer software simulation technology in physics experiments. Compared with actual physics experiments, this paper analyzes the application, necessity and limitations of computer software simulation technology in physics. At this stage, we will explain and discuss the advantages and existing problems of experimental education simulation technology, discuss educational methods and improve the ideas of computer software simulation technology in physics experiment teaching.;;;https://dl.acm.org/doi/10.1145/3482632.3483197;;;Software AND Engineering
Did you do your homework?: raising awareness on software fairness and discrimination;;;['Max Hort', 'Federica Sarro'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Machine Learning is a vital part of various modern day decision making software. At the same time, it has shown to exhibit bias, which can cause an unjust treatment of individuals and population groups. One method to achieve fairness in machine learning software is to provide individuals with the same degree of benefit, regardless of sensitive attributes (e.g., students receive the same grade, independent of their sex or race). However, there can be other attributes that one might want to discriminate against (e.g., students with homework should receive higher grades). We will call such attributes anti-protected attributes. When reducing the bias of machine learning software, one risks the loss of discriminatory behaviour of anti-protected attributes. To combat this, we use grid search to show that machine learning software can be debiased (e.g., reduce gender bias) while also improving the ability to discriminate against anti-protected attributes.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678568;;;Software AND Engineering
FRUGAL: unlocking semi-supervised learning for software analytics;;;['Huy Tu', 'Tim Menzies'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Standard software analytics often involves having a large amount of data with labels in order to commission models with acceptable performance. However, prior work has shown that such requirements can be expensive, taking several weeks to label thousands of commits, and not always available when traversing new research problems and domains. Unsupervised Learning is a promising direction to learn hidden patterns within unlabelled data, which has only been extensively studied in defect prediction. Nevertheless, unsupervised learning can be ineffective by itself and has not been explored in other domains (e.g., static analysis and issue close time). Motivated by this literature gap and technical limitations, we present FRUGAL, a tuned semi-supervised method that builds on a simple optimization scheme that does not require sophisticated (e.g., deep learners) and expensive (e.g., 100% manually labelled data) methods. FRUGAL optimizes the unsupervised learner's configurations (via a simple grid search) while validating our design decision of labelling just 2.5% of the data before prediction. As shown by the experiments of this paper FRUGAL outperforms the state-of-the-art adoptable static code warning recognizer and issue closed time predictor, while reducing the cost of labelling by a factor of 40 (from 100% to 2.5%). Hence we assert that FRUGAL can save considerable effort in data labelling especially in validating prior work or researching new problems. Based on this work, we suggest that proponents of complex and expensive methods should always baseline such methods against simpler and cheaper alternatives. For instance, a semi-supervised learner like FRUGAL can serve as a baseline to the state-of-the-art software analytics.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678617;;;Software AND Engineering
Persistence of Time Management Behavior of Students and Its Relationship with Performance in Software Projects;;;['Joonas Häkkinen', 'Petri Ihantola', 'Matti Luukkainen', 'Antti Leinonen', 'Juho Leinonen'];;;August 2021;;;ICER 2021: Proceedings of the 17th ACM Conference on International Computing Education Research;;;Teachers often preach for their students to start working on assignments early. There is even a fair amount of scientific evidence that starting early is beneficial for learning. In this work, we investigate students’ time management behavior in a second-year project-based software engineering course. In the course, students work on a software project in small groups of four to six students. We study time management from multiple angles. Firstly, we conduct an exploratory factor analysis and study how different time management related behavioral metrics are related to one another, for example, whether individual students’ time management practices in the second-year group project-based course are similar to their earlier time management practices in first-year courses where students work on assignments individually. Understanding how students’ previous time management behavior is manifested in later project-based courses would be beneficial when designing project-based education. Secondly, we study whether students’ time management practices affect the peer-review scores they get from their group members. Lastly, we explore how time management affects course performance. Our findings suggest that time management behavior, even from courses taken in the past, can be used to predict how students perform in future courses.;;;https://dl.acm.org/doi/10.1145/3446871.3469767;;;Software AND Engineering
SoMeSci- A 5 Star Open Data Gold Standard Knowledge Graph of Software Mentions in Scientific Articles;;;['David Schindler', 'Felix Bensmann', 'Stefan Dietze', 'Frank Krüger'];;;October 2021;;;CIKM '21: Proceedings of the 30th ACM International Conference on Information &amp; Knowledge Management;;;Knowledge about software used in scientific investigations is important for several reasons, for instance, to enable an understanding of provenance and methods involved in data handling. However, software is usually not formally cited, but rather mentioned informally within the scholarly description of the investigation, raising the need for automatic information extraction and disambiguation. Given the lack of reliable ground truth data, we present SoMeSci-Software Mentions in Science-a gold standard knowledge graph of software mentions in scientific articles. It contains high quality annotations (IRR: K=.82) of 3756 software mentions in 1367 PubMed Central articles. Besides the plain mention of the software, we also provide relation labels for additional information, such as the version, the developer, a URL or citations. Moreover, we distinguish between different types, such as application, plugin or programming environment, as well as different types of mentions, such as usage or creation. To the best of our knowledge, SoMeSci is the most comprehensive corpus about software mentions in scientific articles, providing training samples for Named Entity Recognition, Relation Extraction, Entity Disambiguation, and Entity Linking. Finally, we sketch potential use cases and provide baseline results.;;;https://dl.acm.org/doi/10.1145/3459637.3482017;;;Software AND Engineering
How the type of customer can influence the product attributes: application of house of quality with multi-user information to improve the functions of a waste collection and treatment service management software;;;['Antonio Maria Coruzzolo', 'Samuele Marinello', 'Francesco Lolli', 'Rita Gamberini'];;;March 2022;;;IEEA '22: Proceedings of the 11th International Conference on Informatics, Environment, Energy and Applications;;;The growth of competitiveness and the globalization of international markets require producers and suppliers of goods and services to commit increasing shares of capital to research and development activities to constantly improve the quality of their offer and to make it flexible with respect to the demand of their customers. Considering the growing complexity of the value chain of products and services for global markets, the need to integrate customer needs into the research and development processes of products and services requires the use of suitable tools for their detection and analysis. The objective of this paper is to describe the application of Quality Function Deployment and its House of Quality tool to optimize a software for the management of waste recovery and disposal processes, with particular reference to the functions dedicated to Waste Electrical and Electronic Equipment (WEEE). Considering the diversity of users who operate through the software, the analysis was also conducted in relation to the specific needs expressed by each category of users. In this way, the main critical elements in the existing configuration and co-designing a new version through the direct involvement of users were identified, evaluating the importance of their needs.;;;https://dl.acm.org/doi/10.1145/3533254.3533258;;;Software AND Engineering
ICME: an informed consent management engine for conformance in smart building environments;;;['Chehara Pathmabandu', 'John Grundy', 'Mohan Baruwal Chhetri', 'Zubair Baig'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Smart buildings can reveal highly sensitive insights about their inhabitants and expose them to new privacy threats and vulnerabilities. Yet, convenience overrides privacy concerns and most people remain ignorant about this issue. We propose a novel Informed Consent Management Engine (ICME) that aims to: (a) increase users’ awareness about privacy issues and data collection practices in their smart building environments, (b) provide fine-grained visibility into privacy conformance and infringement by these devices, (c) recommend and visualise corrective user actions through ”digital nudging”, and (d) support the monitoring and management of personal data disclosure in a shared space. We present a reference architecture for ICME that can be used by software engineers to implement diverse end-user consent management solutions for smart buildings. We also provide a proof-of-concept prototype to demonstrate how the ICME approach works in a shared smart workplace. Demo: <a>https://youtu.be/5y6CdyWAdgY</a>;;;https://dl.acm.org/doi/10.1145/3468264.3473118;;;Software AND Engineering
Research on dynamic evolution method of software service based on trusted agent;;;['Tilei Gao', 'Jinyu He', 'Tengyang Fan', 'Feng Ma'];;;July 2021;;;DSIT 2021: 2021 4th International Conference on Data Science and Information Technology;;;None;;;https://dl.acm.org/doi/10.1145/3478905.3478936;;;Software AND Engineering
Please don't go: increasing women's participation in open source software;;;['Bianca Trinkenreich'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Women represent less than 24% of the software development industry and suffer from various types of prejudice and biases. In Open Source Software projects, despite a variety of efforts to increase diversity and multi-gendered participation, women are even more underrepresented (less than 10%). My research focuses on answering the question: How can OSS communities increase women's participation in OSS projects? I will identify the different OSS career pathways, and develop a holistic view of women's motivations to join or leave OSS, along with their definitions of success. Based on this empirical investigation, I will work together with the Linux Foundation to design attraction and retention strategies focused on women. Before and after implementing the strategies, I will conduct empirical studies to evaluate the state of the practice and understand the implications of the strategies.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00059;;;Software AND Engineering
Muskit: a mutation analysis tool for quantum software testing;;;['Eñaut Mendiluze', 'Shaukat Ali', 'Paolo Arcaini', 'Tao Yue'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Given that quantum software testing is a new area of research, there is a lack of benchmark programs and bugs repositories to assess the effectiveness of testing techniques. To this end, quantum mutation analysis focuses on systematically generating faulty versions of Quantum Programs (QPs), called mutants, using mutation operators. Such mutants can be used as benchmarks to assess the quality of test cases in a test suite. Thus, we present Muskit - a quantum mutation analysis tool for QPs coded in IBM's Qiskit language. Muskit defines mutation operators on gates of QPs and selection criteria to reduce the number of mutants to generate. Moreover, it allows for the execution of test cases on mutants and generation of results for test analyses. Muskit is provided as command line interface, GUI, and web application. We validated Muskit by using it to generate and execute mutants for four QPs. Muskit code: https://github.com/Simula-COMPLEX/muskit Web app: https://qiskitmutantcreatorsrl.pythonanywhere.com/ YouTube Video: EbPHJOK_AEA Artifact Available: https://doi.org/10.5281/zenodo.5288917;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678563;;;Software AND Engineering
Research on intelligent energy-saving design strategy of building thermal comfort experience in western Sichuan based on Climate Consultant software——Take the unlimited bookstore of Santai Middle School in Mianyang city as an example;;;['Junjun Guo', 'Qingchang Chen', 'Zhongfang An', 'Xuanyu Zhu'];;;January 2022;;;BIC 2022: 2022 2nd International Conference on Bioinformatics and Intelligent Computing;;;Nowadays, cultural self-confidence is increasingly emphasized. The architectural field is also paying more and more attention to traditional Chinese architecture. The contemporary expression of the spatial characteristics of traditional buildings is especially valued. This article discusses the modern architectural space creation strategy based on the traditional architectural space composition of Western Sichuan. In addition, it was verified in practice with the unlimited bookstore project of Santai Middle School in Mianyang City. First, we conducted an analysis of climate adaptability in western Sichuan region through the Climate Consultant software. Then we adopted a combination of modern construction technology and materials to make the building sustainable. Finally, we come up with the modern translation strategy, which is based on the space of traditional buildings in Western Sichuan. That is, the modern translation of column and tie construction, reproduction of life scenes in the space under the eaves, and construction of the core space of the courtyard [1]. It is expected to provide a certain reference for the inheritance and development of traditional architecture in Western Sichuan.;;;https://dl.acm.org/doi/10.1145/3523286.3524537;;;Software AND Engineering
Towards a software system for spatio-temporal authorization;;;['Mustafa Al Lail', 'Marshal Moncivais', 'Miguelangel Trevino'];;;None;;;Journal of Computing Sciences in Colleges;;;The increasing dependency on digital technology has made the concept of data security an important concern. Not only how information is accessed, but also where and when have become important considerations in cyber-security. Certain situations exist where it is necessary to restrict access based on time and location. An example is a policy for a medical institution where doctors can only access patient records at hospitals during their shifts. The Generalized Spatio-Temporal Role-Based Access Control model (GSTRBAC) determines users' access to resources based on such information. This paper describes a software architecture and its current implementation of the GSTRBAC model.;;;https://dl.acm.org/doi/10.5555/3469581.3469586;;;Software AND Engineering
Fundamentals of Physical Computing: Determining Key Concepts in Embedded Systems and Hardware/Software Co-Design;;;['Mareen Przybylla', 'Andreas Grillenberger'];;;October 2021;;;WiPSCE '21: Proceedings of the 16th Workshop in Primary and Secondary Computing Education;;;Studies have shown that teachers find it difficult to prepare contents in the area of embedded systems and hardware/software co-design for school students. The goal of this paper is to support them by obtaining a clearly structured representation of the key concepts from this area in order to be able to derive concrete competence goals based on them later on. We apply a method for identifying the key concepts of a subject area within computer science, which has already been tested in the field of data management, to embedded systems and the related hardware/software co-design. Here, we present the procedure (literature selection, content analysis, concept clustering, and structuring) and the results of this process.;;;https://dl.acm.org/doi/10.1145/3481312.3481352;;;Software AND Engineering
The Implementation of Video DES Encryption Engine in FPGA;;;['Lijun Liu'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;In DVB and VOD system, the DES and Triple DES(3DES) algorithm are still be widely used for MPEG-2 packets encryption during the video traffic transmission. This paper specifies one DES and 3DES mixture encryption engine. This engine supports video DES and 3DES encryption at the same time and it also supports both CBC and ECB mode simultaneously. In this engine, the encryption algorithms and modes can be switched seamless for different MPEG-2 packets. This engine is implemented in FPGA based on pipeline structure and can support higher performance with less FPGA resource.;;;https://dl.acm.org/doi/10.1145/3494885.3494905;;;Software AND Engineering
Bluejay: a cross-tooling audit framework for Agile software teams;;;['César García', 'Alejandro Guerrero', 'Joshua Zeitsoff', 'Srujay Korlakunta', 'Pablo Fernandez', 'Armando Fox', 'Antonio Ruiz-Cortés'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Agile software teams are expected to follow a number of specific Team Practices (TPs) during each iteration, such as estimating the effort ("points") required to complete user stories and coordinating the management of the codebase with the delivery of features. For software engineering instructors trying to teach such TPs to student teams, manually auditing teams if teams are following the TPs and improving over time is tedious, time-consuming and error-prone. It is even more difficult when those TPs involve two or more tools. For example, starting work on a feature in a project-management tool such as Pivotal Tracker should usually be followed relatively quickly by the creation of a feature branch on GitHub. Merging a feature branch on GitHub should usually be followed relatively quickly by deploying the new feature to a staging server for customer feedback. Few systems are designed specifically to audit such TPs, and existing ones, as far as we know, are limited to a single specific tool. We present Bluejay, an open-source extensible platform that uses the APIs of multiple tools to collect raw data, synthesize it into TP measurements, and present dashboards to audit the TPs. A key insight in Bluejay's design is that TPs can be expressed in terminology similar to that used for modeling and auditing Service Level Agreement (SLA) compliance. Bluejay therefore builds on mature tools used in that ecosystem and adapts them for describing, auditing, and reporting on TPs. Bluejay currently consumes data from five different widely-used development tools, and can be customized by connecting it to any service with a REST API. Video showcase available at governify.io/showcase/bluejay;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00038;;;Software AND Engineering
FIXME: enhance software reliability with hybrid approaches in cloud;;;['Jinho Hwang', 'Larisa Shwartz', 'Qing Wang', 'Raghav Batta', 'Harshit Kumar', 'Michael Nidd'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;With the promise of reliability in cloud, more enterprises are migrating to cloud. The process of continuous integration/deployment (CICD) in cloud connects developers who need to deliver value faster and more transparently with site reliability engineers (SREs) who need to manage applications reliably. SREs feed back development issues to developers, and developers commit fixes and trigger CICD to redeploy. The release cycle is more continuous than ever, thus the code to production is faster and more automated. To provide this higher level agility, the cloud platforms become more complex in the face of flexibility with deeper layers of virtualization. However, reliability does not come for free with all these complexities. Software engineers and SREs need to deal with wider information spectrum from virtualized layers. Therefore, providing correlated information with true positive evidences is critical to identify the root cause of issues quickly in order to reduce mean time to recover (MTTR), performance metrics for SREs. Similarity, knowledge, or statistics driven approaches have been effective, but with increasing data volume and types, an individual approach is limited to correlate semantic relations of different data sources. In this paper, we introduce FIXME to enhance software reliability with hybrid diagnosis approaches for enterprises. Our evaluation results show using hybrid diagnosis approach is about 17% better in precision. The results are helpful for both practitioners and researchers to develop hybrid diagnosis in the highly dynamic cloud environment.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00032;;;Software AND Engineering
Development of Test Engine for Chinese Medicine Scale Provide Quantitative Tools for TCM Research;;;['YiFan Wang', 'ChenYu Wang', 'Chongyun Zhou', 'Rongjuan Guo', 'Jialin Wang', 'Jia Xing', 'Zhihao Xu'];;;October 2021;;;ISAIMS '21: Proceedings of the 2nd International Symposium on Artificial Intelligence for Medicine Sciences;;;Through the statistics of test materials, norm (boundary value), implementation program, assignment, scoring, score conversion, factors and conclusion characteristics of traditional Chinese medicine scale, the computerization of scale test is modeled. Finally, according to the model, the intelligent test engine of traditional Chinese medicine scale is constructed and developed through C + + programming. The engine imports the current mature TCM scale from excel, and makes conclusion judgment and report generation according to its entries, factors and conclusion judgment conditions. Through the computerized test of the current mature TCM scale, the results show that the application rate of the engine in the computerized evaluation of TCM scale is 100%, The average time to realize the computerized program generation of the scale is only 28 minutes. By further expanding the use, it is found that the intelligent test engine of traditional Chinese medicine scale has a wide application space in traditional Chinese medicine scale, western medicine scale and psychological scale in line with the rules of this engine, which can effectively promote the theoretical research, clinical application and promotion of traditional Chinese medicine scale.;;;https://dl.acm.org/doi/10.1145/3500931.3501006;;;Software AND Engineering
Survey instruments for "how was your weekend?": software development teams working from home during COVID-19;;;['Courtney Miller', 'Paige Rodeghero', 'Margaret-Anne Storey', 'Denae Ford', 'Thomas Zimmermann'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This document describes the survey instruments from our paper "How Was Your Weekend?" Software Development Teams Working From Home During COVID-19 as well as how to access them.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00101;;;Software AND Engineering
Siri, Write the Next Method;;;['Fengcai Wen', 'Emad Aghajani', 'Csaba Nagy', 'Michele Lanza', 'Gabriele Bavota'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Code completion is one of the killer features of Integrated Development Environments (IDEs), and researchers have proposed different methods to improve its accuracy. While these techniques are valuable to speed up code writing, they are limited to recommendations related to the next few tokens a developer is likely to type given the current context. In the best case, they can recommend a few APIs that a developer is likely to use next. We present FeaRS, a novel retrieval-based approach that, given the current code a developer is writing in the IDE, can recommend the next complete method (i.e., signature and method body) that the developer is likely to implement. To do this, FeaRS exploits "implementation patterns" (i.e., groups of methods usually implemented within the same task) learned by mining thousands of open source projects. We instantiated our approach to the specific context of Android apps. A large-scale empirical evaluation we performed across more than 20k apps shows encouraging preliminary results, but also highlights future challenges to overcome.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00025;;;Software AND Engineering
μSCOPE: A Methodology for Analyzing Least-Privilege Compartmentalization in Large Software Artifacts;;;['Nick Roessler', 'Lucas Atayde', 'Imani Palmer', 'Derrick McKee', 'Jai Pandey', 'Vasileios P. Kemerlis', 'Mathias Payer', 'Adam Bates', 'Jonathan M. Smith', 'Andre DeHon', 'Nathan Dautenhahn'];;;October 2021;;;RAID '21: Proceedings of the 24th International Symposium on Research in Attacks, Intrusions and Defenses;;;By prioritizing simplicity and portability, least-privilege engineering has been an afterthought in OS design, resulting in monolithic kernels where any exploit leads to total compromise. μSCOPE (“microscope”) addresses this problem by automatically identifying opportunities for least-privilege separation. μSCOPE replaces expert-driven, semi-automated analysis with a general methodology for exploring a continuum of security vs. performance design points by adopting a quantitative and systematic approach to privilege analysis. We apply the μSCOPE methodology to the Linux kernel by (1) instrumenting the entire kernel to gain comprehensive, fine-grained memory access and call activity; (2) mapping these accesses to semantic information; and (3) conducting separability analysis on the kernel using both quantitative privilege and overhead metrics. We discover opportunities for orders of magnitude privilege reduction while predicting relatively low overheads—at 15% mediation overhead, overprivilege in Linux can be reduced up to 99.8%—suggesting fine-grained privilege separation is feasible and laying the groundwork for accelerating real privilege separation.;;;https://dl.acm.org/doi/10.1145/3471621.3471839;;;Software AND Engineering
Data-driven extract method recommendations: a study at ING;;;['David van der Leij', 'Jasper Binda', 'Robbert van Dalen', 'Pieter Vallen', 'Yaping Luo', 'Maurício Aniche'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;The sound identification of refactoring opportunities is still an open problem in software engineering. Recent studies have shown the effectiveness of machine learning models in recommending methods that should undergo different refactoring operations. In this work, we experiment with such approaches to identify methods that should undergo an Extract Method refactoring, in the context of ING, a large financial organization. More specifically, we (i) compare the code metrics distributions, which are used as features by the models, between open-source and ING systems, (ii) measure the accuracy of different machine learning models in recommending Extract Method refactorings, (iii) compare the recommendations given by the models with the opinions of ING experts. Our results show that the feature distributions of ING systems and open-source systems are somewhat different, that machine learning models can recommend Extract Method refactorings with high accuracy, and that experts tend to agree with most of the recommendations of the model.;;;https://dl.acm.org/doi/10.1145/3468264.3473927;;;Software AND Engineering
Teaching multivariable calculus and tensor calculus with computer algebra software;;;['Miao-jung Yvonne Ou'];;;December 2020;;;ACM Communications in Computer Algebra;;;To go from calculus of scalar functions of one variable to multivariate calculus of vector-valued functions is a steep learning curve for many students. It takes a lot of practice to get used to the new concepts such as the directional derivatives, the di.erentiability, the many types of first order di.erential operators, parameterization of surfaces and the fundamental theorems of integrals, e.g. the Divergence Theorem and the Stokes Theorem. Along the learning process of mastering the skills, the students often need to check whether the intermediate steps in the tedious calculations are correct. Unfortunately, this is beyond the capability of an ordinary calculator and the answers provided at the end of the books. This is where computer algebra software, such as Mathematica, can come to students' help. With the developed symbolic computation tools, the students can tweak a given problem, solve a new one by hand and then check the answer against the result obtained by using the computer algebra software.;;;https://dl.acm.org/doi/10.1145/3465002.3465005;;;Software AND Engineering
Metamorphic testing of Datalog engines;;;['Muhammad Numair Mansur', 'Maria Christakis', 'Valentin Wüstholz'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Datalog is a popular query language with applications in several domains. Like any complex piece of software, Datalog engines may contain bugs. The most critical ones manifest as incorrect results when evaluating queries—we refer to these as query bugs. Given the wide applicability of the language, query bugs may have detrimental consequences, for instance, by compromising the soundness of a program analysis that is implemented and formalized in Datalog. In this paper, we present the first metamorphic-testing approach for detecting query bugs in Datalog engines. We ran our tool on three mature engines and found 13 previously unknown query bugs, some of which are deep and revealed critical semantic issues.;;;https://dl.acm.org/doi/10.1145/3468264.3468573;;;Software AND Engineering
Application of Intelligent Translation Software for English Translation Based on Data Management Technology;;;['Nan Lu', 'Lei Liu'];;;December 2021;;;ICASIT 2021: 2021 International Conference on Aviation Safety and Information Technology;;;With the development of new technologies related to computers, data in all walks of life has grown rapidly, and people's requirements for the use and storage time of data have become higher and higher, making efficient management of data and accurate and fast querying of data have become a social hot spot. Especially the application of data management technology in English-to-English intelligent translation software has attracted the attention of many educators. This article mainly summarizes the characteristics of data management technology and English-to-English intelligent translation software, as well as the advantages and main applications of data management technology in English-to-English intelligent translation software. Based on this, this article issued 300 questionnaires based on the current situation of college students using English-to-English intelligent translation software. The analysis of the survey results showed that: 81.15% of the people who have used Youdao's English-to-English intelligent translation software, it is the most used English-to-English intelligent translation software, which shows that the choices of different individuals are affected by personal preferences; the number of language majors using Sogou's English translation intelligent translation software is 34.57%, and the number of non-language majors using the software is only 10.26%, indicating that language majors have a higher demand for translation software; Although computer translation is stable, only 38 people use the English-to-English intelligent translation software through the computer, and 143 people use the English-to-English intelligent translation software through the mobile phone, indicating that students tend to choose more convenient equipment for English translation learning.;;;https://dl.acm.org/doi/10.1145/3510858.3510992;;;Software AND Engineering
Software Design of Shared Cabinet System Based on Raspberry Pi;;;['Yijing Ren', 'Ling Long'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;In order to make full use of social idle resources and maximize the usage and efficiency of resources. It is necessary to design and implement an intelligent sharing cabinet that can be placed in community and university dormitories. Users can share idle items or take items shared by others, which makes it convenient for people in urgent need of goods and people with idle goods. Through the form of “sharing platform + entity”, we get to develop the national sharing economy. According to the functional requirements, this paper mainly introduces the software design of the main control processing module, including the development of Raspberry Pi and the software design of human-computer interface. The voltage stabilizing module, Internet of things module, display module and cabinet entity are combined and debugged, so that users can scan the QR code to access. It achieves the purpose of what you see is what you get, to achieve resource saving.;;;https://dl.acm.org/doi/10.1145/3495018.3495045;;;Software AND Engineering
Please don't go: a comprehensive approach to increase women's participation in open source software;;;['Bianca Trinkenreich'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Women represent less than 24% of employees in the software development industry and experience various types of prejudice and bias. Despite various efforts to increase diversity and multi-gendered participation, women are even more under-represented in Open Source Software (OSS) projects. In my PhD, I investigate the following question: How can OSS communities increase women's participation in their projects? I will identify different OSS career pathways and develop a holistic view of women's motivations to join or leave OSS, as well as their definitions of success. Based on this empirical investigation, I will work together with the Linux Foundation to design attraction and retention strategies focused on women. Before and after implementing the strategies, I will conduct empirical studies to evaluate the state of the practice and understand the implications of the strategies.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00131;;;Software AND Engineering
AutoDSE: Enabling Software Programmers to Design Efficient FPGA Accelerators;;;['Atefeh Sohrabizadeh', 'Cody Hao Yu', 'Min Gao', 'Jason Cong'];;;None;;;ACM Transactions on Design Automation of Electronic Systems;;;Adopting FPGA as an accelerator in datacenters is becoming mainstream for customized computing, but the fact that FPGAs are hard to program creates a steep learning curve for software programmers. Even with the help of high-level synthesis (HLS), accelerator designers still have to manually perform code reconstruction and cumbersome parameter tuning to achieve optimal performance. While many learning models have been leveraged by existing work to automate the design of efficient accelerators, the unpredictability of modern HLS tools becomes a major obstacle for them to maintain high accuracy. To address this problem, we propose an automated DSE framework—AutoDSE—that leverages a bottleneck-guided coordinate optimizer to systematically find a better design point. AutoDSE detects the bottleneck of the design in each step and focuses on high-impact parameters to overcome it. The experimental results show that AutoDSE is able to identify the design point that achieves, on the geometric mean, 19.9× speedup over one CPU core for MachSuite and Rodinia benchmarks. Compared to the manually optimized HLS vision kernels in Xilinx Vitis libraries, AutoDSE can reduce their optimization pragmas by 26.38× while achieving similar performance. With less than one optimization pragma per design on average, we are making progress towards democratizing customizable computing by enabling software programmers to design efficient FPGA accelerators.;;;https://dl.acm.org/doi/10.1145/3494534;;;Software AND Engineering
The Construction of Software Technology Course System Based on Modern Information Technology;;;['Guohua Xiong', 'Yanfen Shen'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the requirement of "doing a good job in the special work of higher vocational enrollment expansion" proposed by the Ministry of Education, The enrollment of "modern apprenticeship" in vocational colleges has become one of the key points in the expansion of enrollment. This paper takes the software technology major as the research object, and develops modern apprenticeship cooperation through cooperation with Shenzhen Softship Information Technology Co., Ltd. and other enterprise alliances. Both sides have built the corresponding curriculum system on the basis of fully considering the knowledge points and skills required by talents. Through teaching practice, it is found that the students trained in the apprenticeship system have significantly improved their moral skills compared with the students trained in the traditional model. It also proves that modern apprenticeship training is a relatively successful training model.;;;https://dl.acm.org/doi/10.1145/3482632.3482996;;;Software AND Engineering
Parallel Software to Offset the Cost of Higher Precision;;;['Jan Verschelde'];;;December 2020;;;ACM SIGAda Ada Letters;;;Hardware double precision is often insufficient to solve large scientific problems accurately. Computing in higher precision defined by software causes significant computational overhead. The application of parallel algorithms compensates for this overhead. Newton's method to develop power series expansions of algebraic space curves is the use case for this application.;;;https://dl.acm.org/doi/10.1145/3463478.3463483;;;Software AND Engineering
Physicians' Attitudes towards Electronic Prescribing Software: Perceived Benefits and Barriers;;;['Wala M. Eltajoury', 'Abdelsalam M. Maatuk', 'Isam Denna', 'Ebitisam K. Elberkawi'];;;April 2021;;;DATA'21: International Conference on Data Science, E-learning and Information Systems 2021;;;The use of health information technology has become highly effective in healthcare quality as it enhances personal and public care, broadens diagnostic accuracy, reduces medical costs and errors, and improves the effectiveness of both organizational and clinical processes. This study aims to assess physicians' perceptions of perceived benefits and barriers of electronic prescribing (e-Prescribing) software and their implementation. A self-prepared questionnaire was developed, distributed, and filled by physicians (n = 100) from different departments at Benghazi Medical Center, Libya. The Statistical Package for Social Sciences (SPSS) program was used to analyze the results. The results showed that more than 90% of physicians preferred the e-Prescribing software, with most of them believing that they were able to provide better services to patients by saving time and effort (87%), and checking drug interaction (82%), as well as reducing medical errors (89%). On the other hand, the results indicated that the main barriers are the lack of adequate infrastructure, awareness sessions, and human and material resources. Physicians prefer to use the e-Prescribing software, as it supports decision-makers to design more effective strategies and implementation plans. The study recommended the necessity of holding awareness sessions and training programs for using e-Prescribing software.;;;https://dl.acm.org/doi/10.1145/3460620.3460629;;;Software AND Engineering
Development and Application of English Translation Software Based on Computer Corpus;;;['Jing Qiu'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;On the practical level, bilingual dictionary writing, translation teaching, interpreter training and translation assistance can be carried out through parallel corpora. In English teaching, we should make effective use of corpora, take students as the teaching subject, and teachers should be problem-oriented, and spread students' thinking, so that students can discuss corpora by observing corpora, forming a cooperative relationship with others, knowing the background of problems, and then solving corpus problems. With the continuous development of modern computer software technology, the development and use of English translation software has attracted people's attention. In order to effectively improve the accuracy of modern electronic dictionary translation, this paper analyzes the modern English teaching strategies and the design ideas of English translation software based on computer corpus.;;;https://dl.acm.org/doi/10.1145/3482632.3482714;;;Software AND Engineering
Hardware architecture and software stack for PIM based on commercial DRAM technology;;;['Sukhan Lee', 'Shin-haeng Kang', 'Jaehoon Lee', 'Hyeonsu Kim', 'Eojin Lee', 'Seungwoo Seo', 'Hosang Yoon', 'Seungwon Lee', 'Kyounghwan Lim', 'Hyunsung Shin', 'Jinhyun Kim', 'Seongil O', 'Anand Iyer', 'David Wang', 'Kyomin Sohn', 'Nam Sung Kim'];;;June 2021;;;ISCA '21: Proceedings of the 48th Annual International Symposium on Computer Architecture;;;Emerging applications such as deep neural network demand high off-chip memory bandwidth. However, under stringent physical constraints of chip packages and system boards, it becomes very expensive to further increase the bandwidth of off-chip memory. Besides, transferring data across the memory hierarchy constitutes a large fraction of total energy consumption of systems, and the fraction has steadily increased with the stagnant technology scaling and poor data reuse characteristics of such emerging applications. To cost-effectively increase the bandwidth and energy efficiency, researchers began to reconsider the past processing-in-memory (PIM) architectures and advance them further, especially exploiting recent integration technologies such as 2.5D/3D stacking. Albeit the recent advances, no major memory manufacturer has developed even a proof-of-concept silicon yet, not to mention a product. This is because the past PIM architectures often require changes in host processors and/or application code which memory manufacturers cannot easily govern. In this paper, elegantly tackling the aforementioned challenges, we propose an innovative yet practical PIM architecture. To demonstrate its practicality and effectiveness at the system level, we implement it with a 20nm DRAM technology, integrate it with an unmodified commercial processor, develop the necessary software stack, and run existing applications without changing their source code. Our evaluation at the system level shows that our PIM improves the performance of memory-bound neural network kernels and applications by 11.2X and 3.5X, respectively. Atop the performance improvement, PIM also reduces the energy per bit transfer by 3.5X, and the overall energy efficiency of the system running the applications by 3.2X.;;;https://dl.acm.org/doi/10.1109/ISCA52012.2021.00013;;;Software AND Engineering
Innovative Software System for Complex Application of Platelet Rich Plasma in Problematic Skin Wounds;;;['Aneliya Manukova', 'Tsvetan Sokolov', 'Matey Marinov'];;;June 2021;;;CompSysTech '21: Proceedings of the 22nd International Conference on Computer Systems and Technologies;;;None;;;https://dl.acm.org/doi/10.1145/3472410.3472418;;;Software AND Engineering
Compliance by design: software analytics and AIOps;;;['Kostas Kontogiannis', 'Marios Grigoriou', 'Chris Brealey', 'Alberto Giammaria'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Large software systems encompass complex interactions among their components and are subjected to frequent maintenance activities applied in order to fix bugs, add new functionality, port to new platforms, or interoperate with other systems. An important aspect to consider, is how such maintenance activities can be achieved in a way that first minimizes the risk of failures, and second how these maintenance activities can be integrated in a continuous deployment (CD) / continuous integration (CI) DevOps process. One major aspect on achieving this objective is to identify and remediate early on, possible vulnerabilities which are manifested as violations of known published controls and policies. The workshop brought together researchers and practitioners to discuss technological advances in the areas of requirements modeling, systems modeling, logging, event processing, and system verification.;;;https://dl.acm.org/doi/10.5555/3507788.3507847;;;Software AND Engineering
Creating Smart Home Environment Based on Open Source Home Automation Software;;;['Victor Danev', 'Leoneed Kirilov', 'Roumen Nikolov'];;;June 2021;;;CompSysTech '21: Proceedings of the 22nd International Conference on Computer Systems and Technologies;;;The rapid development of IoT has enabled the mass use of smart devices. This in turn allowed the creation of the concept of smart homes and its implementation in people's lives. In this paper a complex smart home environment design is presented. It allows efficient control of many functionalities such as heating and cooling, security, light, audio and video control, comfort control etc. The system is realized via OpenHAB software on hardware platform Raspberry Pi.;;;https://dl.acm.org/doi/10.1145/3472410.3472444;;;Software AND Engineering
Model Transformation Development Using Automated Requirements Analysis, Metamodel Matching, and Transformation by Example;;;['K. Lano', 'S. Kolahdouz-Rahimi', 'S. Fang'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;In this article, we address how the production of model transformations (MT) can be accelerated by automation of transformation synthesis from requirements, examples, and metamodels. We introduce a synthesis process based on metamodel matching, correspondence patterns between metamodels, and completeness and consistency analysis of matches. We describe how the limitations of metamodel matching can be addressed by combining matching with automated requirements analysis and model transformation by example (MTBE) techniques.We show that in practical examples a large percentage of required transformation functionality can usually be constructed automatically, thus potentially reducing development effort. We also evaluate the efficiency of synthesised transformations.Our novel contributions are:
The concept of correspondence patterns between metamodels of a transformation.Requirements analysis of transformations using natural language processing (NLP) and machine learning (ML).Symbolic MTBE using “predictive specification” to infer transformations from examples.Transformation generation in multiple MT languages and in Java, from an abstract intermediate language.;;;https://dl.acm.org/doi/10.1145/3471907;;;Software AND Engineering
Application Analysis of Computer Software Security Vulnerability Detection Based on Web Crawler;;;['Biao Wan', 'Chunmei Xu'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;With the rapid development of the Internet, the World Wide Web has become a carrier of a large amount of information. In order to effectively extract and use this information, web crawlers that crawl various web resources have emerged. The interconnectedness, openness, and interactivity of information in the World Wide Web bring great convenience for information sharing to the society and they also bring many security risks. To protect resource information, computer software security vulnerabilities have become the focus of attention. This article is based on the method of computer software security detection under a web crawler simply analyzes the basic concepts of computer software security detection and analyzes the precautions in the process of security detection. Finally, combined with the computer software security vulnerability problems in the web crawler environment, its security detection technology Application for further analysis.;;;https://dl.acm.org/doi/10.1145/3495018.3495526;;;Software AND Engineering
If It's Not Secure, It Should Not Compile: Preventing DOM-Based XSS in Large-Scale Web Development with API Hardening;;;['Pei Wang', 'Julian Bangert', 'Christoph Kern'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;With tons of efforts spent on its mitigation, Cross-site scripting (XSS) remains one of the most prevalent security threats on the internet. Decades of exploitation and remediation demonstrated that code inspection and testing alone does not eliminate XSS vulnerabilities in complex web applications with a high degree of confidence. This paper introduces Google's secure-by-design engineering paradigm that effectively prevents DOM-based XSS vulnerabilities in large-scale web development. Our approach, named API hardening, enforces a series of company-wide secure coding practices. We provide a set of secure APIs to replace native DOM APIs that are prone to XSS vulnerabilities. Through a combination of type contracts and appropriate validation and escaping, the secure APIs ensure that applications based thereon are free of XSS vulnerabilities. We deploy a simple yet capable compile-time checker to guarantee that developers exclusively use our hardened APIs to interact with the DOM. We make various of efforts to scale this approach to tens of thousands of engineers without significant productivity impact. By offering rigorous tooling and consultant support, we help developers adopt the secure coding practices as seamlessly as possible. We present empirical results showing how API hardening has helped reduce the occurrences of XSS vulnerabilities in Google's enormous code base over the course of two-year deployment.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00123;;;Software AND Engineering
PyXYZ: An Educational 3D Wireframe Engine in Python;;;['Diogo de Andrade', 'Nuno Fachada'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;In this paper we introduce PyXYZ, a 3D wireframe software rendering framework for educational purposes. The main goal of this framework is to provide a simple-to-understand tool that students can use to build a more sophisticated engine, while learning mathematics and acquiring a deeper knowledge of the complexity of a modern 3D engine. PyXYZ can be used as a teaching aid in course work and/or as a template for multi-goal project assignments, allowing students with diverse capabilities and interests to have different levels of commitment. The engine has been used with positive results in a mathematics course unit of a computer games BA and can be easily adapted to various teaching scenarios.;;;https://dl.acm.org/doi/10.1145/3430665.3456345;;;Software AND Engineering
Software-driven Security Attacks: From Vulnerability Sources to Durable Hardware Defenses;;;['Lauren Biernacki', 'Mark Gallagher', 'Zhixing Xu', 'Misiker Tadesse Aga', 'Austin Harris', 'Shijia Wei', 'Mohit Tiwari', 'Baris Kasikci', 'Sharad Malik', 'Todd Austin'];;;None;;;ACM Journal on Emerging Technologies in Computing Systems;;;There is an increasing body of work in the area of hardware defenses for software-driven security attacks. A significant challenge in developing these defenses is that the space of security vulnerabilities and exploits is large and not fully understood. This results in specific point defenses that aim to patch particular vulnerabilities. While these defenses are valuable, they are often blindsided by fresh attacks that exploit new vulnerabilities. This article aims to address this issue by suggesting ways to make future defenses more durable based on an organization of security vulnerabilities as they arise throughout the program life cycle. We classify these vulnerability sources through programming, compilation, and hardware realization, and we show how each source introduces unintended states and transitions into the implementation. Further, we show how security exploits gain control by moving the implementation to an unintended state using knowledge of these sources and how defenses work to prevent these transitions. This framework of analyzing vulnerability sources, exploits, and defenses provides insights into developing durable defenses that could defend against broader categories of exploits. We present illustrative case studies of four important attack genealogies—showing how they fit into the presented framework and how the sophistication of the exploits and defenses have evolved over time, providing us insights for the future.;;;https://dl.acm.org/doi/10.1145/3456299;;;Software AND Engineering
Software-like Compilation for Data Center FPGA Accelerators;;;['James Thomas', 'Chris Lavin', 'Alireza Kaviani'];;;June 2021;;;HEART '21: Proceedings of the 11th International Symposium on Highly Efficient Accelerators and Reconfigurable Technologies;;;Compilation times for large Xilinx devices, such as the Amazon F1 instance, are on the order of several hours. However, today's data center designs often have many identical processing units (PUs), meaning that conventional design flows waste time placing and routing the same problem many times. Furthermore, the connectivity infrastructure of a design tends to be finalized before the PUs, resulting in unnecessary recompilation of a large fraction of the design. We present an open source flow where the connectivity infrastructure logic is implemented ahead of time and routed to many interface blocks that border available slots for PUs. As architects iterate on their PU designs, they only need to perform a single set of parallel, independent compile runs to implement and route the PU alongside each distinct interface block. Our RapidWright-based system stitches the implemented PU into the available slots in the connectivity logic, requiring no additional routing to finalize the design. Our system is able to generate working designs for Amazon F1, and reduces compilation time over the standard monolithic compilation flow by an order of magnitude for designs with up to 180 PUs. Our experiments also show that there is future potential for an additional 4X runtime improvement when relying on emerging open source place and route tools.;;;https://dl.acm.org/doi/10.1145/3468044.3468047;;;Software AND Engineering
Build a malware detection software for IOT network Using Machine learning;;;['Somaya Haiba', 'TOMADER MAZRI'];;;April 2021;;;NISS '21: Proceedings of the 4th International Conference on Networking, Information Systems &amp; Security;;;Any system based on IOT devices must provide a reliable and secure network to transmit and manipulate the data from the smallest technologies to the final server. They are the devices of nowadays, and our future for sure, it will convert all domains of our live starting from the smart home, industry, to e-healthcare systems. To achieve the quality of performances we should have an assurance of security and trustworthiness beginning by the small device used to capture information to the final terminal of the network system, using all the exist possibilities that we can implement to ensure a secure employment. Until now, machine learning become the most powerful application, which provides for any systems the capacity of auto-learning, and improving itself taking a help from the old experiences and without any human intervention or being explicit programmed. Furthermore, the usage of IOT networks, as we know is growing and evaluate enormously so the menaces keep up to date exploiting the weakness of these tools. For that, we propose to make a look about, What machine learning is coming with, to perform more security and analyses the threats, and how can it be used to detect any endanger before it can gain control. Knowing that the reproducible use of resource-constrained IOT devices, the number of IOT Malwares has exploded variously with many ways of breakthrough and then the requirement, to have an efficient malware detection adequate with this grown-up is on immense increasing importance. In this paper, we discuss the usability of machine learning applications in malwares detection software for IOT networks to elicitation the standards, which can us, use to build a powerful model to improve the network security of this small technologies answering to pervious questions.;;;https://dl.acm.org/doi/10.1145/3454127.3458773;;;Software AND Engineering
Performance Modelling and Evaluation of In-Band Control Mode in Software-Defined Satellite Networks Based on Queuing Theory;;;['Jianming Guo', 'Lei Yang', 'Xianfeng Liu', 'Quan Chen', 'Chengguang Fan', 'Xuan Li'];;;May 2021;;;CNIOT '21: Proceedings of the 2021 2nd International Conference on Computing, Networks and Internet of Things;;;None;;;https://dl.acm.org/doi/10.1145/3468691.3468697;;;Software AND Engineering
Towards Automating Code Review Activities;;;['Rosalia Tufano', 'Luca Pascarella', 'Michele Tufano', 'Denys Poshyvanyk', 'Gabriele Bavota'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Code reviews are popular in both industrial and open source projects. The benefits of code reviews are widely recognized and include better code quality and lower likelihood of introducing bugs. However, since code review is a manual activity it comes at the cost of spending developers' time on reviewing their teammates' code. Our goal is to make the first step towards partially automating the code review process, thus, possibly reducing the manual costs associated with it. We focus on both the contributor and the reviewer sides of the process, by training two different Deep Learning architectures. The first one learns code changes performed by developers during real code review activities, thus providing the contributor with a revised version of her code implementing code transformations usually recommended during code review before the code is even submitted for review. The second one automatically provides the reviewer commenting on a submitted code with the revised code implementing her comments expressed in natural language. The empirical evaluation of the two models shows that, on the contributor side, the trained model succeeds in replicating the code transformations applied during code reviews in up to 16% of cases. On the reviewer side, the model can correctly implement a comment provided in natural language in up to 31% of cases. While these results are encouraging, more research is needed to make these models usable by developers.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00027;;;Software AND Engineering
Intelligent UAV-aided controller placement scheme for software-defined vehicular networks;;;['Na Lin', 'Qi Zhao', 'Liang Zhao'];;;May 2021;;;CF '21: Proceedings of the 18th ACM International Conference on Computing Frontiers;;;Recently, researchers have used long short-term memory (LSTM) networks and the bi-directional long short-term memory (Bi-LSTM) networks to process sequence data sets such as vehicle positions in software-defined vehicular networks (SDVN). In this paper, we present a three-component intelligent UAV-aided controller placement scheme (CPP) for SDVN. First, we use Bi-LSTM to model the real-time position of vehicles (traffic flow). Second, we implement a dynamic scheme to place controllers and UAVs (DCUPE) in the network based on the predicted flow. Third, in order to collect real-time traffic information and manage the network, we compute trajectories for the UAVs from real-time Bi-LSTM predictions of vehicle positions and an adaptive artificial bee colony algorithm for the traveling salesman problem (IDABC-TSP). We evaluate our proposed design as a function of energy cost, communication delay, and packet delivery ratio. Our experimental results show the effectiveness of our scheme on real geographical topologies.;;;https://dl.acm.org/doi/10.1145/3457388.3458809;;;Software AND Engineering
Design and Implementation of English Online Translation Software Based on Intelligent Proofreading System;;;['Jing Qiu'];;;May 2021;;;ICAIIS 2021: 2021 2nd International Conference on Artificial Intelligence and Information Systems;;;With the continuous development of modern information technology, the ways and means of learning English have become more diversified. Especially, the emergence of English electronic dictionary makes English learning more and more simple. This paper puts forward the design idea of English online translation software based on intelligent proofreading system. Firstly, the semantic ontology model is created by creating semantic ontology model and phrase translation combination translation algorithm. In addition, the overall system is designed. The hardware and software of the system are designed through the overall architecture of the system, and the hardware design is mainly the search module, so as to improve the search accuracy. In the process of software module, it mainly includes information transmission model, system network topology design and system function design, and can support translation and proofreading of multiple languages. Finally, the designed system is tested. The test results show that this method is accurate and intelligent in English automatic translation.;;;https://dl.acm.org/doi/10.1145/3469213.3471370;;;Software AND Engineering
On the role of system software in energy management of neuromorphic computing;;;['Twisha Titirsha', 'Shihao Song', 'Adarsha Balaji', 'Anup Das'];;;May 2021;;;CF '21: Proceedings of the 18th ACM International Conference on Computing Frontiers;;;Neuromorphic computing systems such as DYNAPs and Loihi have recently been introduced to the computing community to improve performance and energy efficiency of machine learning programs, especially those that are implemented using Spiking Neural Network (SNN). The role of a system software for neuromorphic systems is to cluster a large machine learning model (e.g., with many neurons and synapses) and map these clusters to the computing resources of the hardware. In this work, we formulate the energy consumption of a neuromorphic hardware, considering the power consumed by neurons and synapses, and the energy consumed in communicating spikes on the interconnect. Based on such formulation, we first evaluate the role of a system software in managing the energy consumption of neuromorphic systems. Next, we formulate a simple heuristic-based mapping approach to place the neurons and synapses onto the computing resources to reduce energy consumption. We evaluate our approach with 10 machine learning applications and demonstrate that the proposed mapping approach leads to a significant reduction of energy consumption of neuromorphic computing systems.;;;https://dl.acm.org/doi/10.1145/3457388.3458664;;;Software AND Engineering
Discovering enterprise architecture developing a course with enterprise application software tools;;;['Maria Weber', 'Kyle Chapman', 'John Buerck'];;;None;;;Journal of Computing Sciences in Colleges;;;Information Technology (IT) and Digital Transformation (Dx) are shifting how companies function and embrace emerging technologies. Companies are reimagining how work can be done by adopting new technologies to existing or new infrastructure. Organizations need skilled IT professionals who can drive this transformation, leading to the establishment of a robust enterprise. Industry trends indicate a need to shift academic curricula in Information System (IS) programs. Enterprise Architecture (EA) is a course in a graduate IS program at Saint Louis University. The EA curriculum focuses on the alignment between IT and business. The course covers designing, planning, and implementing organizational changes to corporate architecture through standardization of principles, models, and procedures. The use of EA open-source tools in this course is innovative and ideal for building students' marketable skills and improving their university experience. This paper provides an overview of designing and delivering a gateway course in Enterprise Architecture and Infrastructure Systems using enterprise-class and open-source software tools as part of the Master of Information Systems.;;;https://dl.acm.org/doi/10.5555/3469567.3469569;;;Software AND Engineering
Towards Trace-Based Synchronization of Variability Annotations in Evolving Model-Driven Product Lines;;;['Sandra Greiner', 'Michael Nieke', 'Christoph Seidl'];;;February 2022;;;VaMoS '22: Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;;;Annotative model-driven product lines allow to derive individual variants from a multi-variant model by exploiting annotations. Those declare the presence of each model element in a specific set of variants via a logical expression over features and may change during evolution. This provokes the risk of introducing conflicts causing logically cohesive elements of different models to appear in diverging sets of variants, which threatens the consistency of the product line. Existing work on propagating annotations across models employs the comparatively simple strategy of either overwriting or manually protecting any changed annotation in the target model but does not consider a backward propagation nor any form of synchronization. Therefore, we contribute a sophisticated method for synchronizing annotations which detects corresponding elements based on model transformation traces and resolves conflicting annotations by preserving syntactically different but semantically equal annotations according to the feature model. We demonstrate challenges and our solution method in a scenario of synchronizing two corresponding evolving multi-variant models.;;;https://dl.acm.org/doi/10.1145/3510466.3510470;;;Software AND Engineering
Preliminary Design and Realization of the Computer Aided Teaching Software of Volleyball Tactics;;;['Zejun Chen'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;At present, volleyball skill training is a hot spot in China. Many volleyball loving athletes pay more attention to the study of volleyball tactics, and colleges and universities also pay more attention to the mastery of volleyball skills. This paper studies the preliminary design and implementation of volleyball tactics computer guidance teaching software. Based on the main points of volleyball tactics, this paper makes computer simulation of students' receiving point and padding posture, and carries out teaching of volleyball tactics from the perspective of artificial intelligence data analysis and prediction, so as to realize the auxiliary teaching and automatic guidance of computer software. In this paper, the students' individual learning situation is recorded, and combined with the skill requirements and key points of international volleyball competition, the students are systematically guided. This software is written by Python language, using the visual library, and supporting high scalability. It can supplement the volleyball teaching points that are not involved at present, and also can arouse students' interest in volleyball teaching. Research shows that in this paper, in the computer-aided teaching software of volleyball tactics, taking a volleyball team in our city as an example, compared with the demonstration teaching, the teaching effect of this method is improved by more than 50%, and the teaching practice can be shortened by 24%, which can be said to be helpful for volleyball auxiliary teaching to a great extent. In teaching, the system can also change the module according to the students' mastery of tactics, which is conducive to improving the skills of students of different levels.;;;https://dl.acm.org/doi/10.1145/3482632.3483116;;;Software AND Engineering
Heterogeneous Effects of Software Patches in a Multiplayer Online Battle Arena Game;;;['Yuzi He', 'Christopher Tran', 'Julie Jiang', 'Keith Burghardt', 'Emilio Ferrara', 'Elena Zheleva', 'Kristina Lerman'];;;August 2021;;;FDG '21: Proceedings of the 16th International Conference on the Foundations of Digital Games;;;The popularity of online gaming has grown dramatically, driven in part by streaming and the billion dollar e-sports industry. Online games regularly update their software to fix bugs, add functionality that improve the game’s look and feel, and change the game mechanics to keep the games fun and challenging. An open question, however, is the impact of these changes on player performance and game balance, as well as how players adapt to these sudden changes. To address these questions, we use causal inference to measure the impact of software patches to League of Legends, a popular team-based multiplayer online game. We show that game patches have substantially different impacts on players, depending on their skill level and whether they take breaks between games. We find that the gap between good and bad players increases after a patch, despite efforts to make gameplay more equal. Moreover, longer between-game breaks tend to improve performance after patches. Overall, our results highlight the utility of causal inference, and specifically heterogeneous treatment effect estimation, as a tool to quantify the complex mechanisms of game balance and its interplay with players’ performance.;;;https://dl.acm.org/doi/10.1145/3472538.3472550;;;Software AND Engineering
RealSWATT: Remote Software-based Attestation for Embedded Devices under Realtime Constraints;;;['Sebastian Surminski', 'Christian Niesler', 'Ferdinand Brasser', 'Lucas Davi', 'Ahmad-Reza Sadeghi'];;;November 2021;;;CCS '21: Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security;;;Smart factories, critical infrastructures, and medical devices largely rely on embedded systems that need to satisfy realtime constraints to complete crucial tasks. Recent studies and reports have revealed that many of these devices suffer from crucial vulnerabilities that can be exploited with fatal consequences. Despite the security and safety-critical role of these devices, they often do not feature state-of-the-art security mechanisms. Moreover, since realtime systems have strict timing requirements, integrating new security mechanisms is not a viable option as they often influence the device's runtime behavior. One solution is to offload security enhancements to a remote instance, the so-called remote attestation. We present RealSWATT, the first software-based remote attestation system for realtime embedded devices. Remote attestation is a powerful security service that allows a party to verify the correct functionality of an untrusted remote device. In contrast to previous remote attestation approaches for realtime systems, RealSWATT does neither require custom hardware extensions nor trusted computing components. It is designed to work within real-world IoT networks, connected through Wi-Fi. RealSWATT leverages a dedicated processor core for remote attestation and provides the required timing guarantees without hardware extensions. We implement RealSWATT on the popular ESP32 microcontroller, and we evaluate it on a real-world medical device with realtime constraints. To demonstrate its applicability, we furthermore integrate RealSWATT into a framework for off-the-shelf IoT devices and apply it to a smart plug, a smoke detector, and a smart light bulb.;;;https://dl.acm.org/doi/10.1145/3460120.3484788;;;Software AND Engineering
CacheInspector: Reverse Engineering Cache Resources in Public Clouds;;;['Weijia Song', 'Christina Delimitrou', 'Zhiming Shen', 'Robbert Van Renesse', 'Hakim Weatherspoon', 'Lotfi Benmohamed', 'Frederic De Vaulx', 'Charif Mahmoudi'];;;None;;;ACM Transactions on Architecture and Code Optimization;;;Infrastructure-as-a-Service cloud providers sell virtual machines that are only specified in terms of number of CPU cores, amount of memory, and I/O throughput. Performance-critical aspects such as cache sizes and memory latency are missing or reported in ways that make them hard to compare across cloud providers. It is difficult for users to adapt their application’s behavior to the available resources. In this work, we aim to increase the visibility that cloud users have into shared resources on public clouds. Specifically, we present CacheInspector, a lightweight runtime that determines the performance and allocated capacity of shared caches on multi-tenant public clouds. We validate CacheInspector’s accuracy in a controlled environment, and use it to study the characteristics and variability of cache resources in the cloud, across time, instances, availability regions, and cloud providers. We show that CacheInspector’s output allows cloud users to tailor their application’s behavior, including their output quality, to avoid suboptimal performance when resources are scarce.;;;https://dl.acm.org/doi/10.1145/3457373;;;Software AND Engineering
QDiff: differential testing of quantum software stacks;;;['Jiyuan Wang', 'Qian Zhang', 'Guoqing Harry Xu', 'Miryung Kim'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Over the past few years, several quantum software stacks (QSS) have been developed in response to rapid hardware advances in quantum computing. A QSS includes a quantum programming language, an optimizing compiler that translates a quantum algorithm written in a high-level language into quantum gate instructions, a quantum simulator that emulates these instructions on a classical device, and a software controller that sends analog signals to a very expensive quantum hardware based on quantum circuits. In comparison to traditional compilers and architecture simulators, QSSes are difficult to tests due to the probabilistic nature of results, the lack of clear hardware specifications, and quantum programming complexity. This work devises a novel differential testing approach for QSSes, named QDIFF with three major innovations: (1) We generate input programs to be tested via semantics-preserving, source to source transformation to explore program variants. (2) We speed up differential testing by filtering out quantum circuits that are not worthwhile to execute on quantum hardware by analyzing static characteristics such as a circuit depth, 2-gate operations, gate error rates, and T1 relaxation time. (3) We design an extensible equivalence checking mechanism via distribution comparison functions such as Kolmogorov-Smirnov test and cross entropy. We evaluate QDiff with three widely-used open source QSSes: Qiskit from IBM, Cirq from Google, and Pyquil from Rigetti. By running QDiff on both real hardware and quantum simulators, we found several critical bugs revealing potential instabilities in these platforms. QDiff's source transformation is effective in producing semantically equivalent yet not-identical circuits (i.e., 34% of trials), and its filtering mechanism can speed up differential testing by 66%.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678792;;;Software AND Engineering
GenSys: a scalable fixed-point engine for maximal controller synthesis over infinite state spaces;;;['Stanly Samuel', "Deepak D'Souza", 'Raghavan Komondoor'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;The synthesis of maximally-permissive controllers in infinite-state systems has many practical applications. Such controllers directly correspond to maximal winning strategies in logically specified infinite-state two-player games. In this paper, we introduce a tool called GenSys which is a fixed-point engine for computing maximal winning strategies for players in infinite-state safety games. A key feature of GenSys is that it leverages the capabilities of existing off-the-shelf solvers to implement its fixed point engine. GenSys outperforms state-of-the-art tools in this space by a significant margin. Our tool has solved some of the challenging problems in this space, is scalable, and also synthesizes compact controllers. These controllers are comparatively small in size and easier to comprehend. GenSys is freely available for use and is available under an open-source license.;;;https://dl.acm.org/doi/10.1145/3468264.3473126;;;Software AND Engineering
GenSys: a scalable fixed-point engine for maximal controller synthesis over infinite state spaces;;;['Stanly Samuel', "Deepak D'Souza", 'Raghavan Komondoor'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;The synthesis of maximally-permissive controllers in infinite-state systems has many practical applications. Such controllers directly correspond to maximal winning strategies in logically specified infinite-state two-player games. In this paper, we introduce a tool called GenSys which is a fixed-point engine for computing maximal winning strategies for players in infinite-state safety games. A key feature of GenSys is that it leverages the capabilities of existing off-the-shelf solvers to implement its fixed point engine. GenSys outperforms state-of-the-art tools in this space by a significant margin. Our tool has solved some of the challenging problems in this space, is scalable, and also synthesizes compact controllers. These controllers are comparatively small in size and easier to comprehend. GenSys is freely available for use and is available under an open-source license.;;;https://dl.acm.org/doi/10.1145/3468264.3473126;;;Software AND Engineering
Software Application in Making Basketball Teaching and Training Tactics Design Drawing under the Background of Internet Technology;;;['Feng Hao'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the rapid development of science and technology today, computer technology and Internet technology have led to a new technological revolution. Under the background of Internet technology, people's lifestyles and information acquisition methods are undergoing tremendous changes, and the entire education industry has also been significantly affected. The Internet technology has given birth to a software for making basketball teaching and training tactics design drawings, which has greatly enriched teaching resources and teaching methods. The purpose of this article is to study the software application of basketball teaching and training tactics design drawing under the background of Internet technology. This article first uses computer technology to develop the human-computer interaction software for basketball training tactics teaching, so that basketball players can initially establish the perceptual understanding of basketball skills and tactics, and improve the teaching effect of teachers explaining basketball training techniques and tactics. Then, it compares and analyzes the difference between traditional basketball teaching and the software application teaching, and draws out the advantages of this basketball teaching training tactical design drawing software. Finally, using teaching experiment method, expert interview method, mathematical statistics method, logical analysis method and other methods, the students of the basketball team of school A are used as the experimental objects, and the traditional design drawing method and the design drawing software production method of this research are used for experimental research. The experimental data shows that before the basketball teaching training of the training tactics design drawing, 6 of the experimental group scored more than 5 fixed-point shots, and after the basketball teaching training, 9 of the experimental group scored more than 5 fixed-point shots. The software has obvious advantages in basketball teaching and training.;;;https://dl.acm.org/doi/10.1145/3482632.3482982;;;Software AND Engineering
A Simulation Software for the Evaluation of Vulnerabilities in Reputation Management Systems;;;['Vincenzo Agate', 'Alessandra De Paola', 'Giuseppe Lo Re', 'Marco Morana'];;;None;;;ACM Transactions on Computer Systems;;;Multi-agent distributed systems are characterized by autonomous entities that interact with each other to provide, and/or request, different kinds of services. In several contexts, especially when a reward is offered according to the quality of service, individual agents (or coordinated groups) may act in a selfish way. To prevent such behaviours, distributed Reputation Management Systems (RMSs) provide every agent with the capability of computing the reputation of the others according to direct past interactions, as well as indirect opinions reported by their neighbourhood. This last point introduces a weakness on gossiped information that makes RMSs vulnerable to malicious agents’ intent on disseminating false reputation values. Given the variety of application scenarios in which RMSs can be adopted, as well as the multitude of behaviours that agents can implement, designers need RMS evaluation tools that allow them to predict the robustness of the system to security attacks, before its actual deployment. To this aim, we present a simulation software for the vulnerability evaluation of RMSs and illustrate three case studies in which this tool was effectively used to model and assess state-of-the-art RMSs.;;;https://dl.acm.org/doi/10.1145/3458510;;;Software AND Engineering
Design of translation accuracy correction algorithm for English translation software based on Rough Set;;;['Gaili Cui'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;With the development of modern information technology, network teaching is becoming more and more popular, which provides a strong technical support for English teaching. Many English translation tools emerge as the times require. With the rapid development of computer software technology, the development and application of English translation software has attracted more and more attention. Machine translation is an important research field of natural language processing, which has a wide application prospect in today's information society and military departments. Traditional machine translation methods use pipeline successive operations to identify parts of speech and parse the original corpus, so as to obtain the syntactic structure of English language, which makes the error iterative transmission between translation tasks and the accuracy of structured examples lower, which leads to the lower accuracy of English language and literature translation. Based on rough set theory, this paper expounds the application of translation accuracy correction algorithm in English translation software.;;;https://dl.acm.org/doi/10.1145/3482632.3482750;;;Software AND Engineering
A Research on College Students' English Learning Methods through Mobile Phone-Based software;;;['Kangning Yu'];;;March 2022;;;ICEDS '22: Proceedings of the 2022 3rd International Conference on Education Development and Studies;;;In contemporary society, information technology has been highly developed. The learning of English vocabulary is no longer limited to the traditional classroom or schooling. The research adopts quantitative research method, using questionnaire survey. Based on the basic survey of college students using mobile devices to learn English vocabulary, it is found that the download of English learning software in college students' mobile devices has been very popular, reaching about 92%. However, there are some problems, such as low utilization rate or lack of obvious learning effect. Therefore, to solve these problems in reality, the author puts forward the following suggestions: for learners, first of all, they should stimulate their learning motivation. and cultivate their interest of English; Secondly, they should formulate reasonable learning goals according to their own actual ability; finally, they should plan time reasonably and make efficient use of learning time. For mobile learning resource developers, they should improve the quality of resources, and understand learners' vocabulary learning needs, which aims to create a good language vocabulary learning environment for learners.;;;https://dl.acm.org/doi/10.1145/3528137.3528148;;;Software AND Engineering
Software Development Processes for ADs, SMCs and OSCs supporting Usability, Security, and Privacy Goals – an Overview;;;['Tim Bender', 'Rolf Huesmann', 'Andreas Heinemann'];;;August 2021;;;ARES '21: Proceedings of the 16th International Conference on Availability, Reliability and Security;;;Software applications should be secure, usable and privacy-friendly. However, recurring headlines about data leaks in applications show that it is not so easy to develop software that meets these three challenges. Studies show that it is better to think about these challenges during a software development process. Many ideas and approaches exist in the research community that define these challenges as goals within a software development process. In addition, major companies have published their own software development processes and methods addressing these goals in part. But major companies have very different work conditions compared to a work setting faced by an App-Developer (AD), a Small and Medium Company (SMC) and the Open Source Community (OSC) respectively. This leads us to the question: Are work settings of ADs, SMCs, or the OSCs considered sufficiently by research in order to make software development processes with special focus on security, usability and privacy goals work? Therefore we performed a literature review in order to investigate the current state of research. Using an appropriate query, publications relevant for our question were identified and categorised by two independent reviewers.  Our work shows that there are some publications proposing software processes supporting usability goals and taking work settings into account. We were not able to identify any contribution that proposes a software development process which addresses privacy, usability and security goals together and differentiates the work setting of ADs or as found in SMCs and in OSCs respectively.;;;https://dl.acm.org/doi/10.1145/3465481.3470022;;;Software AND Engineering
Students’ Psychological Adaptation to Using Exam Online System Software in Testing and Assessment;;;['Huong Thi Nguyen'];;;May 2021;;;ICMET 2021: 2021 3rd International Conference on Modern Educational Technology;;;Switching from high schools to universities leads students to change to adapt to new environments. One of the changes that students need to adapt to is learning and teaching methods. This study focuses on students’ psychological adaptation to a software called exam online system (EOS) in testing and assessment. This is crucial in evaluating the effectiveness of information technology application in teaching and learning in 4.0 era. It also provides students with favorable conditions to access to technology in learning. The purpose of this study was to explore students’ psychological adaptation of EOS, and then offer recommendations to the institution. The study employed a survey questionnaire, interviews and observation with 300 students at an international university in Vietnam. The results showed that students’ psychological adaptation is far from prior expectation. This finding helps the studied institution to come up with effective solutions to improve the implementation process of EOS in testing and assessment.;;;https://dl.acm.org/doi/10.1145/3468978.3468980;;;Software AND Engineering
Why Do Developers Reject Refactorings in Open-Source Projects?;;;['Jevgenija Pantiuchina', 'Bin Lin', 'Fiorella Zampetti', 'Massimiliano Di Penta', 'Michele Lanza', 'Gabriele Bavota'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Refactoring operations are behavior-preserving changes aimed at improving source code quality. While refactoring is largely considered a good practice, refactoring proposals in pull requests are often rejected after the code review. Understanding the reasons behind the rejection of refactoring contributions can shed light on how such contributions can be improved, essentially benefiting software quality.This article reports a study in which we manually coded rejection reasons inferred from 330 refactoring-related pull requests from 207 open-source Java projects. We surveyed 267 developers to assess their perceived prevalence of these identified rejection reasons, further complementing the reasons.Our study resulted in a comprehensive taxonomy consisting of 26 refactoring-related rejection reasons and 21 process-related rejection reasons. The taxonomy, accompanied with representative examples and highlighted implications, provides developers with valuable insights on how to ponder and polish their refactoring contributions, and indicates a number of directions researchers can pursue toward better refactoring recommenders.;;;https://dl.acm.org/doi/10.1145/3487062;;;Software AND Engineering
Software for Measuring Linguistic Literacy Rate of Students (Based on Comments Written in Ukrainian);;;['Ihor O. Drahushchak', 'Oksana S. Taran', 'Svitlana P. Bybyk', 'Olesya V. Saban', 'Natalia M. Sharmanova'];;;December 2021;;;DHW 2021: Digital Humanities Workshop;;;In this article, linguistic literacy rate is measured by the number of errors in students’ comments on the web portal. The data comprising about 10,000 comments covering all regions of Ukraine over a period of 10 years has been analyzed. The stages of creating a software which interacts with the LanguageTool and enables generating the results of error analysis and classifying them by types and regions have been described. A map of linguistic literacy of Ukrainian students has been created. Also, the regions with the highest and lowest linguistic literacy and the main types of errors have been identified. The obtained data will make it possible to revise and adjust university language teaching programs in each region in the future.;;;https://dl.acm.org/doi/10.1145/3526242.3526248;;;Software AND Engineering
Supporting Quality Assurance with Automated Process-Centric Quality Constraints Checking;;;['Christoph Mayr-Dorn', 'Michael Vierhauser', 'Stefan Bichler', 'Felix Keplinger', 'Jane Cleland-Huang', 'Alexander Egyed', 'Thomas Mehofer'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Regulations, standards, and guidelines for safety-critical systems stipulate stringent traceability but do not prescribe the corresponding, detailed software engineering process. Given the industrial practice of using only semi-formal notations to describe engineering processes, processes are rarely "executable" and developers have to spend significant manual effort in ensuring that they follow the steps mandated by quality assurance. The size and complexity of systems and regulations makes manual, timely feedback from Quality Assurance (QA) engineers infeasible. In this paper we propose a novel framework for tracking processes in the background, automatically checking QA constraints depending on process progress, and informing the developer of unfulfilled QA constraints. We evaluate our approach by applying it to two different case studies; one open source community system and a safety-critical system in the air-traffic control domain. Results from the analysis show that trace links are often corrected or completed after the fact and thus timely and automated constraint checking support has significant potential on reducing rework.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00118;;;Software AND Engineering
Mechanical visual identification of batch parts based on Halcon software;;;['Cheng Xiong', 'Jiyuan Zhu'];;;July 2021;;;ICIIP '21: Proceedings of the 6th International Conference on Intelligent Information Processing;;;None;;;https://dl.acm.org/doi/10.1145/3480571.3480588;;;Software AND Engineering
Playing Planning Poker in Crowds: Human Computation of Software Effort Estimates;;;['Mohammed Alhamed', 'Tim Storer'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Reliable cost effective effort estimation remains a considerable challenge for software projects. Recent work has demonstrated that the popular Planning Poker practice can produce reliable estimates when undertaken within a software team of knowledgeable domain experts. However, the process depends on the availability of experts and can be time-consuming to perform, making it impractical for large scale or open source projects that may curate many thousands of outstanding tasks. This paper reports on a full study to investigate the feasibility of using crowd workers supplied with limited information about a task to provide comparably accurate estimates using Planning Poker. We describe the design of a Crowd Planning Poker (CPP) process implemented on Amazon Mechanical Turk and the results of a substantial set of trials, involving more than 5000 crowd workers and 39 diverse software tasks. Our results show that a carefully organised and selected crowd of workers can produce effort estimates that are of similar accuracy to those of a single expert.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00014;;;Software AND Engineering
Seamless Variability Management With the Virtual Platform;;;['Wardah Mahmood', 'Daniel Strüber', 'Thorsten Berger', 'Ralf Lämmel', 'Mukelabai Mukelabai'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Customization is a general trend in software engineering, demanding systems that support variable stakeholder requirements. Two opposing strategies are commonly used to create variants: software clone&own and software configuration with an integrated platform. Organizations often start with the former, which is cheap, agile, and supports quick innovation, but does not scale. The latter scales by establishing an integrated platform that shares software assets between variants, but requires high up-front investments or risky migration processes. So, could we have a method that allows an easy transition or even combine the benefits of both strategies? We propose a method and tool that supports a truly incremental development of variant-rich systems, exploiting a spectrum between both opposing strategies. We design, formalize, and prototype the variability-management framework virtual platform. It bridges clone&own and platform-oriented development. Relying on programming-language-independent conceptual structures representing software assets, it offers operators for engineering and evolving a system, comprising: traditional, asset-oriented operators and novel, feature-oriented operators for incrementally adopting concepts of an integrated platform. The operators record meta-data that is exploited by other operators to support the transition. Among others, they eliminate expensive feature-location effort or the need to trace clones. Our evaluation simulates the evolution of a real-world, clone-based system, measuring its costs and benefits.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00147;;;Software AND Engineering
High-Speed Millimeter-Wave Mobile Experimentation on Software-Defined Radios;;;['Jesus O. Lacruz', 'Dolores Garcia', 'Pablo Jimenez', 'Joan Palacios', 'Joerg Widmer'];;;December 2020;;;GetMobile: Mobile Computing and Communications;;;Millimeter-wave (mm-Wave) communications have become an integral part of WLAN standards and 5G mobile networks and, as application data rate requirements increase, more and more traffic will move to these very high frequency bands. Although there is an ample choice of powerful experimental platforms for sub-6 GHz research, building mm-Wave systems is much more difficult due to the very high hardware requirements. To address the lack of suitable experimentation platforms, we propose mm-FLEX, a flexible and modular open platform with real-time signal processing capabilities that supports a bandwidth of 2 GHz and is compatible with current mm-Wave standards. The platform is built around a fast FPGA processor and a 60 GHz phased antenna array at front-end that can be reconfigured at nanosecond timescales. Together with its ease of use, this turns the platform into a unique tool for research on beam training in highly mobile scenarios and full-bandwidth mm-Wave signal processing.;;;https://dl.acm.org/doi/10.1145/3457356.3457368;;;Software AND Engineering
Research on Spatial Pattern Evolution of Cultural Industry Based on Computer Software Analysis;;;['Shu Dong'];;;May 2021;;;CIPAE 2021: 2021 2nd International Conference on Computers, Information Processing and Advanced Education;;;Cultural and creative industry is a new industrial form, which has broad development prospects. However, many emerging cultural industrial parks are enclosed in disguise, and some are not clearly positioned but only used as pure tourism development resources, lacking the dynamic adaptation and innovation ability of the internal and external environment of the cluster. From the development trend of world cultural industry, industrial cluster is an important organizational form of cultural industry development and an important symbol of cultural industry layout system, and cultural industry cluster has a strong geographical spatial clustering feature. Cultural industry is not only an important driving force to promote economic development, but also reflects the "soft power" of a country and the international competitiveness of a country. In view of the trend of the cluster development of cultural industry, this paper analyzes the relationship between the urbanization process and the development of urban cultural industry in China, puts forward the planning ideas of cultural industry spatial layout based on computer software analysis, and emphasizes the important influence of urban development context on the continuation of urban culture and its industrial development.;;;https://dl.acm.org/doi/10.1145/3456887.3459690;;;Software AND Engineering
Assessing the students' understanding and their mistakes in code review checklists: an experience report of 1,791 code review checklist questions from 394 students;;;['Chun Yong Chong', 'Patanamon Thongtanunam', 'Chakkrit Tantithamthavorn'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Code review is a widely-used practice in software development companies to identify defects. Hence, code review has been included in many software engineering curricula at universities worldwide. However, teaching code review is still a challenging task because the code review effectiveness depends on the code reading and analytical skills of a reviewer. While several studies have investigated the code reading techniques that students should use to find defects during code review, little has focused on a learning activity that involves analytical skills. Indeed, developing a code review checklist should stimulate students to develop their analytical skills to anticipate potential issues (i.e., software defects). Yet, it is unclear whether students can anticipate potential issues given their limited experience in software development (programming, testing, etc.). We perform a qualitative analysis to investigate whether students are capable of creating code review checklists, and if the checklists can be used to guide reviewers to find defects. In addition, we identify common mistakes that students make when developing a code review checklist. Our results show that while there are some misconceptions among students about the purpose of code review, students are able to anticipate potential defects and create a relatively good code review checklist. Hence, our results lead us to conclude that developing a code review checklist can be a part of the learning activities for code review in order to scaffold students' skills.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00011;;;Software AND Engineering
CIBench: a dataset and collection of techniques for build and test selection and prioritization in continuous integration;;;['Xianhao Jin', 'Francisco Servant'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Continuous integration (CI) is a widely used practice in modern software engineering. Unfortunately, it is also an expensive practice --- Google and Mozilla estimate their CI systems in millions of dollars. There are a number of techniques and tools designed to or having the potential to save the cost of CI or expand its benefit - reducing time to feedback. However, their benefits in some dimensions may also result in drawbacks in others. They may also be beneficial in other scenarios where they are not designed to help. Therefore, we built CIBench, a dataset and collection of techniques for build and test selection and prioritization in Continuous Integration. CIBench is based on a popular existing dataset for CI --- TravisTorrent [2] and extends it in multiple ways including mining additional Travis logs, Github commits, and building dependency graphs for studied projects. This dataset allows us to replicate and evaluate existing techniques to improve CI under the same settings, to better understand the impact of applying different strategies in a more comprehensive way.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00070;;;Software AND Engineering
Robot runner: a tool for automatically executing experiments on robotics software;;;['Stan Swanborn', 'Ivano Malavolta'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Software is becoming the core aspect in robotics development and it is growing in terms of complexity and size. However, roboticists and researchers are struggling in ensuring and even measuring the quality of their software with respect to run-time properties such as energy efficiency and performance. This paper presents Robot Runner, a tool for streamlining the execution of measurement-based experiments involving robotics software. The tool is able to automatically setup, start, resume, and fully replicate user-defined experiments. Thanks to its pluginbased architecture, the tool is fully independent of the number, type, and complexity of the used robots (both real and simulated). GitHub repository - https://github.com/S2-group/robot-runner Youtube video - https://youtu.be/le-SAXI2k1E;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00029;;;Software AND Engineering
SoftRefresh: Targeted refresh for Energy-efficient DRAM systems via Software and Operating Systems support;;;['Duy-Thanh Nguyen', 'Nhut-Minh Ho', 'Ik-Joon Chang'];;;September 2021;;;MEMSYS '21: Proceedings of the International Symposium on Memory Systems;;;Due to its capacitive nature, DRAM cells must be refreshed regularly to retain their information. However, due to the scale of DRAM deployment in modern computer systems, the energy overhead of DRAM refresh operations is becoming significant. The crux in managing DRAM refresh is knowing if the data in particular cells are valid or not. Previous works have suggested many hardware schemes that effectively try to guess this. In this paper, we propose modifications to allow software involvement in regulating refresh operations. This opens the door for targeted, and hence minimal, refresh operations. Only valid pages having potential bit errors will be refreshed. Compared to conventionally refreshing the whole DRAM, our SoftRefresh saves up to 43% energy on average. Our proposal can work on all types of modern DRAM with only minor modifications to the existing hardware and software systems.;;;https://dl.acm.org/doi/10.1145/3488423.3519323;;;Software AND Engineering
Constructive master's thesis work in industry: guidelines for applying design science research;;;['Eric Knauss'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;[Context:] Software engineering researchers and practitioners rely on empirical evidence from the field. Thus, education of software engineers must include strong and applied education in empirical research methods. For most students, the master's thesis is the last, but also most applied form of this education in their studies. [Problem:] Especially thesis work in collaboration with industry requires that concerns of stakeholders from academia and practice are carefully balanced. It is possible, yet difficult to do high-impact empirical work within the timeframe of a typical thesis. In particular, if this research aims to provide practical value to industry, academic quality can suffer. Even though constructive research methods such as Design Science Research (DSR) exist, thesis projects repeatably struggle to apply them. [Principle solution idea:] DSR enables balancing such concerns by providing room both for knowledge questions and design work. Yet, only limited experience exists in our field on how to make this research method work within the context of a master's thesis. To enable running design science master's theses in collaboration with industry, this paper complements existing method descriptions and guidelines. It offers experience and pragmatic advice to students, examiners, and supervisors in academia and industry. [Method:] This paper itself is based on DSR. Based on 12 design science theses over the last seven years, common pitfalls and good practices are collected from analysing the theses, the student-supervisor interaction, the supervisor-industry interaction, the examiner feedback, and, where available, reviewer comments on publications that are based on such theses. [Results:] This paper provides concrete advise for framing research questions, structuring a report, as well as for planning and conducting design science research with practitioners.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00021;;;Software AND Engineering
Research on the Application of Artificial Intelligence in Piano Exercise Using Internet and Computer Software and Hardware Technologies;;;['Li Zhao', 'Wenfei Zeng'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;With the gradual deepening of the "Internet +" trend and the rise of artificial intelligence to the national strategy, it has become an inevitable trend to use new Internet and computer software and hardware technologies to serve music communication and music education. In the entire system of intelligent piano teaching, it mainly includes hardware construction methods, software design methods, music presentation forms, teaching methods, etc. Based on the existing technology and theories, different methods have different characteristics in the entire teaching. This article elaborates on the demand analysis, design, implementation and testing of the piano assistant practice system. This system can provide more convenience and better teaching effect for traditional piano teaching, provide a piano learning auxiliary tool for students, and provide a tool for teachers to supervise and manage students' piano learning.;;;https://dl.acm.org/doi/10.1145/3495018.3501114;;;Software AND Engineering
GitHub-OSS fixit;;;['Shin Hwei Tan', 'Chunfeng Hu', 'Ziqiang Li', 'Xiaowen Zhang', 'Ying Zhou'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Many studies have shown the benefits of introducing open-source projects into teaching Software Engineering (SE) courses. However, there are several limitations of existing studies that limit the wide adaptation of open-source projects in a classroom setting, including (1) the selected project is limited to one particular project, (2) most studies only investigated on its effect on teaching a specific SE concept, and (3) students may make mistakes in their contribution which leads to poor quality code. Meanwhile, software companies have successfully launched programs like Google Summer of Code (GSoC) and FindBugs "fixit" to contribute to open-source projects. Inspired by the success of these programs, we propose GitHub-OSS Fixit, a team-based course project where students are taught to contribute to open-source Java projects by fixing bugs reported in GitHub. We described our course outline to teach students SE concepts by encouraging the usages of several automated program analysis tools. We also included the carefully designed instructions that we gave to students for participating in GitHub-OSS Fixit. As all lectures and labs are conducted online, we think that our course design could help in guiding future online SE courses. Overall, our survey results show that students think that GitHub-OSS Fixit could help them to improve many skills and apply the knowledge taught in class. In total, 154 students have submitted 214 pull requests to 24 different Java projects, in which 93 of them have been merged, and 46 have been closed by developers.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00009;;;Software AND Engineering
GasHolesJ- a software tool for measurement of gas holes in cheese;;;['Angel Danev', 'Atanaska Bosakova-Ardenska', 'Petar Panayotov', 'Petya Boyanova'];;;June 2021;;;CompSysTech '21: Proceedings of the 22nd International Conference on Computer Systems and Technologies;;;The aim of this paper is to present an approach for objective and automatic detection and measure the gas holes in Swiss-type of cheese (Emmental) by computer vision techniques. Samples of four brands of Emmental cheese are bought from the marketplace. The cheese is factory cut into slices. Each slice of the cheese is captured at both sides by a digital camera and the images are saved locally in a computer. A standalone computer program called GasHolesJ is developed for processing the images. The program uses techniques for performing manual thresholding and nineteen algorithms for global auto thresholding are implemented in it. The results images obtained after performing manual and auto thresholding are analyzed and a difference operation between them is performed, in order to compare the efficiency of each auto threshold algorithms with the efficiency of manual threshold technique. The results show that six algorithms for global auto thresholding are effective enough for detection gas holes in Emmental cheese.;;;https://dl.acm.org/doi/10.1145/3472410.3472424;;;Software AND Engineering
Effect of Mobile Devices and Software in Collaborative Learning Smart Classroom on Students’ Learning Motivation;;;['Chen Guo', 'Ying Huang'];;;May 2021;;;ICDEL '21: Proceedings of the 2021 6th International Conference on Distance Education and Learning;;;Motivational factors are critical for engaging and sustaining students to use mobile devices for learning purposes. The purpose of this study is to investigate a group of college students’ attitudes towards applying mobile devices and software in a smart classroom and the effect of the facilities on the students’ language learning motivation. Results indicate that the participants demonstrated a positive attitude towards the role the mobile devices and software plays in the smart classroom in general. Besides, utilization of the mobile devices and software can also help facilitate students’ learning motivation. The structure of a well-designed collaborative learning smart classroom (CLSC) for language learning is proposed in this study as well.;;;https://dl.acm.org/doi/10.1145/3474995.3475000;;;Software AND Engineering
Research on the Copyright Protection of Open Source Code and Its Derivative Software Works Based on Internet and Information Technology;;;['Yanqing Fang'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;Most of the open source code adopts the GPL agreement, that is, derivative software works developed using open source code must recognize the copyright of the software work author, and at the same time, the author must allow anyone to enjoy the freedom to use, copy, modify, and derive his work. However, this limitation inevitably leads to judicial disputes because of the lack of relevant applicable principles and legislative basis. The article believes that it has the dual attributes of deductive works and cooperative works, and then analyzes the corresponding copyright ownership and exercise, and specifically elaborates how to define whether it constitutes copyright infringement in judicial practice. If we can improve the corresponding legal system and establish a dispute prevention mechanism for open source software activities, it will bring huge benefits to the development of open source software and the entire network industry.;;;https://dl.acm.org/doi/10.1145/3495018.3495376;;;Software AND Engineering
What helped, and what did not?: An Evaluation of the Strategies to Improve Continuous Integration;;;['Xianhao Jin', 'Francisco Servant'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Continuous integration (CI) is a widely used practice in modern software engineering. Unfortunately, it is also an expensive practice --- Google and Mozilla estimate their CI systems in millions of dollars. There are a number of techniques and tools designed to or having the potential to save the cost of CI or expand its benefit - reducing time to feedback. However, their benefits in some dimensions may also result in drawbacks in others. They may also be beneficial in other scenarios where they are not designed to help. In this paper, we perform the first exhaustive comparison of techniques to improve CI, evaluating 14 variants of 10 techniques using selection and prioritization strategies on build and test granularity. We evaluate their strengths and weaknesses with 10 different cost and time-to-feedback saving metrics on 100 real-world projects. We analyze the results of all techniques to understand the design decisions that helped different dimensions of benefit. We also synthesized those results to lay out a series of recommendations for the development of future research techniques to advance this area.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00031;;;Software AND Engineering
A tutorial on how to connect python with different simulation software to develop rich simheuristics;;;['Mohammad Peyman', 'Pedro Copado', 'Javier Panadero', 'Angel A. Juan', 'Mohammad Dehghanimohammadabadi'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;Simulation is an excellent tool to study real-life systems with uncertainty. Discrete-event simulation (DES) is a common simulation approach to model time-dependent and complex systems. Therefore, there are a variety of commercial (Simio, AnyLogic, Simul8, Arena, etc.) and non-commercial (SimPy, Salabim, etc.) software packages that enable users to take advantage of DES modeling. Although these tools are capable of modeling real-life systems with a high accuracy, they generally fail to conduct advanced analytical analysis (i.e., machine learning, interactive visualizations) or complicated optimization (i.e., simheuristics). Therefore, coupling these DES platforms with external programming languages like Python offers additional mathematical operations and algorithmic flexibility. This integration makes the simulation modeling more intelligent and extends its applicability to a broader range of problems. This study aims to provide a step-wise tutorial for helping simulation users to create intelligent DES models by integrating them with Python. Multiple demo examples are discussed to provide insights and making this connection based on commercial and non-commercial DES packages.;;;https://dl.acm.org/doi/10.5555/3522802.3522805;;;Software AND Engineering
Towards domain-specific modelling environments based on augmented reality;;;['Léa Brunschwig', 'Rubén Campos-López', 'Esther Guerra', 'Juan de Lara'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Models are pervasive in many disciplines, like software and systems engineering. Modelling by the use of domain-specific languages (DSLs) has lowered the entry barrier to this activity to domain experts and citizen developers. At the same time, we are witnessing constant improvements in the capabilities of mobile devices, like augmented reality (AR) based on their camera. AR could be exploited in modelling scenarios that require locating virtual objects in the surrounding physical space. In this vision paper, we explore the use of DSLs with AR syntax, and propose the automated synthesis of mobile modelling environments for them. This opens the door to novel scenarios for domain-specific modelling in areas like interior design, Industry 4.0, domotics, tourism and transportation, among others. We propose a design process founded on Software Language Engineering principles, provide prototype tool support, and identify open challenges for the community.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00020;;;Software AND Engineering
Adaptive Precision Block-Jacobi for High Performance Preconditioning in the Ginkgo Linear Algebra Software;;;['Goran Flegar', 'Hartwig Anzt', 'Terry Cojean', 'Enrique S. Quintana-Ortí'];;;None;;;ACM Transactions on Mathematical Software;;;The use of mixed precision in numerical algorithms is a promising strategy for accelerating scientific applications. In particular, the adoption of specialized hardware and data formats for low-precision arithmetic in high-end GPUs (graphics processing units) has motivated numerous efforts aiming at carefully reducing the working precision in order to speed up the computations. For algorithms whose performance is bound by the memory bandwidth, the idea of compressing its data before (and after) memory accesses has received considerable attention. One idea is to store an approximate operator–like a preconditioner–in lower than working precision hopefully without impacting the algorithm output. We realize the first high-performance implementation of an adaptive precision block-Jacobi preconditioner which selects the precision format used to store the preconditioner data on-the-fly, taking into account the numerical properties of the individual preconditioner blocks. We implement the adaptive block-Jacobi preconditioner as production-ready functionality in the Ginkgo linear algebra library, considering not only the precision formats that are part of the IEEE standard, but also customized formats which optimize the length of the exponent and significand to the characteristics of the preconditioner blocks. Experiments run on a state-of-the-art GPU accelerator show that our implementation offers attractive runtime savings.;;;https://dl.acm.org/doi/10.1145/3441850;;;Software AND Engineering
Please turn your cameras on: remote onboarding of software developers during a pandemic;;;['Paige Rodeghero', 'Thomas Zimmermann', 'Brian Houck', 'Denae Ford'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;The COVID-19 pandemic has impacted the way that software development teams onboard new hires. Previously, most software developers worked in physical offices and new hires onboarded to their teams in the physical office, following a standard onboarding process. However, when companies transitioned employees to work from home due to the pandemic, there was little to no time to develop new onboarding procedures. In this paper, we present a survey of 267 new hires at Microsoft that onboarded to software development teams during the pandemic. We explored their remote onboarding process, including the challenges that the new hires encountered and their social connectedness with their teams. We found that most developers onboarded remotely and never had an opportunity to meet their teammates in person. This leads to one of the biggest challenges faced by these new hires, building a strong social connection with their team. We use these results to provide recommendations for onboarding remote hires.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00013;;;Software AND Engineering
A survey of wireless network simulation and/or emulation software for use in higher education;;;['Theodore A. Richards V', 'Eric Gamess', 'David Thornton'];;;April 2021;;;ACM SE '21: Proceedings of the 2021 ACM Southeast Conference;;;In this paper, we survey network simulators and/or emulators with support for wireless networks. We selected six tools, OMNeT++/INET, ns-3, Packet Tracer, Mininet-WiFi, CORE and Komondor, and further investigate them in regards to their potential use in higher education. These simulators/emulators are readily available and have support for wireless networks in one form or another. The goal of the paper is to help instructors in choosing adequate software to assist online teaching of courses related to wireless networks, including laboratories, using virtual devices, with a minimum investment.;;;https://dl.acm.org/doi/10.1145/3409334.3452066;;;Software AND Engineering
On the experiences of adopting automated data validation in an industrial machine learning project;;;['Lucy Ellen Lwakatare', 'Ellinor Rånge', 'Ivica Crnkovic', 'Jan Bosch'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Background: Data errors are a common challenge in machine learning (ML) projects and generally cause significant performance degradation in ML-enabled software systems. To ensure early detection of erroneous data and avoid training ML models using bad data, research and industrial practice suggest incorporating a data validation process and tool in ML system development process. Aim: The study investigates the adoption of a data validation process and tool in industrial ML projects. The data validation process demands significant engineering resources for tool development and maintenance. Thus, it is important to identify the best practices for their adoption especially by development teams that are in the early phases of deploying ML-enabled software systems. Method: Action research was conducted at a large-software intensive organization in telecommunications, specifically within the analytics R&D organization for an ML use case of classifying faults from returned hardware telecommunication devices. Results: Based on the evaluation results and learning from our action research, we identified three best practices, three benefits, and two barriers to adopting the data validation process and tool in ML projects. We also propose a data validation framework (DVF) for systematizing the adoption of a data validation process. Conclusions: The results show that adopting a data validation process and tool in ML projects is an effective approach of testing ML-enabled software systems. It requires having an overview of the level of data (feature, dataset, cross-dataset, data stream) at which certain data quality tests can be applied.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00034;;;Software AND Engineering
Automating the design flow under dynamic partial reconfiguration for hardware-software co-design in FPGA SoC;;;['Biruk Seyoum', 'Marco Pagani', 'Alessandro Biondi', 'Giorgio Buttazzo'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Despite its benefits, hardware acceleration under dynamic partial reconfiguration (DPR) has not been fully leveraged by many system designers, mostly due to the complexities of the DPR design flow and the lack of efficient design tools to automate the design process. Furthermore, making such a design approach suitable for real-time embedded systems requires the need for extending the standard DPR design flow with additional design steps, which have to accurately account for the timing behavior of the software and hardware components of the design, as well as of the components of the computing platform (e.g., the reconfiguration interface). To address this problem, this paper presents DART, a tool that fully automates the design flow in a real-time DPR-based system that comprises both software and hardware components. The tool targets the Zynq 7-series and Ultrascale+ FPGA-based SoCs by Xilinx. It aims at alleviating the manual effort required by state-of-the-art tools while not expecting high expertise in the design of programmable logic components under DPR. To this purpose, it fully automates the partitioning, floorplanning, and implementation (routing and bitstream generation) phases, generating a set of bitstreams starting from a set of tasks annotated with high-level timing requirements. The tool leverages mathematical optimization to solve the partitioning and floorplanning problems, and relies on a set of auto-generated scripts that interact with the vendor tools to mobilize the synthesis and implementation stages. DART has been experimentally evaluated with a case study application from an accelerated image processing system.;;;https://dl.acm.org/doi/10.1145/3412841.3441928;;;Software AND Engineering
GenTree: Using Decision Trees to Learn Interactions for Configurable Software;;;['KimHao Nguyen', 'ThanhVu Nguyen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Modern software systems are increasingly designed to be highly configurable, which increases flexibility but can make programs harder to develop, test, and analyze, e.g., how configuration options are set to reach certain locations, what characterizes the configuration space of an interesting or buggy program behavior? We introduce GenTree, a new dynamic analysis that automatically learns a program's interactions---logical formulae that describe how configuration option settings map to code coverage. GenTree uses an iterative refinement approach that runs the program under a small sample of configurations to obtain coverage data; uses a custom classifying algorithm on these data to build decision trees representing interaction candidates; and then analyzes the trees to generate new configurations to further refine the trees and interactions in the next iteration. Our experiments on 17 configurable systems spanning 4 languages show that GenTree efficiently finds precise interactions using a tiny fraction of the configuration space.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00142;;;Software AND Engineering
Studying Test Annotation Maintenance in the Wild;;;['Dong Jae Kim', 'Nikolaos Tsantalis', 'Tse-Hsun Peter Chen', 'Jinqiu Yang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Since the introduction of annotations in Java 5, the majority of testing frameworks, such as JUnit, TestNG, and Mockito, have adopted annotations in their core design. This adoption affected the testing practices in every step of the test life-cycle, from fixture setup and test execution to fixture teardown. Despite the importance of test annotations, most research on test maintenance has mainly focused on test code quality and test assertions. As a result, there is little empirical evidence on the evolution and maintenance of test annotations. To fill this gap, we perform the first fine-grained empirical study on annotation changes. We developed a tool to mine 82,810 commits and detect 23,936 instances of test annotation changes from 12 open-source Java projects. Our main findings are: (1) Test annotation changes are more frequent than rename and type change refactorings. (2) We recover various migration efforts within the same testing framework or between different frameworks by analyzing common annotation replacement patterns. (3) We create a taxonomy by manually inspecting and classifying a sample of 368 test annotation changes and documenting the motivations driving these changes. Finally, we present a list of actionable implications for developers, researchers, and framework designers.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00019;;;Software AND Engineering
How Was Your Weekend?: Software Development Teams Working From Home During COVID-19;;;['Courtney Miller', 'Paige Rodeghero', 'Margaret-Anne Storey', 'Denae Ford', 'Thomas Zimmermann'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The mass shift to working at home during the COVID-19 pandemic radically changed the way many software development teams collaborate and communicate. To investigate how team culture and team productivity may also have been affected, we conducted two surveys at a large software company. The first, an exploratory survey during the early months of the pandemic with 2,265 developer responses, revealed that many developers faced challenges reaching milestones and that their team productivity had changed. We also found through qualitative analysis that important team culture factors such as communication and social connection had been affected. For example, the simple phrase "How was your weekend?" had become a subtle way to show peer support. In our second survey, we conducted a quantitative analysis of the team cultural factors that emerged from our first survey to understand the prevalence of the reported changes. From 608 developer responses, we found that 74% of these respondents missed social interactions with colleagues and 51% reported a decrease in their communication ease with colleagues. We used data from the second survey to build a regression model to identify important team culture factors for modeling team productivity. We found that the ability to brainstorm with colleagues, difficulty communicating with colleagues, and satisfaction with interactions from social activities are important factors that are associated with how developers report their software development team's productivity. Our findings inform how managers and leaders in large software companies can support sustained team productivity during times of crisis and beyond.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00064;;;Software AND Engineering
Computational Thinking in the Mathematics Classroom: Fostering Algorithmic Thinking and Generalization Skills Using Dynamic Mathematics Software;;;['Sylvia van Borkulo', 'Christos Chytas', 'Paul Drijvers', 'Erik Barendsen', 'Jos Tolboom'];;;October 2021;;;WiPSCE '21: Proceedings of the 16th Workshop in Primary and Secondary Computing Education;;;There are increasing calls for mathematics teachers to foster computational thinking (CT) skills in their lessons and align them with existing curricula and national educational policies. Algorithmic thinking (AT) and generalization are two key elements of CT that are often underrepresented in traditional mathematics lessons. This study investigated how to address AT and generalization aspects in 12th-grade calculus lessons using the dynamic mathematics software GeoGebra. We present a six-lesson intervention designed by an interdisciplinary team of researchers and teachers with a background in computer science and mathematics education that aims to foster pre-university students’ AT and generalization skills in calculus lessons. We evaluated the intervention in a 15 students classroom in the Netherlands through the analysis of students’ workbooks, files, interviews, and the teacher’s logbook. The findings suggest that the intervention was favorably seen by both the teacher and the students, and that their learning and teaching experience was highly satisfactory. The most common challenges for successfully completing the designed material included issues related to getting familiar with GeoGebra, syntax, and effectively using conditional statements. Finally, we report on the learning and teaching experience and discuss strategies to address AT and generalization aspects for teachers who wish to address such CT aspects in mathematics lessons.;;;https://dl.acm.org/doi/10.1145/3481312.3481319;;;Software AND Engineering
Comparing within- and cross-project machine learning algorithms for code smell detection;;;['Manuel De Stefano', 'Fabiano Pecorelli', 'Fabio Palomba', 'Andrea De Lucia'];;;August 2021;;;MaLTESQuE 2021: Proceedings of the 5th International Workshop on Machine Learning Techniques for Software Quality Evolution;;;Code smells represent a well-known problem in software engineering, since they are a notorious cause of loss of comprehensibility and maintainability. The most recent efforts in devising automatic machine learning-based code smell detection techniques have achieved unsatisfying results so far. This could be explained by the fact that all these approaches follow a within-project classification, i.e. training and test data are taken from the same source project, which combined with the imbalanced nature of the problem, produces datasets with a very low number of instances belonging to the minority class (i.e. smelly instances). In this paper, we propose a cross-project machine learning approach and compare its performance with a within-project alternative. The core idea is to use transfer learning to increase the overall number of smelly instances in the training datasets. Our results have shown that cross-project classification provides very similar performance with respect to within-project. Despite this finding does not yet provide a step forward in increasing the performance of ML techniques for code smell detection, it sets the basis for further investigations.;;;https://dl.acm.org/doi/10.1145/3472674.3473978;;;Software AND Engineering
Analysis of "Influence of Inclusive Leadership on Team Performance" based on SPSS software: Based on the Mediating Role of Employee Voice Behaviors;;;['Li Xiaomei', 'Gao Chaomin'];;;June 2021;;;ICCIR '21: Proceedings of the 2021 1st International Conference on Control and Intelligent Robotics;;;In order to clarify the influence of inclusive leadership style on team performance and the mediating effect of suggestion behavior, based on a summary of related research, an inclusive leader has a significant positive impact on team performance, and the suggestion behavior has inclusive leadership Theoretical assumptions such as playing an intermediary role in the impact of team performance, designing a questionnaire using a widely recognized maturity scale, and using questionnaire stars to survey 300 grassroots employees, The results show that the three dimensions of openness, availability, and accessibility of inclusive leadership have a significant positive impact on team performance; the behavior of initiation plays an intermediary role in the three dimensions of inclusive leadership and team performance. Use spss23.0 analysis software related analysis (Pearson) and hypothesis testing, the independent variable and dependent variable, the mediation variables into formula for correlation analysis, and learned that the correlation coefficient between 0.503** and 0.685**, no more than 0.700, shows that the correlation degree between the three independent variables as moderate correlation, and there is no collinearity problem, and presents the 0.01 level of significance, which shows a significant positive correlation between the three variables. Further hypothesis test, the dependent variable respectively into the argument inclusive leadership team performance of usability, accessibility, openness, the regression equation model, that decision coefficient (R squared value of 0.241**, 0.243**, 0.268**, and presents the 0.01 level of significance, and inclusive leadership openness, availability, accessibility, positive influence on team performance. Finally the mediation role of inspection, the team performance as the dependent variable, inclusive leadership openness, availability, accessibility, as the independent variable, will advice behavior as a intervening variable, into the linear regression model, that decision coefficient (R squared value of 0.408**, 0.419**, 0.402**, and presents the 0.01 level of significance, on the basis of Baron and Kenny (1986) proposed by the intermediary effect, advice behavior in inclusive leadership openness, availability, accessibility, and the impact of team performance has partial intermediary role. Based on this result, make management suggestions for the organization or team: you can introduce inclusive leaders, or train existing managers with the characteristics of capacitive leadership styles to meet the needs of modern management.;;;https://dl.acm.org/doi/10.1145/3473714.3473776;;;Software AND Engineering
Effectiveness of peer review in teaching and learning user centered conceptual design among large cohorts of information technology students;;;['Farshid Anvari', 'Hien Minh Thi Tran', 'Deborah Richards'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Conceptual design often sets the direction of the development of a product. Educating Software Engineering and Information Technology (IT) students to consider the needs of users during the conceptual design stage is important. The assessment of conceptual design is a time consuming process. When budgets are limited, financial resources are inadequately allocated to allow staff to spend quality time assessing the conceptual design artifacts of large classes. We present a methodology to teach, capture and evaluate conceptual design artifacts for large classes. In two separate studies, two groups of over 185 undergraduate IT students reviewed their peers' design artifacts using a comprehensive rubric. Their reviews were later checked by two researchers using the same rubric. It was found that not only were the student-peers' reviews close to the researchers' reviews, it was possible to give students valuable and timely feedback and scaffold them to reflect, an essential characteristic for professional competence. In addition, we found that assessment by staff was not feasible due to inadequate resources. We conclude that for large classes, conceptual design artifacts can be evaluated and valuable feedback provided in a timely manner by peers with the guidance of a comprehensive rubric.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00016;;;Software AND Engineering
Modding Support of Game Engines;;;['Lukas Schreiner', 'Sebastian von Mammen'];;;August 2021;;;FDG '21: Proceedings of the 16th International Conference on the Foundations of Digital Games;;;This paper aims at showing how different game engines support modding. To this end, the concepts of modding and game engines alongside their historical evolution are introduced first. Additionally, some well-known game engines and mods are presented, and their unique features are described. Further, the effects of using game engines and those that modding has on games, developers, and players are laid out. Particular focus is placed on the effects on competitive games. These effects include an enhanced lifespan for games and the requirement for more development effort. Finally, the modding-support of selected game engines is illustrated and compared with each other. These engines are the id Tech engine(s), Unreal Engine, the Source engine, and Unity. The paper is then concluded with an outlook on future research possibilities and recommendations to developers.;;;https://dl.acm.org/doi/10.1145/3472538.3472574;;;Software AND Engineering
μSE: mutation-based evaluation of security-focused static analysis tools for Android;;;['Amit Seal Ami', 'Kaushal Kafle', 'Adwait Nadkarni', 'Denys Poshyvanyk', 'Kevin Moran'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This demo paper presents the technical details and usage scenarios of μSE: a mutation-based tool for evaluating security-focused static analysis tools for Android. Mutation testing is generally used by software practitioners to assess the robustness of a given test-suite. However, we leverage this technique to systematically evaluate static analysis tools and uncover and document soundness issues. μSE's analysis has found 25 previously undocumented flaws in static data leak detection tools for Android. μSE offers four mutation schemes, namely Reachability, Complex-reachability, TaintSink, and ScopeSink, which determine the locations of seeded mutants. Furthermore, the user can extend μSE by customizing the API calls targeted by the mutation analysis. μSE is also practical, as it makes use of filtering techniques based on compilation and execution criteria that reduces the number of ineffective mutations. Website: https://muse-security-evaluation.github.io Video URL: https://youtu.be/Kfkzi57gYys;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00034;;;Software AND Engineering
Innovative design of legal practice teaching system based on LETS software;;;['Yao Liu'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;In recent years, the rapid development of the legal practice teaching system has caused some problems. The huge gap between legal education and the legal profession is a remarkable achievement. In order to solve this problem, the experimental teaching of law must be strengthened. At the same time, under the background of the huge scale of legal education in our country, it is a good choice to effectively carry out legal experiment education and the road of informationization. Follow-up law education should implement the goal of training applied talents. Applied legal talents should not only master a solid legal theoretical foundation, but also have proficient legal practice skills. The application of the emerging legal experimental teaching system LETS system has achieved this goal. However, the application of the LETS system has also made us discover that there are many problems in the current legal practice teaching. The students lack professional legal skills and cannot cope with the solution of actual cases. Students’ legal practice lacks effective guidance, legal business contacts are narrow, legal skills lack comprehensive training, and the evaluation system of legal professional skills training courses is in urgent need of reform. In this regard, we must establish a comprehensive legal professional skills training model and innovate the legal practice teaching system by scientifically and rationally setting up legal practice teaching courses, layering and systematic teaching content, and improving teachers' legal application ability.;;;https://dl.acm.org/doi/10.1145/3482632.3482691;;;Software AND Engineering
When and How to Make Breaking Changes: Policies and Practices in 18 Open Source Software Ecosystems;;;['Chris Bogart', 'Christian Kästner', 'James Herbsleb', 'Ferdian Thung'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Open source software projects often rely on package management systems that help projects discover, incorporate, and maintain dependencies on other packages, maintained by other people. Such systems save a great deal of effort over ad hoc ways of advertising, packaging, and transmitting useful libraries, but coordination among project teams is still needed when one package makes a breaking change affecting other packages. Ecosystems differ in their approaches to breaking changes, and there is no general theory to explain the relationships between features, behavioral norms, ecosystem outcomes, and motivating values. We address this through two empirical studies. In an interview case study, we contrast Eclipse, NPM, and CRAN, demonstrating that these different norms for coordination of breaking changes shift the costs of using and maintaining the software among stakeholders, appropriate to each ecosystem’s mission. In a second study, we combine a survey, repository mining, and document analysis to broaden and systematize these observations across 18 ecosystems. We find that all ecosystems share values such as stability and compatibility, but differ in other values. Ecosystems’ practices often support their espoused values, but in surprisingly diverse ways. The data provides counterevidence against easy generalizations about why ecosystem communities do what they do.;;;https://dl.acm.org/doi/10.1145/3447245;;;Software AND Engineering
What do pre-trained code models know about code?;;;['Anjan Karmakar', 'Romain Robbes'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Pre-trained models of code built on the transformer architecture have performed well on software engineering (SE) tasks such as predictive code generation, code summarization, among others. However, whether the vector representations from these pre-trained models comprehensively encode characteristics of source code well enough to be applicable to a broad spectrum of downstream tasks remains an open question. One way to investigate this is with diagnostic tasks called probes. In this paper, we construct four probing tasks (probing for surface-level, syntactic, structural, and semantic information) for pre-trained code models. We show how probes can be used to identify whether models are deficient in (understanding) certain code properties, characterize different model layers, and get insight into the model sample-efficiency. We probe four models that vary in their expected knowledge of code properties: BERT (pre-trained on English), CodeBERT and CodeBERTa (pre-trained on source code, and natural language documentation), and GraphCodeBERT (pre-trained on source code with dataflow). While GraphCodeBERT performs more consistently overall, we find that BERT performs surprisingly well on some code tasks, which calls for further investigation.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678927;;;Software AND Engineering
Cultivation of applied talents from the perspective of Ucinet software measurement Research on Visualization of General Aesthetic Education Construction;;;['Chen Wenxuanzi'];;;December 2021;;;EBIMCS '21: Proceedings of the 2021 4th International Conference on E-Business, Information Management and Computer Science;;;Abstract: At present, the lack of top-level design in the construction of aesthetic education in Chinese colleges and universities has caused general aesthetic education to stay on the surface. The division of specialties in local applied universities has also led to dysfunction of general aesthetic education, and insufficient reforms have led to problems such as the lack of general aesthetic education. Application-oriented colleges and universities face the training of application-oriented talents, and need to clarify their goals of general education reform, realize the return of general spirit through aesthetic education reform, and serve the cultivation of high-quality applied talents through general education reform. Based on the characteristics of application-oriented universities and combined with Ucinet software, this article will consider and explore the construction of general aesthetic education courses for application-oriented talent training. This issue will be discussed and analyzed by the predecessors through knowledge graphs for more in-depth interpretation and analysis.;;;https://dl.acm.org/doi/10.1145/3511716.3511774;;;Software AND Engineering
Investigating the interplay between developers and automation;;;['Omar Elazhary'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Continuous practices are a staple of the modern software development workflow. Automation, in particular, is widely adopted due to its benefits related to quality and productivity. However, automation, similarly to all other aspects of the software development workflow, interacts with humans (in this case developers). While some work has investigated the impact of automation on developers, it is not clear to what extent context and process influence that impact. We present our ADEPT theory of developers and automation, in an attempt to bridge this gap and identify the possible ways context, process, and other factors may influence how developers perceive, interpret, and interact with automation.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00064;;;Software AND Engineering
Design and Simulation of Engine Management System;;;['Salma Mohammed', 'Masouda Mohamed', 'Tahani Abdalmawla'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;The development of manufacturing and management, technologies over the previous decade has transformed the automotive industry. The engine management system is undoubtedly one of the most intelligent systems in today’s automobile. The purpose of this paper is to design and simulate an automotive engine management system. Based on a PIC development board, we design and implement engine control functions which include an ignition system, acceleration, deceleration, emergency brakes, hand brakes, speed, and distance travelled. The C language is chosen for the development of PIC microcontroller. Results have shown and proven the success of the proposed system.;;;https://dl.acm.org/doi/10.1145/3492547.3492605;;;Software AND Engineering
Considering the Artifact Ecology when Supporting the Evolution of Practices - Analyzing the Parallel Journeys of Two Teleconsultation Software in a General Hospital;;;['Clément Cormi', 'Khuloud Abou-Amsha', 'Matthieu Tixier', 'Myriam Lewkowicz'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;The growing use of teleconsultation, especially since the start of the Covid-19 pandemic, changes physicians' work at the hospital. In this paper, we set out to study how physicians have integrated teleconsultation into their healthcare practices. Moreover, we are interested in how teleconsultation software contributes to developing new medical practices and how the design of teleconsultation software can better support them. Based on 16 months of fieldwork in a general hospital that offers two different teleconsultation software, we have investigated teleconsultation practices through interviews and observations involving ten physicians doing teleconsultation and a telemedicine secretary. Unlike the existing informal remote care by phone, we observe that teleconsultation supports new formal healthcare practices, particularly for patient care management and inter-organizational cooperation. While analyzing the integration of teleconsultation in physicians' practices, we highlight that both pieces of software do not support those practices on equal terms according to their design. We argue that teleconsultation software design can limit the spread of these new healthcare practices and that the artifact ecology of physicians should be considered during the design process.;;;https://dl.acm.org/doi/10.1145/3492821;;;Software AND Engineering
Ethics: What is the Research Scenario in the Brazilian Symposium SBQS?;;;['Luiz Paulo Carvalho', 'José Antonio Suzano', 'Monica Anastassiu', 'Flávia Maria Santoro', 'Jonice Oliveira', 'João Carlos Gonçalves'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Many practitioners and researchers still consider software as program code, composed by algorithms and associated documentation, written in a programming language, and finally compiled or interpreted in a computational environment. The different facets of the software question, explored in interdisciplinary fields such as Digital Humanities, seem largely unexplored in Software Engineering and other traditional Computing fields of research. This paper aims to present an overview of ethical aspects through the publications of the Brazilian Symposium on Software Quality (SBQS). We followed a Systematic Literature Review (SLR) approach and presented quantitative and qualitative, and in-depth results, analyzing fifteen editions of the SBQS between 2006 and 2020. We adopted the concept of Ethics in a primary way, through searches for terms directly associated, and secondary, by terms such as Informed Consent, aligned with the definitions and concepts of Computational Ethics combined with episteme and good practices in Software Engineering. The results pointed to the minor occurrence of ethical aspects in SBQS publications, growing timidly over the years. We conclude that there is broad space to explore the theme of Computational Ethics combined with Software Quality.;;;https://dl.acm.org/doi/10.1145/3493244.3493249;;;Software AND Engineering
The Design and Implementation of the Score Query App Software Based on the iOS Platform;;;['Zhe Li', 'Lin Zhang', 'Yongchang Ren'];;;December 2021;;;ICASIT 2021: 2021 International Conference on Aviation Safety and Information Technology;;;None;;;https://dl.acm.org/doi/10.1145/3510858.3510995;;;Software AND Engineering
ADEPT: a socio-technical theory of continuous integration;;;['Omar Elazhary', 'Margaret-Anne Storey', 'Neil A. Ernst', 'Elise Paradis'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Continuous practices that rely on automation in the software development workflow have been widely adopted by industry for over a decade. Despite this widespread use, software development remains a primarily human-driven activity that is highly creative and collaborative. There has been extensive research on how continuous practices rely on automation and its impact on software quality and development velocity, but relatively little has been done to understand how automation impacts developer behavior and collaboration. In this paper, we introduce a socio-technical theory about continuous practices. The ADEPT theory combines constructs that include humans, processes, documentation, automation and the project environment, and describes propositions that relate these constructs. The theory was derived from phenomena observed in previous empirical studies. We show how the ADEPT theory can explain and describe existing continuous practices in software development, and how it can be used to generate new propositions for future studies to understand continuous practices and their impact on the social and technical aspects of software development.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00014;;;Software AND Engineering
How to Identify Boundary Conditions with Contrasty Metric?;;;['Weilin Luo', 'Hai Wan', 'Xiaotong Song', 'Binhao Yang', 'Hongzhen Zhong', 'Yin Chen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The boundary conditions (BCs) have shown great potential in requirements engineering because a BC captures the particular combination of circumstances, i.e., divergence, in which the goals of the requirement cannot be satisfied as a whole. Existing researches have attempted to automatically identify lots of BCs. Unfortunately, a large number of identified BCs make assessing and resolving divergences expensive. Existing methods adopt a coarse-grained metric, generality, to filter out less general BCs. However, the results still retain a large number of redundant BCs since a general BC potentially captures redundant circumstances that do not lead to a divergence. Furthermore, the likelihood of BC can be misled by redundant BCs resulting in costly repeatedly assessing and resolving divergences. In this paper, we present a fine-grained metric to filter out the redundant BCs. We first introduce the concept of contrasty of BC. Intuitively, if two BCs are contrastive, they capture different divergences. We argue that a set of contrastive BCs should be recommended to engineers, rather than a set of general BCs that potentially only indicates the same divergence. Then we design a post-processing framework (PPFc) to produce a set of contrastive BCs after identifying BCs. Experimental results show that the contrasty metric dramatically reduces the number of BCs recommended to engineers. Results also demonstrate that lots of BCs identified by the state-of-the-art method are redundant in most cases. Besides, to improve efficiency, we propose a joint framework (JFc) to interleave assessing based on the contrasty metric with identifying BCs. The primary intuition behind JFc is that it considers the search bias toward contrastive BCs during identifying BCs, thereby pruning the BCs capturing the same divergence. Experiments confirm the improvements of JFc in identifying contrastive BCs.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00132;;;Software AND Engineering
Parallel Component Composition and Performance Optimization Based on Agent Technology;;;['Yunfeng Peng', 'Congming Shi', 'Guowei Gao', 'Jianan Wang', 'Hai Liu'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;In order to better assemble parallel component programs and optimize performance, different software agents are designed and used. The component connection agent is responsible for the component interface glue and data redistribution. The component execution agent and resource management agent cooperate with each other to deploy the components on the computing nodes that meet the resource requirements. Four different component adaptive strategies are defined. Different component adaptive agent, component execution agent and resource management agent cooperate with each other to complete the adaptive process of component and improve the performance of component. Resource management agent, load detection agent and component execution agent cooperate with each other to complete the load balancing work and improve the performance and throughput of the whole computing platform. Experiments on heterogeneous computer clusters demonstrate the effectiveness of the proposed parallel component assembly and performance optimization method based on agent technology. Compared with the traditional performance optimization methods, the method based on agent technology is flexible and has performance advantages.;;;https://dl.acm.org/doi/10.1145/3494885.3494929;;;Software AND Engineering
Building a bot for automatic expert retrieval on discord;;;['Ignacio Nuñez Norambuena', 'Alexandre Bergel'];;;August 2021;;;MaLTESQuE 2021: Proceedings of the 5th International Workshop on Machine Learning Techniques for Software Quality Evolution;;;It is common for software practitioners to look for experts on online chat platforms, such as Discord. However, finding them is a complex activity that requires a deep knowledge of the open source community. As a consequence, newcomers and casual participants may not be able to adequately find experts willing to discuss a particular topic.   Our paper describes a bot that provides a ranked list of Discord users that are experts in a particular set of topics. Our bot uses simple heuristics to model expertise, such as a word occurrence table and word embeddings. Our bot shows that at least half of the retrieved users are indeed experts.;;;https://dl.acm.org/doi/10.1145/3472674.3473982;;;Software AND Engineering
Reducing network latency in industrial IoT systems using hardware-software complex based on injection;;;['Alexey Slepnev', 'Danila Matveev', 'Evgenii Karelin', 'Ivan Tumanov', 'Ivan Vnukov', 'Ruslan Kirichek', 'Igor Kandakov'];;;December 2021;;;ICFNDS 2021: The 5th International Conference on Future Networks &amp; Distributed Systems;;;Over the past couple of years, the Internet and data networks have evolved noticeably. The number of IoT devices is increasing every year, and according to forecasts, it will continue to grow. Because of this, the shortcomings of today’s network architecture are becoming more and more apparent. In this article, we present a universal system for optimizing networks, in which it will be built.;;;https://dl.acm.org/doi/10.1145/3508072.3508227;;;Software AND Engineering
Teaching DevOps: a tale of two universities;;;['Richard Hobeck', 'Ingo Weber', 'Len Bass', 'Hasan Yasar'];;;October 2021;;;SPLASH-E 2021: Proceedings of the 2021 ACM SIGPLAN International Symposium on SPLASH-E;;;DevOps is a set of practices in software engineering that is in high demand by industry. It is a dynamic field which constantly adds new methods and tools. Teaching DevOps prepares today’s computer science students for best-practices in a working environment but challenges university lecturers to provide central concepts while staying up-to-date with current trends. In this paper we report and reflect on our experiences teaching DevOps at two universities (in the USA and Germany) in an inverted classroom format. We describe how we set-up the courses, provide a brief analysis of data we collected, and share our lessons learned.;;;https://dl.acm.org/doi/10.1145/3484272.3484962;;;Software AND Engineering
Naming Practices in Java Projects: An Empirical Study;;;['Remo Gresta', 'Vinicius Durelli', 'Elder Cirilo'];;;November 2021;;;SBQS '21: Proceedings of the XX Brazilian Symposium on Software Quality;;;Investigating the properties of identifier names and their role in software systems have been central to software engineering. Research in naming identifiers shows that informative names are crucial to improving the readability and maintainability of programs: essentially, intention-revealing names make code easier to understand and act as a basic form of documentation. Poorly named identifiers tend to hurt the comprehensibility and maintainability of software systems. However, most computer science curricula emphasize programming concepts and language syntax over naming guidelines and conventions. Consequently, programmers lack knowledge about naming practices. We carried out a study to explore the naming practices of Java programmers. We analyzed 1,421,607 identifier names (i.e., attributes, parameters, and variables names) from 40 open-source Java projects and categorized these names into eight naming practices. We examined the occurrence and prevalence of the categories across projects, and our results also highlight in which contexts identifiers following each naming practice tend to appear more regularly. The results can be helpful to enhance programmers’ awareness and contribute to improving educational materials and code review methods.;;;https://dl.acm.org/doi/10.1145/3493244.3493258;;;Software AND Engineering
Automatically identifying parameter constraints in complex web APIs: a case study at Adyen;;;['Henk Grent', 'Aleksei Akimov', 'Maurício Aniche'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Web APIs may have constraints on parameters, such that not all parameters are either always required or always optional. Moreover, the presence or value of one parameter could cause another parameter to be required, or parameters could have restrictions on what kinds of values are valid. Having a clear overview of the constraints helps API consumers to integrate without the need for additional support and with fewer integration faults. We made use of existing documentation and code analysis approaches for identifying parameter constraints in complex web APIs. In this paper, we report our case study of several APIs at Adyen, a large-scale payment company that offers complex Web APIs to its customers. Our results show that the documentation- and code-based approach can identify 23% and 53% of the constraints respectively and, when combined, 68% of them. We also reflect on the current challenges that these approaches face. In particular, the absence of information that explicitly describes the constraints in the documentation (in the documentation analysis), and the engineering of a sound static code analyser that is sensitive to data-flow, maintains longer parameter references throughout the API's code, and that is able to symbolically execute the several libraries and frameworks used by the API (in the static analysis).;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00016;;;Software AND Engineering
How Green Finance Sparks Sustainability: Using Big Data Analysis and Visualization Software to Unite Future Economic and Social Value Potential;;;['Bai Xin', 'Zhou Wei Keng', 'Chen Zi Yao', 'Huang Zi Han', 'Lai Qing Long', 'Wang Jing Qi'];;;June 2021;;;ICIEB '21: Proceedings of the 2021 2nd International Conference on Internet and E-Business;;;The core concept of socialism with Chinese characteristics for the new era is to promote the optimization and upgrading of the economic system and the construction of sustainable ecological civilization. In the wake of the COVID-19, it has become a major issue for countries around the world to pursue green recovery. Green is a necessary condition for sustainable development, finance is the leading force of social economy, and the development of green finance is the core call of today's era. Guangdong, as the main force of the national economic lifeline, took the lead in green finance innovation and promoted the transformation and adjustment of leading industries. At present, the banking industry has repeatedly disclosed the environment, society and governance (ESG) in its social responsibility reports in order to achieve the strategic goal of carbon peak and carbon neutral, but there is a lack of systematic review on the measures and implementation. Aiming at objective problems, this paper mainly discusses how green finance stimulates sustainability and explores the value potential of the future economy and society. Based on this, this paper selected 300 literatures from the Web of Science (WOS) database, mapped the coword cluster, and analyzed their annual trend, topic scope, literature sources, etc. With the help of big data analysis technology and visualization software function, scientometrics is used to demonstrate the possibility and feasibility of the research contents in relevant fields, and to produce cutting-edge academic achievements with insight. In order to achieve the ultimate goal of green development with capital and financial design for diversified and deep thinking, to provide reference value theory for co-construction environment, data-driven investment scale and sustainable development, to accelerate the green finance reform in Guangdong Province and even the country to make a forward-looking small contribution.;;;https://dl.acm.org/doi/10.1145/3471988.3472013;;;Software AND Engineering
Does Code Complexity Affect the Quality of Real-Time Projects?: Detection of Code Smell on Software Projects using Machine Learning Algorithms;;;['Archana Patnaik', 'Neelamadhab Padhy'];;;August 2021;;;DSMLAI '21': Proceedings of the International Conference on Data Science, Machine Learning and Artificial Intelligence;;;Code smell targets to identify bugs that occur due to incorrect analysis of code during software development life cycle. It is the task of analyzing a code design problem. The primary causes of code smell are complexity in structural design, violation of programming paradigm, and lack of unit-level testing by the software programmer. Our research focuses on the identification of code smell using different machine learning classifiers. We have considered 15 software code metrics of the Junit open source project and developed a hybrid model for code smell detection. Our dataset consists of 45 features which is further reduced by 15 using various feature selection techniques. Random sampling is used to handle the imbalance in the dataset. The project's performance is evaluated using 10 machine learning techniques which including regression, ensemble methods, and classification. Based on the statistical analysis, it is analyzed that the Random forest ensemble classifiers give best result with an accuracy of 99.12 % is the most appropriate technique for detecting different types of bad smells like god class, duplicate code, long method, large class, and refused bequest.;;;https://dl.acm.org/doi/10.1145/3484824.3484911;;;Software AND Engineering
Undergraduate Research Experience with Software Development using a Large Existing Code Base in a Teaching-oriented College;;;['Wei Jin', 'David Marshall', 'Puen Xie', 'Jiawei Li', 'Matthew Stiller', 'Taisann Kham', 'Dakota Norris', 'Ikechukwu Okolocha'];;;October 2021;;;SIGITE '21: Proceedings of the 22nd Annual Conference on Information Technology Education;;;Undergraduate research has been shown to enrich education, increase retention and promote critical thinking. Research projects involving extending an already mature and relatively large code base have special value for students, as they mimic industry experience. Students have to understand the existing code structure and figure out where to add their code to extend the functionality of the system. There are obvious challenges for undergraduate students to take on such projects, including lack of knowledge at the onset of the project, limited time span (normally a semester), and limited time availability during a semester. Undergraduate institutions have additional challenges, such as high teaching load for faculty advisors and lack of graduate students who could act as mentors. In this paper, we report our experience with a relatively large project that lasted for several semesters and involved several teams of students. We managed the challenges by being flexible and carving out many mini-projects from this umbrella project, which required that the faculty advisor work closely with students. The project has successfully produced a teaching/learning tool for auto-gradable full tracing exercises. The tool has been prototyped in classrooms and helped students learn various programming constructs. We hope that our experience could encourage larger scale projects in undergraduate institutions.;;;https://dl.acm.org/doi/10.1145/3450329.3476864;;;Software AND Engineering
Towards Extraction of Message-Based Communication in Mixed-Technology Architectures for Performance Model;;;['Snigdha Singh', 'Yves Richard Kirschner', 'Anne Koziolek'];;;April 2021;;;ICPE '21: Companion of the ACM/SPEC International Conference on Performance Engineering;;;Software systems architected using multiple technologies are becoming popular. Many developers use these technologies as it offers high service quality which has often been optimized in terms of performance. In spite of the fact that performance is a key to the technology-mixed software applications, still there a little research on performance evaluation approaches explicitly considering the extraction of architecture for modelling and predicting performance. In this paper, we discuss the opportunities and challenges in applying existing architecture extraction approaches to support model-driven performance prediction for technology-mixed software. Further, we discuss how it can be extended to support a message-based system. We describe how various technologies deriving the architecture can be transformed to create the performance model. In order to realise the work, we used a case study from the energy system domain as an running example to support our arguments and observations throughout the paper.;;;https://dl.acm.org/doi/10.1145/3447545.3451201;;;Software AND Engineering
DeepLV: Suggesting Log Levels Using Ordinal Based Neural Networks;;;['Zhenhao Li', 'Heng Li', 'Tse-Hsun Peter Chen', 'Weiyi Shang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Developers write logging statements to generate logs that provide valuable runtime information for debugging and maintenance of software systems. Log level is an important component of a logging statement, which enables developers to control the information to be generated at system runtime. However, due to the complexity of software systems and their runtime behaviors, deciding a proper log level for a logging statement is a challenging task. For example, choosing a higher level (e.g., error) for a trivial event may confuse end users and increase system maintenance overhead, while choosing a lower level (e.g., trace) for a critical event may prevent the important execution information to be conveyed opportunely. In this paper, we tackle the challenge by first conducting a preliminary manual study on the characteristics of log levels. We find that the syntactic context of the logging statement and the message to be logged might be related to the decision of log levels, and log levels that are further apart in order (e.g., trace and error) tend to have more differences in their characteristics. Based on this, we then propose a deep-learning based approach that can leverage the ordinal nature of log levels to make suggestions on choosing log levels, by using the syntactic context and message features of the logging statements extracted from the source code. Through an evaluation on nine large-scale open source projects, we find that: 1) our approach outperforms the state-of-the-art baseline approaches; 2) we can further improve the performance of our approach by enlarging the training data obtained from other systems; 3) our approach also achieves promising results on cross-system suggestions that are even better than the baseline approaches on within-system suggestions. Our study highlights the potentials in suggesting log levels to help developers make informed logging decisions.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00131;;;Software AND Engineering
On the Naming of Methods: A Survey of Professional Developers;;;['Reem S. Alsuhaibani', 'Christian D. Newman', 'Michael J. Decker', 'Michael L. Collard', 'Jonathan I. Maletic'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;This paper describes the results of a large (+1100 responses) survey of professional software developers concerning standards for naming source code methods. The various standards for source code method names are derived from and supported in the software engineering literature. The goal of the survey is to determine if there is a general consensus among developers that the standards are accepted and used in practice. Additionally, the paper examines factors such as years of experience and programming language knowledge in the context of survey responses. The survey results show that participants very much agree about the importance of various standards and how they apply to names and that years of experience and the programming language has almost no effect on their responses. The results imply that the given standards are both valid and to a large degree complete. The work provides a foundation for automated method name assessment during development and code reviews.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00061;;;Software AND Engineering
A Framework for Facilitating Reproducible News Sentiment Impact Analysis;;;['Weisi Chen', 'Islam Al-Qudah', 'Fethi Rabhi'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;The proliferation of outlets for news media in recent decades has contributed to faster issuance of news data. News analysis has been one of the key activities conducted by researchers in a broad variety of research disciplines. In general, the analysis process used in these studies includes interpreting the content of the news items, and then discovering their impact in a specific area. In this paper, we delve into the field of news analysis applied to the financial domain and explore news sentiment impact analysis in the context of financial markets. Existing studies lack systematic methods to assimilate financial context and evaluate the impact of a given news dataset on relevant entities financial market performance. We introduce an improved version of the framework called News Sentiment Impact Analysis (NSIA) that encompasses models, supporting software architecture and processes for defining various financial contexts and conducting news sentiment impact analysis. The framework is then evaluated using a prototype implementation and a case study that investigates the impact of extremely negative news on the stock price of the related entities. The results demonstrate the functionality, usability and reproducibility of the framework, and its capability to bridge the gap between generating news sentiment and evaluating its impact in selected financial contexts.;;;https://dl.acm.org/doi/10.1145/3520084.3520104;;;Software AND Engineering
The Application and Evaluation of Mobile Learning of Systematic English Grammar Teaching in Social Software Weixin;;;['Xuedan Liu', 'Liemei Huang'];;;May 2021;;;ICDEL '21: Proceedings of the 2021 6th International Conference on Distance Education and Learning;;;With the development of the world, people rely on their mobile phone to get information in spite of that most of the information are fragmented. So many people can not get the whole picture. This research aims to develop a mobile learning system in English Grammar teaching as well as make an evaluation system on this learning. The research was carried in Geely University of China in Chengdu, Sichuang Province and the samples are university freshmen.;;;https://dl.acm.org/doi/10.1145/3474995.3475003;;;Software AND Engineering
A large-scale empirical study on Java library migrations: prevalence, trends, and rationales;;;['Hao He', 'Runzhi He', 'Haiqiao Gu', 'Minghui Zhou'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;With the rise of open-source software and package hosting platforms, reusing 3rd-party libraries has become a common practice. Due to various failures during software evolution, a project may remove a used library and replace it with another library, which we call library migration. Despite substantial research on dependency management, the understanding of how and why library migrations occur is still lacking. Achieving this understanding may help practitioners optimize their library selection criteria, develop automated approaches to monitor dependencies, and provide migration suggestions for their libraries or software projects. In this paper, through a fine-grained commit-level analysis of 19,652 Java GitHub projects, we extract the largest migration dataset to-date (1,194 migration rules, 3,163 migration commits). We show that 8,065 (41.04%) projects having at least one library removal, 1,564 (7.96%, lower-bound) to 5,004 (25.46%, upper-bound) projects have at least one migration, and a median project with migrations has 2 to 4 migrations in total. We discover that library migrations are dominated by several domains (logging, JSON, testing and web service) presenting a long tail distribution. Also, migrations are highly unidirectional in that libraries are either mostly abandoned or mostly chosen in our project corpus. A thematic analysis on related commit messages, issues, and pull requests identifies 14 frequently mentioned migration reasons (e.g., lack of maintenance, usability, integration, etc), 7 of which are not discussed in previous work. Our findings can be operationalized into actionable insights for package hosting platforms, project maintainers, and library developers. We provide a replication package at <a>https://doi.org/10.5281/zenodo.4816752</a>.;;;https://dl.acm.org/doi/10.1145/3468264.3468571;;;Software AND Engineering
Traceability Transformed: Generating more Accurate Links with Pre-Trained BERT Models;;;['Jinfeng Lin', 'Yalin Liu', 'Qingkai Zeng', 'Meng Jiang', 'Jane Cleland-Huang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Software traceability establishes and leverages associations between diverse development artifacts. Researchers have proposed the use of deep learning trace models to link natural language artifacts, such as requirements and issue descriptions, to source code; however, their effectiveness has been restricted by availability of labeled data and efficiency at runtime. In this study, we propose a novel framework called Trace BERT (T-BERT) to generate trace links between source code and natural language artifacts. To address data sparsity, we leverage a three-step training strategy to enable trace models to transfer knowledge from a closely related Software Engineering challenge, which has a rich dataset, to produce trace links with much higher accuracy than has previously been achieved. We then apply the T-BERT framework to recover links between issues and commits in Open Source Projects. We comparatively evaluated accuracy and efficiency of three BERT architectures. Results show that a Single-BERT architecture generated the most accurate links, while a Siamese-BERT architecture produced comparable results with significantly less execution time. Furthermore, by learning and transferring knowledge, all three models in the framework outperform classical IR trace models. On the three evaluated real-word OSS projects, the best T-BERT stably outperformed the VSM model with average improvements of 60.31% measured using Mean Average Precision (MAP). RNN severely underper-formed on these projects due to insufficient training data, while T-BERT overcame this problem by using pretrained language models and transfer learning.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00040;;;Software AND Engineering
Extracting Concise Bug-Fixing Patches from Human-Written Patches in Version Control Systems;;;['Yanjie Jiang', 'Hui Liu', 'Nan Niu', 'Lu Zhang', 'Yamin Hu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;High-quality and large-scale repositories of real bugs and their concise patches collected from real-world applications are critical for research in the software engineering community. In such a repository, each real bug is explicitly associated with its fix. Therefore, on one side, the real bugs and their fixes may inspire novel approaches for finding, locating, and repairing software bugs; on the other side, the real bugs and their fixes are indispensable for rigorous and meaningful evaluation of approaches for software testing, fault localization, and program repair. To this end, a number of such repositories, e.g., Defects4J, have been proposed. However, such repositories are rather small because their construction involves expensive human intervention. Although bug-fixing code commits as well as associated test cases could be retrieved from version control systems automatically, existing approaches could not yet automatically extract concise bug-fixing patches from bug-fixing commits because such commits often involve bug-irrelevant changes. In this paper, we propose an automatic approach, called BugBuilder, to extracting complete and concise bug-fixing patches from human-written patches in version control systems. It excludes refactorings by detecting refactorings involved in bug-fixing commits, and reapplying detected refactorings on the faulty version. It enumerates all subsets of the remaining part and validates them on test cases. If none of the subsets has the potential to be a complete bug-fixing patch, the remaining part as a whole is taken as a complete and concise bug-fixing patch. Evaluation results on 809 real bug-fixing commits in Defects4J suggest that BugBuilder successfully generated complete and concise bug-fixing patches for forty percent of the bug-fixing commits, and its precision (99%) was even higher than human experts.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00069;;;Software AND Engineering
Software and Content Design of a Browser-based Mobile 4D VR Application to Explore Historical City Architecture;;;['Sander Muenster', 'Jonas Bruschke', 'Ferdinand Maiwald', 'Constantin Kleiner'];;;October 2021;;;SUMAC'21: Proceedings of the 3rd Workshop on Structuring and Understanding of Multimedia heritAge Contents;;;The Kulturerbe4D project aims at making the diversity and change processes of architectural monuments in the urban context virtually visible and experienceable, especially for children and young people, but also for residents and tourists. A virtual city tour providing cultural and historical information is to be combined with the transfer of knowledge about monuments, anthropogenic factors of influence, and protective measures. This article focusses on three main challenges in producing city-scale mobile 4D applications: (a) 4D content creation specifically for historical purposes is highly labour intensive, (b) web applications are better accepted by users but require more adoption to cope with technical limitations, (c) historically accurate 4D content is of disperse visual quality and visualization strategies are rarely empirically proven. Within this article we present our research and development work to overcome those issues.;;;https://dl.acm.org/doi/10.1145/3475720.3484442;;;Software AND Engineering
Construction and application of knowledge graph of domestic operating system testing;;;['Dongsheng Jin', 'Zhi Wang', 'Mingyang Li', 'Xinjie Zhu'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;Aiming at the problems of poor reusability of domestic operating system test cases and insufficient sharing of test case design experience at this stage, a method for constructing knowledge graphs in the field of domestic operating system testing is proposed, and ontology construction and natural language processing technologies are applied to the field of software testing. Use the strong correlation of the knowledge graph to mine the experience knowledge in the design of historical test cases, select and reuse test cases that meet the test requirements for testers, and help them design test cases more efficiently. Through empirical research, this method gives full play to the advantages of knowledge graphs in relational network analysis and retrieval, and the coverage rate of reused test cases reaches 71%, which can greatly save test costs and improve test efficiency, and has strong engineering application value.;;;https://dl.acm.org/doi/10.1145/3494885.3494933;;;Software AND Engineering
A Real-Time Video Analysis Software Based on Deep Convolutional Neural Networks (DCNN) for Useful and Effective Endoscopy Video Storage;;;['Atuahene William Agyei', 'Libing Wu', 'Li Huang', 'Anang Emmanuella'];;;April 2021;;;IMIP '21: 2021 3rd International Conference on Intelligent Medicine and Image Processing;;;Storage of endoscopy images poses a great problem in the health sector, and to our best knowledge, the limited study focuses on the identified problem. In this study, a system developed specifically to detect lesions and automatically save them employed to reduce the size of endoscopy images and videos. 5,460 images were collected for training to detect lesions, YOLO (You Only Look Once) V3 (version 3) which is a deep convolutional neural network was introduced to detect gastritis lesions from different parts of the stomach. A deep convolutional neural network that is a powerful model used to assist in classifying endoscopy images accuracy. 114,657 images were trained on the ResNet-50 model for the distribution of image classification. The proposed method achieved a sensitivity, specificity, and accuracy of 91%, 94%, 97%. If trained further with the dataset, it could become a complementary tool for patient management. The proposed method was able to achieve an automated system that is able to retain images of detected lesions at reduced storage can be used in endoscopy centers.;;;https://dl.acm.org/doi/10.1145/3468945.3468947;;;Software AND Engineering
First-class concepts: reifying architectural knowledge beyond the dominant decomposition;;;['Toni Mattis', 'Tom Beckmann', 'Patrick Rein', 'Robert Hirschfeld'];;;July 2021;;;COP '21: Proceedings of the 13th ACM International Workshop on Context-Oriented Programming and Advanced Modularity;;;In software engineering, programs are ideally partitioned into independently maintainable and understandable modules. As a system grows, its architecture gradually loses the capability to modularly accommodate new concepts. While refactoring is expensive and the language might lack appropriate primary language constructs to express certain cross-cutting concerns, programmers are still able to explain and delineate convoluted concepts through secondary means: code comments, use of whitespace and arrangement of code, documentation, or communicating tacit knowledge.  Secondary constructs are easy to change and provide high flexibility in communicating cross-cutting concerns and other concepts among programmers. However, they have no reified representation that can be explored and maintained through tools.  In this exploratory work, we discuss novel ways to express a wide range of concepts, including cross-cutting concerns, patterns, and lifecycle artifacts independently of the dominant decomposition imposed by an existing architecture. Our concepts are first-class objects inside the programming environment that retain the capability to change as easily as code comments. We explore new tools that allow programmers to view and change programs from conceptual perspectives rather than scattering their attention across existing modules.  Our designs are geared towards facilitating multiple secondary perspectives on a system to co-exist alongside the original architecture, hence making it easier to explore, understand, and explain complex contexts and narratives not expressible in traditional modularity constructs.;;;https://dl.acm.org/doi/10.1145/3464970.3468413;;;Software AND Engineering
AI programmer: autonomously creating software programs using genetic algorithms;;;['Kory Becker', 'Justin Gottschlich'];;;July 2021;;;GECCO '21: Proceedings of the Genetic and Evolutionary Computation Conference Companion;;;In this paper, we present AI Programmer, a machine learning (ML) system that can automatically generate full software programs, while requiring only minimal human guidance. At its core, AI Programmer uses a genetic algorithm (GA), coupled with a tightly constrained programming language that minimizes the overhead of its ML search space. Part of AI Programmer's novelty stems from (i) its unique system design, including an embedded, hand-crafted interpreter for efficiency and security and (ii) its augmentation of classic GA to include instruction-gene randomization bindings and programming language-specific genome construction and elimination techniques. We provide a detailed examination of AI Programmer's system design, several examples detailing how the system works, and experimental data demonstrating its software generation capabilities and performance using only mainstream CPUs.;;;https://dl.acm.org/doi/10.1145/3449726.3463125;;;Software AND Engineering
Data Reconstruction and Optimal Design of Auto Rearview Mirror Based on RE;;;['Qian Zhou', 'Mananga Moulongo Vareine Daricka', 'Yongchao Ma', 'Mingyu Huang'];;;January 2022;;;AIEE '22: Proceedings of the 2022 3rd International Conference on Artificial Intelligence in Electronics Engineering;;;Abstract: Based on reverse engineering, this paper collects 3D data from the car rearview mirror to obtain point cloud data. The geometric data of the three-dimensional model is processed by the reverse software Geomagic. Use Solidworks software to reconstruct the obtained three-dimensional model, and perform fluid analysis, analyze the pressure, velocity distribution, flow trace, etc. of the car rearview mirror at different speeds, and optimize based on the analysis results. Finally, the solid model is processed by rapid prototyping. In the development of new products, if reverse engineering can be used reasonably, the cost of product design will be greatly shortened while saving costs.;;;https://dl.acm.org/doi/10.1145/3512826.3512835;;;Software AND Engineering
Industry–Academia Research Collaboration and Knowledge Co-creation: Patterns and Anti-patterns;;;['Dusica Marijan', 'Sagar Sen'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Increasing the impact of software engineering research in the software industry and the society at large has long been a concern of high priority for the software engineering community. The problem of two cultures, research conducted in a vacuum (disconnected from the real world), or misaligned time horizons are just some of the many complex challenges standing in the way of successful industry–academia collaborations. This article reports on the experience of research collaboration and knowledge co-creation between industry and academia in software engineering as a way to bridge the research–practice collaboration gap. Our experience spans 14 years of collaboration between researchers in software engineering and the European and Norwegian software and IT industry. Using the participant observation and interview methods, we have collected and afterwards analyzed an extensive record of qualitative data. Drawing upon the findings made and the experience gained, we provide a set of 14 patterns and 14 anti-patterns for industry–academia collaborations, aimed to support other researchers and practitioners in establishing and running research collaboration projects in software engineering.;;;https://dl.acm.org/doi/10.1145/3494519;;;Software AND Engineering
Using Domain-specific Corpora for Improved Handling of Ambiguity in Requirements;;;['Saad Ezzini', 'Sallam Abualhaija', 'Chetan Arora', 'Mehrdad Sabetzadeh', 'Lionel C. Briand'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Ambiguity in natural-language requirements is a pervasive issue that has been studied by the requirements engineering community for more than two decades. A fully manual approach for addressing ambiguity in requirements is tedious and time-consuming, and may further overlook unacknowledged ambiguity - the situation where different stakeholders perceive a requirement as unambiguous but, in reality, interpret the requirement differently. In this paper, we propose an automated approach that uses natural language processing for handling ambiguity in requirements. Our approach is based on the automatic generation of a domain-specific corpus from Wikipedia. Integrating domain knowledge, as we show in our evaluation, leads to a significant positive improvement in the accuracy of ambiguity detection and interpretation. We scope our work to coordination ambiguity (CA) and prepositional-phrase attachment ambiguity (PAA) because of the prevalence of these types of ambiguity in natural-language requirements [1]. We evaluate our approach on 20 industrial requirements documents. These documents collectively contain more than 5000 requirements from seven distinct application domains. Over this dataset, our approach detects CA and PAA with an average precision of ã80% and an average recall of ã89% (ã90% for cases of unacknowledged ambiguity). The automatic interpretations that our approach yields have an average accuracy of ã85%. Compared to baselines that use generic corpora, our approach, which uses domain-specific corpora, has ã33% better accuracy in ambiguity detection and ã16% better accuracy in interpretation.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00133;;;Software AND Engineering
Specifying with Interface and Trait Abstractions in Abstract State Machines: A Controlled Experiment;;;['Philipp Paulweber', 'Georg Simhandl', 'Uwe Zdun'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Abstract State Machine (ASM) theory is a well-known state-based formal method. As in other state-based formal methods, the proposed specification languages for ASMs still lack easy-to-comprehend abstractions to express structural and behavioral aspects of specifications. Our goal is to investigate object-oriented abstractions such as interfaces and traits for ASM-based specification languages. We report on a controlled experiment with 98 participants to study the specification efficiency and effectiveness in which participants needed to comprehend an informal specification as problem (stimulus) in form of a textual description and express a corresponding solution in form of a textual ASM specification using either interface or trait syntax extensions. The study was carried out with a completely randomized design and one alternative (interface or trait) per experimental group. The results indicate that specification effectiveness of the traits experiment group shows a better performance compared to the interfaces experiment group, but specification efficiency shows no statistically significant differences. To the best of our knowledge, this is the first empirical study studying the specification effectiveness and efficiency of object-oriented abstractions in the context of formal methods.;;;https://dl.acm.org/doi/10.1145/3450968;;;Software AND Engineering
Characterizing and Predicting Good First Issues;;;['Yuekai Huang', 'Junjie Wang', 'Song Wang', 'Zhe Liu', 'Dandan Wang', 'Qing Wang'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background. Where to start contributing to a project is a critical challenge for newcomers of open source projects. To support newcomers, GitHub utilizes the Good First Issue (GFI) label, with which project members can manually tag issues in an open source project that are suitable for the newcomers. However, manually labeling GFIs is time- and effort-consuming given the large number of candidate issues. In addition, project members need to have a close understanding of the project to label GFIs accurately. Aims. This paper aims at providing a thorough understanding of the characteristics of GFIs and an automatic approach in GFIs prediction, to reduce the burden of project members and help newcomers easily onboard. Method. We first define 79 features to characterize the GFIs and further analyze the correlation between each feature and GFIs. We then build machine learning models to predict GFIs with the proposed features. Results. Experiments are conducted with 74,780 issues from 10 open source projects from GitHub. Results show that features related to the semantics, readability, and text richness of issues can be used to effectively characterize GFIs. Our prediction model achieves a median AUC of 0.88. Results from our user study further prove its potential practical value. Conclusions. This paper provides new insights and practical guidelines to facilitate the understanding of GFIs and the automation of GFIs labeling.;;;https://dl.acm.org/doi/10.1145/3475716.3475789;;;Software AND Engineering
A Quasi-Experiment to Investigating the Impact of the Strategy Design Pattern on Maintainability;;;['Gabriel Silva', 'Vinícius Andrade', 'Reginaldo Ré', 'Rafael Meneses'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;GoF Design Patterns (DPs) are optimal solutions for several recurring problems in software development. As maintenance accounts for a massive amount of development costs, understanding the impact of DPs on maintainability is key to decide whether their benefits outweigh their costs. To test the hypothesis that the Strategy DP impacts maintainability, we carried out a quasi-experiment with 19 final-year undergraduate students. Participants performed enhancement tasks in two identical versions of Java classes that differed only in that a version implemented the Strategy DP whereas another version did not. As recommended in the literature, we used effectiveness as a representative proxy of maintainability and correctness as a measure of effectiveness. We found a statistically significant correctness change between treatments. Moreover, the effect size shows that a participant is 47.7 percentage points more likely to succeed when the Strategy DP is not used. Conversely, a participant is 5.5 times more likely to fail when the DP is introduced. Unlike most related studies, our findings suggest that the Strategy DP may reduce software maintainability although these findings need to be confirmed by independent and extended replications.;;;https://dl.acm.org/doi/10.1145/3474624.3474636;;;Software AND Engineering
Towards Higher-Level Abstractions for Quantum Computing;;;['Adrian Cobb', 'Jean-Guy Schneider', 'Kevin Lee'];;;February 2022;;;ACSW '22: Proceedings of the 2022 Australasian Computer Science Week;;;Quantum Computing (QC) has emerged as a field of ever-increasing activity as it promises to revolutionize computation and enable the solution of computational problems that we (realistically) cannot solve with Classical Computing to date. However, existing quantum programming environments mostly require an in-depth understanding of the basic QC building blocks, that is, quantum states, superposition, entanglement and measurement as well as the changing of quantum states using basic quantum gates. The present state of quantum programming reminds us of how Classical Computing was about 70 years ago when computing machines such as the ENIAC required significant effort to program solely using very basic digital building blocks. Over the decades, though, increasingly higher-level abstractions have been created on top of the basic building blocks of Classical Computing and made computation much more accessible and wide-spread. In order to make Quantum Computing more accessible, we argue that Software Engineering for QC needs to embark on a similar journey and create abstractions that shield developers from the basic QC building blocks as much as possible so that they can focus their attention on solving problems and less on how to manipulate quantum states using quantum circuits. Based on our experience of developing a scalable quantum n-queens solver, this paper aims to formulate recommendations for raising the level of abstraction in Quantum Software Engineering.;;;https://dl.acm.org/doi/10.1145/3511616.3513106;;;Software AND Engineering
Genetic optimisation of C++ applications;;;['Rafail Giavrimis', 'Alexis Butler', 'Constantin Cezar Petrescu', 'Michail Basios', 'Santanu Kumar Dash'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Software developers sometimes use inefficient data structures or library interfaces without considering the potential impact they may have during the runtime of a program. This is due to the significant effort required to research and evaluate possibly more efficient alternatives. Consequently, there is a need for tooling to automate the design space exploration. Our proposed code optimisation solution, called Artemis++, tries to address this issue with automatic exploration and transformation of data structures to optimise software performance. In preliminary testing on three mainstream C++ libraries, we have observed improvements up to 16.09%, 27.90%, and 2.74% for CPU usage, runtime and memory, respectively.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678650;;;Software AND Engineering
Grading 600+ students: a case study on peer and self grading;;;['Maurício Aniche', 'Frank Mulder', 'Felienne Hermans'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Grading large classes has become a challenging and expensive task for many universities. The Delft University of Technology (TU Delft), located in the Netherlands, has observed a large increase in student numbers over the past few years. Given the large growth of the student population, grading all the submissions results in high costs. We made use of self and peer grading in the 2018--2019 edition of our software testing course. Students worked in teams of two, and self and peer graded three assignments in our course. We ended up with 906 self and peer graded submissions, which we compared to 248 submissions that were graded by our TAs. In this paper, we report on the differences we observed between self, peer, and TA grading. Our findings show that: (i) self grades tend to be 8--10% higher than peer grades on average, (ii) peer grades seem to be a good approximator of TA grades; in cases where self and peer grade differ significantly, the TA grade seems to lie in between, and (iii) the gender and the nationality of the student do not seem to affect self and peer grading.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00031;;;Software AND Engineering
An Empirical Study on Deployment Faults of Deep Learning Based Mobile Applications;;;['Zhenpeng Chen', 'Huihan Yao', 'Yiling Lou', 'Yanbin Cao', 'Yuanqiang Liu', 'Haoyu Wang', 'Xuanzhe Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Deep learning (DL) is moving its step into a growing number of mobile software applications. These software applications, named as DL based mobile applications (abbreviated as mobile DL apps) integrate DL models trained using large-scale data with DL programs. A DL program encodes the structure of a desirable DL model and the process by which the model is trained using training data. Due to the increasing dependency of current mobile apps on DL, software engineering (SE) for mobile DL apps has become important. However, existing efforts in SE research community mainly focus on the development of DL models and extensively analyze faults in DL programs. In contrast, faults related to the deployment of DL models on mobile devices (named as deployment faults of mobile DL apps) have not been well studied. Since mobile DL apps have been used by billions of end users daily for various purposes including for safety-critical scenarios, characterizing their deployment faults is of enormous importance. To fill in the knowledge gap, this paper presents the first comprehensive study to date on the deployment faults of mobile DL apps. We identify 304 real deployment faults from Stack Overflow and GitHub, two commonly used data sources for studying software faults. Based on the identified faults, we construct a fine-granularity taxonomy consisting of 23 categories regarding to fault symptoms and distill common fix strategies for different fault symptoms. Furthermore, we suggest actionable implications and research avenues that can potentially facilitate the deployment of DL models on mobile devices.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00068;;;Software AND Engineering
Modelling IoT Application Requirements for Benchmarking IoT Middleware Platforms;;;['Shalmoly Mondal', 'Alireza Hassani', 'Prem Prakash Jayaraman', 'Pari Delir Haghighi', 'Dimitrios Georgakopoulos'];;;November 2021;;;iiWAS2021: The 23rd International Conference on Information Integration and Web Intelligence;;;The significant advances in the Internet of Things (IoT) have led to IoT applications being widely used in various scenarios ranging from smart city, smart farming, to Industrial IoT (IIoT) solutions. With the explosion of IoT application development, IoT middleware platforms are increasingly being used for hosting such IoT applications. This has given rise to the need for developing benchmarking solutions to analyze and test the performance of different middleware platforms that host these IoT applications. To develop such benchmarks, there are a number of key components that are needed. One of these components is an IoT dataset. To generate such datasets, representing IoT application requirements in a general and formal way is important. In this paper, we propose a framework to model the IoT Applications Requirements and enable Data Generation(ARDG-IoT). The framework supports a formal way to capture IoT application requirements and use these requirements to generate IoT data that can be used to create benchmarks for different IoT middleware platforms. ARDG-IoT consists of our proposed model, IoTSySML, which captures the application requirements, and an IoT data simulator tool, which is used to generate IoT data. We present an evaluation of the framework using a real world Industrial IoT application case study.;;;https://dl.acm.org/doi/10.1145/3487664.3487742;;;Software AND Engineering
Video Analytics Architecture with Metadata Event-Engine for Urban Safe Cities;;;['David Eneko Ruiz de Gauna', 'Eider Irigoyen', 'Inaki Cejudo', 'Harbil Arregui', 'Peter Leskovsky', 'Oihana Otaegui'];;;July 2021;;;ICCTA '21: Proceedings of the 2021 7th International Conference on Computer Technology Applications;;;Intelligent video analysis from sources such as urban surveillance cameras is a prolific research area today. Multiple types of computer architectures offer a wide range of possibilities when addressing the needs of computer vision technologies. When it comes to real time processing for high level and complex event detections, however, some limitations may arise, such as the computing power in the edge or the cost of sending real time video to the cloud for running advanced algorithms. In this paper, we present a functional architecture of a complete video surveillance solution and we focus on the metadata-processing event engine which takes care of the high-level video processing that is decoupled from a low-level video analysis. The low-level video analysis running in the edge generates and publishes a flow of JSON messages structure containing the details of bounding boxes detected in each frame into an asynchronous messaging service. The metadata event engine is running in a remote cloud, far from the camera locations. We present the performance evaluation of this event engine under different circumstances simulating data coming simultaneously from multiple cameras, in order to study the best strategies when deploying and partitioning distributed processing tasks.;;;https://dl.acm.org/doi/10.1145/3477911.3477919;;;Software AND Engineering
Revisiting the design of LSM-tree Based OLTP storage engine with persistent memory;;;['Baoyue Yan', 'Xuntao Cheng', 'Bo Jiang', 'Shibin Chen', 'Canfang Shang', 'Jianying Wang', 'Gui Huang', 'Xinjun Yang', 'Wei Cao', 'Feifei Li'];;;None;;;Proceedings of the VLDB Endowment;;;The recent byte-addressable and large-capacity commercialized persistent memory (PM) is promising to drive database as a service (DBaaS) into unchartered territories. This paper investigates how to leverage PMs to revisit the conventional LSM-tree based OLTP storage engines designed for DRAM-SSD hierarchy for DBaaS instances. Specifically we (1) propose a light-weight PM allocator named Hal-loc customized for LSM-tree, (2) build a high-performance Semi-persistent Memtable utilizing the persistent in-memory writes of PM, (3) design a concurrent commit algorithm named Reorder Ring to aschieve log-free transaction processing for OLTP workloads and (4) present a Global Index as the new globally sorted persistent level with non-blocking in-memory compaction. The design of Reorder Ring and Semi-persistent Memtable achieves fast writes without synchronized logging overheads and achieves near instant recovery time. Moreover, the design of Semi-persistent Memtable and Global Index with in-memory compaction enables the byte-addressable persistent levels in PM, which significantly reduces the read and write amplification as well as the background compaction overheads. The overall evaluation shows that the performance of our proposal over PM-SSD hierarchy outperforms the baseline by up to 3.8x in YCSB benchmark and by 2x in TPC-C benchmark.;;;https://dl.acm.org/doi/10.14778/3467861.3467875;;;Software AND Engineering
The Capabilities and Future Use of Facial Recognition Software on the Raspberry Pi – Exploratory System for Adolescent Mental Health Screening;;;['Alicia Kim'];;;May 2021;;;ICMHI '21: Proceedings of the 5th International Conference on Medical and Health Informatics;;;This research project was conducted with the goal of creating an automatic facial detection and recognition system to be used in various areas, such as healthcare and security. By using the Raspberry Pi device and the OpenVINO toolkit, a facial recognition virtual environment was created, and programs such as the Human Pose Estimation Model and the Interactive Face Detection Demo were tested. Originally, the plan to test the Raspberry Pi and its capabilities was to collect images of initial random subjects for the device to learn, and have the subjects stand in front of the device to see if the connected camera could correctly identify them. However, due to the COVID-19 pandemic, there was an extremely limited number of subjects available. Therefore, images of the members of the 13-member K-Pop group Seventeen were used, as there is a wide variety of content accessible through Twitter, Instagram, and YouTube. Furthermore, members go through a large number of changes in hair color and hairstyle, and therefore a variety of images could be used to fully test the accuracy of the device. In order to test the Raspberry Pi, 6-8 different images of each member were shown to the device camera to be identified. Of these images, 4-5 had been entered into the device's image database, while 2-3 were unfamiliar. Of the 100 total pictures, 77 (77%) were recognized as having an identifiable face, while 23 (23%) had faces not recognized by the Raspberry Pi. Of the 77 images that the Raspberry Pi recognized to have a face, 24 (31.17%) were identified correctly, 52 (67.53%) were identified incorrectly, and 1 (1.3%) was identified as unknown. Though the device was largely inaccurate, it was determined that modifications involving the sensitivity in which the camera measures and detects facial features will improve the accuracy of the device. Through the experimentation process, the idea for utilizing the technology to detect symptoms of stress and anxiety in teenagers was created, and a method for integrating the device into the daily lives of people as a self-care reminder system was formed.;;;https://dl.acm.org/doi/10.1145/3472813.3473183;;;Software AND Engineering
Writing P4 compiler backend for packet processing engines;;;['Balachandher Sambasivam', 'Maheswari Subramanian', 'Deb Chatterjee', 'Mallikarjuna Gouda', 'Sosutha Sethuramapandian', 'Yogender Singh Saroha'];;;December 2021;;;ANCS '21: Proceedings of the Symposium on Architectures for Networking and Communications Systems;;;The advent of P4 as a protocol-independent and platform-independent network packet processing language has revolutionized the way networks are designed and the way networking devices are programmed. There are few programmable devices, whether ASICs or FPGA-based devices, that are designed with P4 programmability as the end goal right from the beginning. As a consequence, although these packet processing engines are programmable, writing a P4 compiler for these targets requires overcoming some technical challenges. Our team has worked on a variety of packet processing pipelines in recent years, in this article, we are presenting some of these challenges as well as the solutions we found to work around them.;;;https://dl.acm.org/doi/10.1145/3493425.3502769;;;Software AND Engineering
DeepWukong: Statically Detecting Software Vulnerabilities Using Deep Graph Neural Network;;;['Xiao Cheng', 'Haoyu Wang', 'Jiayi Hua', 'Guoai Xu', 'Yulei Sui'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Static bug detection has shown its effectiveness in detecting well-defined memory errors, e.g., memory leaks, buffer overflows, and null dereference. However, modern software systems have a wide variety of vulnerabilities. These vulnerabilities are extremely complicated with sophisticated programming logic, and these bugs are often caused by different bad programming practices, challenging existing bug detection solutions. It is hard and labor-intensive to develop precise and efficient static analysis solutions for different types of vulnerabilities, particularly for those that may not have a clear specification as the traditional well-defined vulnerabilities.This article presents DeepWukong, a new deep-learning-based embedding approach to static detection of software vulnerabilities for C/C++ programs. Our approach makes a new attempt by leveraging advanced recent graph neural networks to embed code fragments in a compact and low-dimensional representation, producing a new code representation that preserves high-level programming logic (in the form of control- and data-flows) together with the natural language information of a program. Our evaluation studies the top 10 most common C/C++ vulnerabilities during the past 3 years. We have conducted our experiments using 105,428 real-world programs by comparing our approach with four well-known traditional static vulnerability detectors and three state-of-the-art deep-learning-based approaches. The experimental results demonstrate the effectiveness of our research and have shed light on the promising direction of combining program analysis with deep learning techniques to address the general static code analysis challenges.;;;https://dl.acm.org/doi/10.1145/3436877;;;Software AND Engineering
Industry-Academia Research Collaborations During and After COVID-19;;;['Dusica Marijan', 'Chetan Bansal', 'Tamara Lopez'];;;October 2021;;;ACM SIGSOFT Software Engineering Notes;;;There exists a long-standing challenge of building successful research collaborations between industry and academia in software engineering. There are multiple reasons contributing to this issue, including different timelines, impact metrics, expectations, and perceptions of researchers and practitioners, altogether leading to the issue known as the industryacademia collaboration gap. After the onset of the COVID-19 pandemic, most researchers and practitioners were sent to work from home, relying on virtual collaboration with their peers, which might have given rise to an even wider industry-academia collaboration gap. At the 8th International Workshop on Software Engineering Research and Industrial Practice, held virtually at the International Conference on Software Engineering 2021, we investigate the impact that working from home has had on research collaborations between industry and academia. We also take a look at how remote work may change research collaborations in the future. In this report, we present takeaways from keynote talks on this matter, share insights from the panel of six experts on the topic of industry-academia collaborations, and finally summarize findings from related paper presentations.;;;https://dl.acm.org/doi/10.1145/3485952.3485957;;;Software AND Engineering
Effect on brain activity while programming with (without) music;;;['Ananga Thapaliya'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;In this study, I investigate the effect of programming with (without) music on electromagnetic waves in software developers' brain and analyzing how music influences the overall result of their tasks. For this research, I used an EEG device to measure the brain activity of the programmer and analyzed electromagnetic waves by calculating the arousal-valence coefficients & using pre-processing techniques (EEG studio). The experiment was performed with 8 students who were also software developers (5 undergraduates and 3 graduates). As a result, when programming with music, I discovered that the mean valence was greater while the mean arousal was lower. These early results suggest the feasibility of the technique.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00044;;;Software AND Engineering
A Decision Support System for Managing Technical Debt: Towards a Systemic Perspective;;;['Eduardo Franco', 'Kechi Hirama', 'Stefano Armenia', 'Tatyana Skripnikova', 'Sebastian Betzin'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Maintaining a software system in operation requires resources to keep it reasonably bug-free, appropriate for the business needs, and still changeable. However, it is challenging to evaluate resource allocation strategies while considering both current and future needs. This paper presents a decision support system, using technical debt concepts, built based on the system dynamics approach that aims to assist decision-makers in evaluating different maintenance investment strategies. The tool can help evaluate future impacts by simulating possible scenarios, generating knowledge and insights for decision-makers, and helping to communicate them among different stakeholders.;;;https://dl.acm.org/doi/10.1145/3474624.3477062;;;Software AND Engineering
Automatic Unit Test Generation for Machine Learning Libraries: How Far Are We?;;;['Song Wang', 'Nishtha Shrestha', 'Abarna Kucheri Subburaman', 'Junjie Wang', 'Moshi Wei', 'Nachiappan Nagappan'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Automatic unit test generation that explores the input space and produces effective test cases for given programs have been studied for decades. Many unit test generation tools that can help generate unit test cases with high structural coverage over a program have been examined. However, the fact that existing test generation tools are mainly evaluated on general software programs calls into question about its practical effectiveness and usefulness for machine learning libraries, which are statistically-orientated and have fundamentally different nature and construction from general software projects. In this paper, we set out to investigate the effectiveness of existing unit test generation techniques on machine learning libraries. To investigate this issue, we conducted an empirical study on five widely-used machine learning libraries with two popular unit test case generation tools, i.e., EVOSUITE and Randoop. We find that (1) most of the machine learning libraries do not maintain a high-quality unit test suite regarding commonly applied quality metrics such as code coverage (on average is 34.1%) and mutation score (on average is 21.3%), (2) unit test case generation tools, i.e., EVOSUITE and Randoop, lead to clear improvements in code coverage and mutation score, however, the improvement is limited, and (3) there exist common patterns in the uncovered code across the five machine learning libraries that can be used to improve unit test case generation tasks.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00138;;;Software AND Engineering
Visual Analysis of Emotions Using AI Image-Processing Software: Possible Male/Female Differences between the Emotion Pairs “Neutral”–“Fear” and “Pleasure”–“Pain”;;;['Hermann Prossinger', 'Tomas Hladky', 'Jakub Binter', 'Silvia Boschetti', 'Daniel Riha'];;;June 2021;;;PETRA '21: Proceedings of the 14th PErvasive Technologies Related to Assistive Environments Conference;;;Inferring the emotional state of an individual by viewing his/her facial expression seems to be present in all human cultures. Numerous studies have shown that various changes in facial muscles determine the resulting facial expression. The analysis of images of faces expressing emotional states promises to contribute to quantification of the claimed observations. Here, we use a suite of AI (artificial intelligence) algorithms, along with ML (maximum likelihood) estimated distributions to quantify the shift in facial expression from “neutral”→“fear” and “pain”→“pleasure”. The images are single frames of five emotional states (neutral, fear, pain, pleasure, laugh) expressed by actors and actresses in BDSM videos. We extract a feature vector for each image, dimension-reduce these feature vectors by mapping them onto a two-dimensional manifold and calculate the norms of the normalized displacement vectors for each emotional pair. We then find that the ML distributions of the norms are Gamma-distributed and that the modes for each pair are different for both males and females. We use Wilks lambda to determine significance. We find that the distributions for the females are significantly different, but not for the males. The methodology we present here has widespread applications: monitoring the emotional states of humans in various settings; among these: determining whether participants in BDSM and similar videos are indeed volunteering their participation or are victims of criminal activity.;;;https://dl.acm.org/doi/10.1145/3453892.3461656;;;Software AND Engineering
Automated conformance testing for JavaScript engines via deep compiler fuzzing;;;['Guixin Ye', 'Zhanyong Tang', 'Shin Hwei Tan', 'Songfang Huang', 'Dingyi Fang', 'Xiaoyang Sun', 'Lizhong Bian', 'Haibo Wang', 'Zheng Wang'];;;June 2021;;;PLDI 2021: Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation;;;JavaScript (JS) is a popular, platform-independent programming language. To ensure the interoperability of JS programs across different platforms, the implementation of a JS engine should conform to the ECMAScript standard. However, doing so is challenging as there are many subtle definitions of API behaviors, and the definitions keep evolving.   We present COMFORT, a new compiler fuzzing framework for detecting JS engine bugs and behaviors that deviate from the ECMAScript standard. COMFORT leverages the recent advance in deep learning-based language models to automatically generate JS test code. As a departure from prior fuzzers, COMFORT utilizes the well-structured ECMAScript specifications to automatically generate test data along with the test programs to expose bugs that could be overlooked by the developers or manually written test cases. COMFORT then applies differential testing methodologies on the generated test cases to expose standard conformance bugs. We apply COMFORT to ten mainstream JS engines. In 200 hours of automated concurrent testing runs, we discover bugs in all tested JS engines. We had identified 158 unique JS engine bugs, of which 129 have been verified, and 115 have already been fixed by the developers. Furthermore, 21 of the COMFORT-generated test cases have been added to Test262, the official ECMAScript conformance test suite.;;;https://dl.acm.org/doi/10.1145/3453483.3454054;;;Software AND Engineering
Teaching the Scrum master role using professional Agile coaches and communities of practice;;;['Maria Paasivaara'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;As Scrum seems to be the most popular Agile method at the moment, most universities teaching software development teach it. A Scrum Team consists of a Scrum Master, a Product Owner, and developers. The Scrum Master role is vital in the team. However, looking at the industry, companies have difficulties both in hiring good Scrum Masters and convincing their developers or other personnel to take that role. Agile trainers do offer short Scrum Master training courses. However, we lacking information on how to train Scrum Masters in university education. In this paper, we report how we arranged a one-semester long Scrum Master training course. During the course, students worked as team Scrum Masters under the guidance of professional agile coaches and collaborated in a Scrum Master Community of Practice. We collected data by performing 13 post-course semi-structured interviews with Scrum Masters and by analyzing the learning diaries of 37 students from three course instances. Team-specific Agile coaches supported their Scrum Master first by example, then by observing the Scrum Masters in action and providing feedback and ideas, and finally by helping students to reflect. Students found the coaches extremely useful and wished they had utilized their coach more. Scrum Master community of practice worked best when students self-organized, shared practices and tools and provided peer support when facing problems. Finally, students with a non-technical background, as well as female students performed better as Scrum Masters than computer science and male students.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00012;;;Software AND Engineering
The Role of Formalism in System Requirements;;;['Jean-Michel Bruel', 'Sophie Ebersold', 'Florian Galinier', 'Manuel Mazzara', 'Alexandr Naumchev', 'Bertrand Meyer'];;;None;;;ACM Computing Surveys;;;A major determinant of the quality of software systems is the quality of their requirements, which should be both understandable and precise. Most requirements are written in natural language, which is good for understandability but lacks precision.To make requirements precise, researchers have for years advocated the use of mathematics-based notations and methods, known as “formal.” Many exist, differing in their style, scope, and applicability. The present survey discusses some of the main formal approaches and compares them to informal methods.The analysis uses a set of nine complementary criteria, such as level of abstraction, tool availability, and traceability support. It classifies the approaches into five categories based on their principal style for specifying requirements: natural-language, semi-formal, automata/graphs, mathematical, and seamless (programming-language-based). It includes examples from all of these categories, altogether 21 different approaches, including for example SysML, Relax, Eiffel, Event-B, and Alloy.The review discusses a number of open questions, including seamlessness, the role of tools and education, and how to make industrial applications benefit more from the contributions of formal approaches.;;;https://dl.acm.org/doi/10.1145/3448975;;;Software AND Engineering
GrumPy: an automated approach to simplify issue data analysis for newcomers;;;['Joselito Mota Jr.', 'Railana Santana', 'Ivan Machado'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The development model of open-source projects involves intensive developers’ collaborations to develop new features and maintain existing ones. Repositories hosting the projects may offer communication facilities to make partnerships happen in practice systematically. Issue reporting is one of the most employed strategies, as it carries valuable information about the software behavior or the repository itself. Indeed, issues have become the focus of several recent investigations, leading to an increased demand for automated approaches to support issue mining and analysis. The literature has brought a set of solutions for automating issue mining and analysis. However, they do not often provide developers with a user-friendly interface or an easy way to mine, manage or visualize issues’ data. Therefore, this paper introduces GrumPy, an open-source environment aimed to provide an automated approach to mine, manage, and visualize statistics about reported issues from open-source repositories. It provides a manageable multi-miner, a module to handle or visualize issues’ components, and a dashboard module responsible for showing repository data graphically. Our tool goal is to facilitate issues research work and its components.;;;https://dl.acm.org/doi/10.1145/3474624.3476012;;;Software AND Engineering
DeepMetis: augmenting a deep learning test set to increase its mutation score;;;['Vincenzo Riccio', 'Nargiz Humbatova', 'Gunel Jahangirova', 'Paolo Tonella'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Deep Learning (DL) components are routinely integrated into software systems that need to perform complex tasks such as image or natural language processing. The adequacy of the test data used to test such systems can be assessed by their ability to expose artificially injected faults (mutations) that simulate real DL faults. In this paper, we describe an approach to automatically generate new test inputs that can be used to augment the existing test set so that its capability to detect DL mutations increases. Our tool DEEPMETIS implements a search based input generation strategy. To account for the non-determinism of the training and the mutation processes, our fitness function involves multiple instances of the DL model under test. Experimental results show that DEEPMETIS is effective at augmenting the given test set, increasing its capability to detect mutants by 63% on average. A leave-one-out experiment shows that the augmented test set is capable of exposing unseen mutants, which simulate the occurrence of yet undetected faults.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678764;;;Software AND Engineering
Learning to boost the efficiency of modern code review;;;['Robert Heumüller'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Modern Code Review (MCR) is a standard in all kinds of organizations that develop software. MCR pays for itself through perceived and proven benefits in quality assurance and knowledge transfer. However, the time invest in MCR is generally substantial. The goal of this thesis is to boost the efficiency of MCR by developing AI techniques that can partially replace or assist human reviewers. The envisioned techniques distinguish from existing MCR-related AI models in that we interpret these challenges as graph-learning problems. This should allow us to use state-of-science algorithms from that domain to learn coding and reviewing standards directly from existing projects. The required training data will be mined from online repositories and the experiments will be designed to use standard, quantitative evaluation metrics. This research proposal defines the motivation, research-questions, and solution components for the thesis, and gives an overview of the relevant related work.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00126;;;Software AND Engineering
Intelligent change operators for multi-objective refactoring;;;['Chaima Abid', 'James Ivers', 'Thiago do N. Ferreira', 'Marouane Kessentini', 'Fares E. Kahla', 'Ipek Ozkaya'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;In this paper, we propose intelligent change operators and integrate them into an evolutionary multi-objective search algorithm to recommend valid refactorings that address conflicting quality objectives such as understandability and effectiveness. The proposed intelligent crossover and mutation operators incorporate refactoring dependencies to avoid creating invalid refactorings or invalidating existing refactorings. Further, the intelligent crossover operator is augmented to create offspring that improve solution quality by exchanging blocks of valid refactorings that improve a solution's weakest objectives. We used our intelligent change operators to generate refactoring recommendations for four widely used open-source projects. The results show that our intelligent change operators improve the diversity of solutions. Diversity is important in genetic algorithms because crossing over a homogeneous population does not yield new solutions. Given the inherent nature of design trade-offs in software, giving developers choices that reflect these trade-offs is important. Higher diversity makes better use of developers time than lots of incredibly similar solutions. Our intelligent change operators also accelerate solution convergence to a feasible solution that optimizes the trade-off between the conflicting quality objectives. Finally, they reduce the number of invalid refactorings by up to 71.52% compared to existing search-based refactoring approaches, and increase the quality of the solutions. Our approach outperformed the state-of-the-art search-based refactoring approaches and an existing deterministic refactoring tool based on manual validation by developers with an average manual correctness, precision and recall of 0.89, 0.82, and 0.87.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678519;;;Software AND Engineering
Learning Quick Fixes from Code Repositories;;;['Reudismam Sousa', 'Gustavo Soares', 'Rohit Gheyi', 'Titus Barik', "Loris D'Antoni"];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Code analyzers such as Error Prone and FindBugs detect code patterns symptomatic of bugs, performance issues, or bad style. These tools express patterns as quick fixes that detect and rewrite unwanted code. However, it is difficult to come up with new quick fixes and decide which ones are useful and frequently appear in real code. We propose to rely on the collective wisdom of programmers and learn quick fixes from revision histories in software repositories. We present Revisar, a tool for discovering common Java edit patterns in code repositories. Given code repositories and their revision histories, Revisar (i) identifies code edits from revisions and (ii) clusters edits into sets that can be described using an edit pattern. The designers of code analyzers can then inspect the patterns and add the corresponding quick fixes to their tools. We ran Revisar on nine popular GitHub projects, and it discovered 89 useful edit patterns that appeared in 3 or more projects. Moreover, 64% of the discovered patterns did not appear in existing tools. We then conducted a survey with 164 programmers from 124 projects and found that programmers significantly preferred eight out of the nine of the discovered patterns. Finally, we submitted 16 pull requests applying our patterns to 9 projects and, at the time of the writing, programmers accepted 7 (63.6%) of them. The results of this work aid toolsmiths in discovering quick fixes and making informed decisions about which quick fixes to prioritize based on patterns programmers actually apply in practice.;;;https://dl.acm.org/doi/10.1145/3474624.3474650;;;Software AND Engineering
SoFi: Reflection-Augmented Fuzzing for JavaScript Engines;;;['Xiaoyu He', 'Xiaofei Xie', 'Yuekang Li', 'Jianwen Sun', 'Feng Li', 'Wei Zou', 'Yang Liu', 'Lei Yu', 'Jianhua Zhou', 'Wenchang Shi', 'Wei Huo'];;;November 2021;;;CCS '21: Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security;;;JavaScript engines have been shown prone to security vulnerabilities, which can lead to serious consequences due to their popularity. Fuzzing is an effective testing technique to discover vulnerabilities. The main challenge of fuzzing JavaScript engines is to generate syntactically and semantically valid inputs such that deep functionalities can be explored. However, due to the dynamic nature of JavaScript and the special features of different engines, it is quite challenging to generate semantically meaningful test inputs. We observed that state-of-the-art semantic-aware JavaScript fuzzers usually require manually written rules to analyze the semantics for a JavaScript engine, which is labor-intensive, incomplete and engine-specific. Moreover, the error rate of generated test cases is still high. Another challenge is that existing fuzzers cannot generate new method calls that are not included in the initial seed corpus or pre-defined rules, which limits the bug-finding capability.  To this end, we propose a novel semantic-aware fuzzing technique named SoFi. To guarantee the validity of the generated test cases, SoFi adopts a fine-grained program analysis to identify available variables and infer types of these variables for the mutation. Moreover, an automatic repair strategy is proposed to repair syntax/semantic errors in invalid test cases. To improve the exploration capability of SoFi, we propose a reflection-based analysis to identify unseen attributes and methods of objects, which are further used in the mutation. With fine-grained analysis and reflection-based augmentation, SoFi can generate more valid and diverse test cases. Besides, SoFi is general in different JavaScript engines without any manual configuration (e.g., the grammar rules). The evaluation results have shown that SoFi outperforms state-of-the-art techniques in generating semantically valid inputs, improving code coverage and detecting more bugs. SoFi discovered 51 bugs in popular JavaScript engines, 28 of which have been confirmed or fixed by the developers and 10 CVE IDs have been assigned.;;;https://dl.acm.org/doi/10.1145/3460120.3484823;;;Software AND Engineering
A Sound Dynamic Partial Order Reduction Engine for Java Pathfinder;;;['Kyle Storey', 'Eric Mercer', 'Pavel Parizek'];;;October 2019;;;ACM SIGSOFT Software Engineering Notes;;;When model checking a multi-threaded program, it is often nec- essary to enumerate the possible ordering of concurrent events to evaluate the behavior of the program. However, enumerating every possible order of events quickly leads to state-space explo- sion. Dynamic Partial Order Reduction (DPOR) is a method to dynamically determine a subset of schedules that need to be evaluated to observe all the relevant behavior of a program. A sound implementation of DPOR in Java Path nder (JPF) can be tricky without incurring unacceptable amounts of overhead, be- cause JPF does not support subdividing existing transitions and conservatively inserting choice generators to end transitions at each possible scheduling point causes JPF to save a large amount of state. We present an extension to JPF, which is an efficient implementation of DPOR that attempts to minimize spacial com- plexity. It handles the directing of the search and uses a simple interface to allow the user to de ne the set of events to operate on and to determine which of those events are dependent. It keeps its own internal representation of all possible scheduling points without inserting choice generators at each point. It then restarts portions of the search, if necessary, to insert only the needed choice generators.;;;https://dl.acm.org/doi/10.1145/3364452.3364457;;;Software AND Engineering
Evolution of a compiling query engine;;;['Thomas Neumann'];;;None;;;Proceedings of the VLDB Endowment;;;In 2011 we showed how to use dynamic code generation to process queries in a data-centric manner. This execution model can produce compact and efficient code and was successfully used by both our own systems and systems of other groups. As the systems become used in practice, additional techniques were developed for shortcomings that did arrive, including low-latency compilation, multi-threading support, and others. This paper gives an overview of the evolution of our query engine within in the last ten years, and points out which problem have to be tackled to bring a compiling system into production usage.;;;https://dl.acm.org/doi/10.14778/3476311.3476410;;;Software AND Engineering
FIDDLR: streamlining reuse with concern-specific modelling languages;;;['Maximilian Schiedermeier', 'Jörg Kienzle', 'Bettina Kemme'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;Model-Driven Engineering (MDE) reduces complexity, improves Separation of Concerns and promotes reuse by structuring software development as a process of model production and refinement. Domain-Specific Modelling Languages and Aspect-Oriented Modelling techniques can reduce complexity and improve modularization of crosscutting concerns in situations where the features of general purpose modelling languages are not well aligned with the subject of study. In this article we present FIDDLR, a novel framework that integrates the ideas of Domain-Specific Modelling Languages, Concern-Oriented Reuse and MDE to modularize concerns that cross-cut multiple levels of abstraction of the software development process and streamline the reuse process. It also prescribes the integration of the different tooling along this process. We demonstrate the effectiveness of our framework and the potential for reduced complexity and leveraged reuse by building a reusable concern that exposes the services a system offers through a REST interface.;;;https://dl.acm.org/doi/10.1145/3486608.3486913;;;Software AND Engineering
RMVRVM – A Paradigm for Creating Energy Efficient User Applications Connected to Cloud through REST API;;;['Lavneet Singh'];;;February 2022;;;ISEC 2022: 15th Innovations in Software Engineering Conference;;;The applications that run on resource-constrained devices, especially for batteries, pose a challenge. The activities such applications do while running on such devices consume energy and drain the device's battery. Many of these applications use REST API to communicate with their backend services running outside of the devices, primarily on the cloud. The paradigms like Model View View-Model (MVVM) used on the application side require data transformations that cause applications to consume more battery. There is a need for an improved approach and a paradigm that can be used to develop green software with reduced battery consumption. This paper proposes a novel Remote-Model View Remote-View-Model (RMVRVM) paradigm. The use of RMVRVM paradigm lowers the battery consumption on devices where the application is running and hence contributes to writing green software. In addition, RMVRVM makes an application more responsive and thus a delight to use. This paradigm has been implemented in industrial case studies, and significant gains in terms of the reduced amount of data transfer, reduced battery consumption, and faster response time were observed. Experiments were also done to further validate the paradigm with encouraging results. The practitioners can apply the RMVRVM to design applications for battery-constrained devices with smaller energy footprints and better response times.;;;https://dl.acm.org/doi/10.1145/3511430.3511434;;;Software AND Engineering
Creating and migrating chatbots with conga;;;['Sara Pérez-Soler', 'Esther Guerra', 'Juan de Lara'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Chatbots are agents that enable the interaction of users and software by means of written or spoken natural language conversation. Their use is growing, and many companies are starting to offer their services via chatbots, e.g., for booking, shopping or customer support. For this reason, many chatbot development tools have emerged, which makes choosing the most appropriate tool difficult. Moreover, there is hardly any support for migrating chatbots between tools. To alleviate these issues, we propose a model-driven engineering solution that includes: (i) a domain-specific language to model chatbots independently of the development tool; (ii) a recommender that suggests the most suitable development tool for the given chatbot requirements and model; (iii) code generators that synthesize the chatbot code for the selected tool; and (iv) parsers to extract chatbot models out of existing chatbot implementations. Our solution is supported by a web IDE called Conga that can be used for both chatbot creation and migration. A demo video is available at https://youtu.be/3sw1FDdZ7XY.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00030;;;Software AND Engineering
Tool-Aided Loop Invariant Development: Insights into Student Conceptions and Difficulties;;;['Megan Fowler', 'Eileen Kraemer', 'Murali Sitaraman', 'Joseph E. Hollingsworth'];;;June 2021;;;ITiCSE '21: Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1;;;To develop code that meets its specification and is verifiably correct, such as in a software engineering course, students must be able to understand formal contracts and annotate their code with assertions such as loop invariants. To assist in developing suitable instructor and automated tool interventions, this research aims to go beyond simple pre- and post-conditions and gain insight into student learning of loop invariants involving objects. As students develop suitable loop invariants for given code with the aid of an online system backed by a verification engine, each student attempt, either correct or incorrect, was collected and analyzed automatically, and catalogued using an iterative process to capture common difficulties. Students were also asked to explain their thought process in arriving at their answer for each submission. The collected explanations were analyzed manually and found to be useful to assess their level of understanding as well as to extract actionable information for instructors and automated tutoring systems. Qualitative conclusions include the impact of the medium.;;;https://dl.acm.org/doi/10.1145/3430665.3456351;;;Software AND Engineering
PCPATCH: Software for the Topological Construction of Multigrid Relaxation Methods;;;['Patrick E. Farrell', 'Matthew G. Knepley', 'Lawrence Mitchell', 'Florian Wechsung'];;;None;;;ACM Transactions on Mathematical Software;;;Effective relaxation methods are necessary for good multigrid convergence. For many equations, standard Jacobi and Gauß–Seidel are inadequate, and more sophisticated space decompositions are required; examples include problems with semidefinite terms or saddle point structure. In this article, we present a unifying software abstraction, PCPATCH, for the topological construction of space decompositions for multigrid relaxation methods. Space decompositions are specified by collecting topological entities in a mesh (such as all vertices or faces) and applying a construction rule (such as taking all degrees of freedom in the cells around each entity). The software is implemented in PETSc and facilitates the elegant expression of a wide range of schemes merely by varying solver options at runtime. In turn, this allows for the very rapid development of fast solvers for difficult problems.;;;https://dl.acm.org/doi/10.1145/3445791;;;Software AND Engineering
Open3DGen: open-source software for reconstructing textured 3D models from RGB-D images;;;['Teo T. Niemirepo', 'Marko Viitanen', 'Jarno Vanne'];;;June 2021;;;MMSys '21: Proceedings of the 12th ACM Multimedia Systems Conference;;;This paper presents the first entirely open-source and cross-platform software called Open3DGen for reconstructing photorealistic textured 3D models from RGB-D images. The proposed software pipeline consists of nine main stages: 1) RGB-D acquisition; 2) 2D feature extraction; 3) camera pose estimation; 4) point cloud generation; 5) coarse mesh reconstruction; 6) optional loop closure; 7) fine mesh reconstruction; 8) UV unwrapping; and 9) texture projection. This end-to-end scheme combines multiple state-of-the-art techniques and provides an easy-to-use software package for real-time 3D model reconstruction and offline texture mapping. The main innovation lies in various Structure-from-Motion (SfM) techniques that are used with additional depth data to yield high-quality 3D models in real-time and at low cost. The functionality of Open3DGen has been validated on AMD Ryzen 3900X CPU and Nvidia GTX1080 GPU. This proof-of-concept setup attains an average processing speed of 15 fps for 720p (1280x720) RGBD input without the offline backend. Our solution is shown to provide competitive 3D mesh quality and execution performance with the state-of-the-art commercial and academic solutions.;;;https://dl.acm.org/doi/10.1145/3458305.3463374;;;Software AND Engineering
Accuracy and Resiliency of Analog Compute-in-Memory Inference Engines;;;['Zhe Wan', 'Tianyi Wang', 'Yiming Zhou', 'Subramanian S. Iyer', 'Vwani P. Roychowdhury'];;;None;;;ACM Journal on Emerging Technologies in Computing Systems;;;Recently, analog compute-in-memory (CIM) architectures based on emerging analog non-volatile memory (NVM) technologies have been explored for deep neural networks (DNNs) to improve scalability, speed, and energy efficiency. Such architectures, however, leverage charge conservation, an operation with infinite resolution, and thus are susceptible to errors. Thus, the inherent stochasticity in any analog NVM used to execute DNNs, will compromise performance. Several reports have demonstrated the use of analog NVM for CIM in a limited scale. It is unclear whether the uncertainties in computations will prohibit large-scale DNNs. To explore this critical issue of scalability, this article first presents a simulation framework to evaluate the feasibility of large-scale DNNs based on CIM architecture and analog NVM. Simulation results show that DNNs trained for high-precision digital computing engines are not resilient against the uncertainty of the analog NVM devices. To avoid such catastrophic failures, this article introduces the analog bi-scale representation for the DNN, and the Hessian-aware Stochastic Gradient Descent training algorithm to enhance the inference accuracy of trained DNNs. As a result of such enhancements, DNNs such as Wide ResNets for CIFAR-100 image recognition problem are demonstrated to have significant performance improvements in accuracy without adding cost to the inference hardware.;;;https://dl.acm.org/doi/10.1145/3502721;;;Software AND Engineering
PROMPT - Master Courses for Professional SoftwareDevelopers;;;['Stefan Eck', 'Hans A. Hansson'];;;January 2019;;;ACM SIGSOFT Software Engineering Notes;;;PROMPT [1] is an educational initiative in cooperation with several academic parties and leading industrial companies and organizations. Together, the parties offer advanced level courses in software engineering in a web-based format, tailored to fit professional engineers and software developers who need to be able to combine full-time work and studies. The long-term goal of PROMPT is to guarantee the supply of advanced software competencies and innovativeness in industry. The courses are free of charge within Europe, cover typically 7.5 university credits and are run over a whole semester, at a pace of 25% of full-time. All courses are developed in close cooperation with the Swedish industry and trade organizations.;;;https://dl.acm.org/doi/10.1145/3310013.3310036;;;Software AND Engineering
An Algorithmic Approach for Generating Behavioral UML Models Using Natural Language Processing;;;['Esra A. Abdelnabi', 'Abdelsalam M. Maatuk', 'Tawfig M. Abdelaziz'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;The process of transformation from informal requirements stated in natural language into a formal specification such as Unified Modeling Language (UML) is an important challenge. User requirements that are expressed in natural language can be very problematic, which makes the requirements analysis a difficult task. In this paper, we propose a method to analyze the natural language requirements and generate sequence and collaboration diagrams from these requirements, which are commonly used to describe the behavior of software systems. A case study was accomplished to compare the diagrams generated by the proposed approach to the diagrams produced by other approaches. The results showed that the elements of the sequence and collaboration diagrams extracted through our approach are very satisfactory and they would be acceptable as initial analysis models.;;;https://dl.acm.org/doi/10.1145/3492547.3492612;;;Software AND Engineering
M3: end-to-end memory management in elastic system software stacks;;;['David Lion', 'Adrian Chiu', 'Ding Yuan'];;;April 2021;;;EuroSys '21: Proceedings of the Sixteenth European Conference on Computer Systems;;;This paper proposes M3, an end-to-end system that dynamically distributes memory resources among competing applications to maximize their overall performance. Today's data center workloads, can adapt to a wide range of memory sizes, and they are built on complex software stacks. M3 consists of a set of mechanisms and policies allowing the layers of the system stack to make coordinated decisions. Applications continuously adapt to current resource availability, and resources are distributed to competing applications according to their needs. Experiments show that compared to the best possible static configurations, M3 achieves up to 3.05x speed-up.;;;https://dl.acm.org/doi/10.1145/3447786.3456256;;;Software AND Engineering
Handover Experiments with UAVs: Software Radio Tools and Experimental Research Platform;;;['Keith Powell', 'Andrew Yingst', 'Talha Faizur Rahman', 'Vuk Marojevic'];;;January 2022;;;WiNTECH '21: Proceedings of the 15th ACM Workshop on Wireless Network Testbeds, Experimental evaluation &amp; CHaracterization;;;Mobility management is the key feature of cellular networks. When integrating unmanned aerial vehicles (UAVs) into cellular networks, their cell association needs to be carefully managed for coexistence with other cellular users. UAVs move in three dimensions and may traverse several cells on their flight path, and so may be subject to several handovers. In order to enable research on mobility management with UAV users, this paper describes the design, implementation, and testing methodology for handover experiments with aerial users. We leverage software-defined radios (SDRs) and implement a series of tools for preparing the experiment in the laboratory and for taking it outdoors for field testing. We use solely commercial off-the-shelf hardware, open-source software, and an experimental license to enable reproducible and scalable experiments. Our initial outdoor results with two SDR base stations connected to an open-source software core network, implementing the 4G long-term evolution protocol, and one low altitude UAV user equipment demonstrate the handover process.;;;https://dl.acm.org/doi/10.1145/3477086.3480841;;;Software AND Engineering
GraphTrans: a software system for network conversions for simulation, structural analysis, and graph operations;;;['Henry L. Carscadden', 'Lucas Machi', 'Chris J. Kuhlman', 'Dustin Machi', 'S. S. Ravi'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;Network representations of socio-physical systems are ubiquitous, examples being social (media) networks and infrastructure networks like power transmission and water systems. The many software tools that analyze and visualize networks, and carry out simulations on them, require different graph formats. Consequently, it is important to develop software for converting graphs that are represented in a given source format into a required representation in a destination format. For network-based computations, graph conversion is a key capability that facilitates interoperability among software tools. This paper describes such a system called GraphTrans to convert graphs among different formats. This system is part of a new cyberinfrastructure for network science called net.science. We present the GraphTrans system design and implementation, results from a performance evaluation, and a case study to demonstrate its utility.;;;https://dl.acm.org/doi/10.5555/3522802.3522850;;;Software AND Engineering
Reflections on: A Simpler Model of Software Readability;;;['Daryl Posnett', 'Abram Hindle', 'Premkumar Devanbu'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;At UC Davis, in late 2010, we noticed that developers frequently debated the topic of code readability and style. Practitioners often expressed strong, off-the-cuff judgments regarding the read- ability of code, but mostly disagreed on the precise attributes of readability. While developers clearly cared about the factors they believed related to readability, the concept was not well defined.;;;https://dl.acm.org/doi/10.1145/3468744.3468754;;;Software AND Engineering
Promises and Perils of Inferring Personality on GitHub;;;['Frenk C.J. van Mil', 'Ayushi Rastogi', 'Andy Zaidman'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Personality plays a pivotal role in our understanding of human actions and behavior. Today, the applications of personality are widespread, built on the solutions from psychology to infer personality. Aim: In software engineering, for instance, one widely used solution to infer personality uses textual communication data. As studies on personality in software engineering continue to grow, it is imperative to understand the performance of these solutions. Method: This paper compares the inferential ability of three widely studied text-based personality tests against each other and the ground truth on GitHub. We explore the challenges and potential solutions to improve the inferential ability of personality tests. Results: Our study shows that solutions for inferring personality are far from being perfect. Software engineering communications data can infer individual developer personality with an average error rate of 41%. In the best case, the error rate can be reduced up to 36% by following our recommendations1.;;;https://dl.acm.org/doi/10.1145/3475716.3475775;;;Software AND Engineering
Automating the synthesis of recommender systems for modelling languages;;;['Lissette Almonte', 'Sara Pérez-Soler', 'Esther Guerra', 'Iván Cantador', 'Juan de Lara'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;We are witnessing an increasing interest in building recommender systems (RSs) for all sorts of Software Engineering activities. Modelling is no exception to this trend, as modelling environments are being enriched with RSs that help building models by providing recommendations based on previous solutions to similar problems in the same domain. However, building a RS from scratch requires considerable effort and specialized knowledge. To alleviate this problem, we propose an automated approach to the generation of RSs for modelling languages. Our approach is model-based, and we provide a domain-specific language called Droid to configure every aspect of the RS (like the type and features of the recommended items, the recommendation method, and the evaluation metrics). The RS so configured can be deployed as a service, and we offer out-of-the-box integration of this service with the EMF tree editor. To assess the usefulness of our proposal, we present a case study on the integration of a generated RS with a modelling chatbot, and report on an offline experiment measuring the precision and completeness of the recommendations.;;;https://dl.acm.org/doi/10.1145/3486608.3486905;;;Software AND Engineering
Analyzing Uncertainty in Release Planning: A Method and Experiment for Fixed-Date Release Cycles;;;['Olawole Oni', 'Emmanuel Letier'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Release planning—deciding what features to implement in upcoming releases of a software system—is a critical activity in iterative software development. Many release planning methods exist, but most ignore the inevitable uncertainty in estimating software development effort and business value. The article’s objective is to study whether analyzing uncertainty during release planning generates better release plans than if uncertainty is ignored. To study this question, we have developed a novel release planning method under uncertainty, called BEARS, that models uncertainty using Bayesian probability distributions and recommends release plans that maximize expected net present value and expected punctuality. We then compare release plans recommended by BEARS to those recommended by methods that ignore uncertainty on 32 release planning problems. The experiment shows that BEARS recommends release plans with higher expected net present value and expected punctuality than methods that ignore uncertainty, thereby indicating the harmful effects of ignoring uncertainty during release planning. These results highlight the importance of eliciting and analyzing uncertainty in software effort and value estimations and call for increased research in these areas.;;;https://dl.acm.org/doi/10.1145/3490487;;;Software AND Engineering
IoT development in the wild: bug taxonomy and developer challenges;;;['Amir Makhshari', 'Ali Mesbah'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;IoT systems are rapidly adopted in various domains, from embedded systems to smart homes. Despite their growing adoption and popularity, there has been no thorough study to understand IoT development challenges from the practitioners' point of view. We provide the first systematic study of bugs and challenges that IoT developers face in practice, through a large-scale empirical investigation. We highlight frequent bug categories and their root causes, correlations between them, and common pitfalls and challenges that IoT developers face. We recommend future directions for IoT areas that require research and development attention.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00103;;;Software AND Engineering
Research on Rendering Effect and Frame Rate Analysis of Group Behavior Oriented to VR Environment;;;['Jian Du', 'Shengwei Qin', 'Gengbin Ma', 'ZiLong Wu'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;How to effectively simulate complex behaviors is a key point in VR, such as crowd escape. Based on this purpose, this paper discusses the rendering effect in a VR game "shock absorption" with group behavior. We discussed the effect of group behavior in the context of shock-absorbing escape with using GPGPU to process data, which greatly improves computational efficiency. And the processing methods in the paper can supports earthquake escape simulation with multiple NPC and player interactions well. The experimental results show that the group behavior can effectively improve the immersion of shock absorbers in the VR game, and provide a general pipeline for lots of group behavior rendered in VR environments;;;https://dl.acm.org/doi/10.1145/3494885.3494946;;;Software AND Engineering
Experience with Teaching Performance Measurement and Testing in a Course on Functional Testing;;;['Andre B. Bondi', 'Razieh Saremi'];;;April 2021;;;ICPE '21: Companion of the ACM/SPEC International Conference on Performance Engineering;;;Stevens Institute of Technology offers a graduate course on functional software testing that addresses test planning driven by use cases, the use of software tools, and the derivation of test cases to achieve coverage with minimal effort. The course also contains material on performance testing. Teaching performance testing and measurement in a university setting was challenging because giving the students access to a target system would have required more time, resources, and planning than were available. %neither the students nor the university typically have access to a system that can be tested and measured. We addressed these challenges (a) by showing the students how resource usage could be measured in a controlled way with the instrumentation that comes with most modern laptops by default, and (b) by having the students use JMeter to measure the response times of existing websites . We describe how students were introduced to the concept of a controlled performance test by playing recordings of the same musical piece with and without video. We make recommendations for the future avoidance of the emergent ethical issue that one should not subject one does not own to anything but the most trivial loads. We also describe some successes and pitfalls in this effort.;;;https://dl.acm.org/doi/10.1145/3447545.3451196;;;Software AND Engineering
The Case for Adaptive Security Interventions;;;['Irum Rauf', 'Marian Petre', 'Thein Tun', 'Tamara Lopez', 'Paul Lunn', 'Dirk Van Der Linden', 'John Towse', 'Helen Sharp', 'Mark Levine', 'Awais Rashid', 'Bashar Nuseibeh'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Despite the availability of various methods and tools to facilitate secure coding, developers continue to write code that contains common vulnerabilities. It is important to understand why technological advances do not sufficiently facilitate developers in writing secure code. To widen our understanding of developers' behaviour, we considered the complexity of the security decision space of developers using theory from cognitive and social psychology. Our interdisciplinary study reported in this article (1) draws on the psychology literature to provide conceptual underpinnings for three categories of impediments to achieving security goals, (2) reports on an in-depth meta-analysis of existing software security literature that identified a catalogue of factors that influence developers' security decisions, and (3) characterises the landscape of existing security interventions that are available to the developer during coding and identifies gaps. Collectively, these show that different forms of impediments to achieving security goals arise from different contributing factors. Interventions will be more effective where they reflect psychological factors more sensitively and marry technical sophistication, psychological frameworks, and usability. Our analysis suggests “adaptive security interventions” as a solution that responds to the changing security needs of individual developers and a present a proof-of-concept tool to substantiate our suggestion.;;;https://dl.acm.org/doi/10.1145/3471930;;;Software AND Engineering
Concurrent model synchronisation with multiple objectives;;;['Nils Weidmann', 'Gregor Engels'];;;June 2021;;;GECCO '21: Proceedings of the Genetic and Evolutionary Computation Conference;;;Concurrent model synchronisation, i.e. the (bidirectional) propagation of updates between two models, is an important problem in the area of model-driven engineering (MDE). Compared to other consistency management tasks, synchronising concurrent updates is especially challenging as they can be conflicting, such that restoring a consistent state is not possible when all updates must be considered. Recent approaches create a search space of possible solutions and determine the optimum solution via exact methods, such as integer linear programming (ILP), via a configurable, scalarised objective function that takes conflicting goals into account. However, the determination of suitable configuration parameters and runtime efficiency improvements are still an open issue, which is commonly addressed by using heuristics instead of exact methods. We investigate on whether it is beneficial to apply heuristics to solve concurrent model synchronisation problems. First, a multiobjective evolutionary algorithm is used for small instances for which all pareto-optimal solutions can be presented to a user to select the best one. Second, for larger models, we propose a method to determine suitable weightings for aggregating all objectives into a single function. Finally, these insights are used to recommend a strategy for determining solutions of satisfying quality within an acceptable amount of time.;;;https://dl.acm.org/doi/10.1145/3449639.3459283;;;Software AND Engineering
Fast recovery of correlated failures in distributed stream processing engines;;;['Li Su', 'Yongluan Zhou'];;;June 2021;;;DEBS '21: Proceedings of the 15th ACM International Conference on Distributed and Event-based Systems;;;In a large-scale cluster, correlated failures usually involve a number of nodes failing simultaneously. Although correlated failures occur infrequently, they have significant effect on systems' availability, especially for streaming applications that require real-time analysis, as repairing the failed nodes or acquiring additional ones would take a significant amount of time. Most state-of-the-art distributed stream processing systems (DSPSs) focus on recovering individual failures and do not consider the optimization for recovering correlated failure. In this work, we propose an incremental and query-centric recovery paradigm where the recovery of failed operator partitions would be carefully scheduled based on the current availability of resources, such that the outputs of queries can be recovered as early as possible. By analyzing the existing recovery techniques, we identify the challenges and propose a fault-tolerance framework that can support incremental recovery with minimum overhead during the system's normal execution. We also formulate the new problem of recovery scheduling under correlated failures and design algorithms to optimize the recovery latency with a performance guarantee. A comprehensive set of experiments are conducted to study the validity of our proposal.;;;https://dl.acm.org/doi/10.1145/3465480.3466923;;;Software AND Engineering
IoT Bugs and Development Challenges;;;['Amir Makhshari', 'Ali Mesbah'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;IoT systems are rapidly adopted in various domains, from embedded systems to smart homes. Despite their growing adoption and popularity, there has been no thorough study to understand IoT development challenges from the practitioners' point of view. We provide the first systematic study of bugs and challenges that IoT developers face in practice, through a large-scale empirical investigation. We collected 5,565 bug reports from 91 representative IoT project repositories and categorized a random sample of 323 based on the observed failures, root causes, and the locations of the faulty components. In addition, we conducted nine interviews with IoT experts to uncover more details about IoT bugs and to gain insight into IoT developers' challenges. Lastly, we surveyed 194 IoT developers to validate our findings and gain further insights. We propose the first bug taxonomy for IoT systems based on our results. We highlight frequent bug categories and their root causes, correlations between them, and common pitfalls and challenges that IoT developers face. We recommend future directions for IoT areas that require research and development attention.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00051;;;Software AND Engineering
Research on Electronic Control Emergency Support System of a Tracked Vehicle Engine Based on STM32;;;['Changhong Gong', 'Lingxiang Xia', 'Xianguo Zou'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;None;;;https://dl.acm.org/doi/10.1145/3495018.3495078;;;Software AND Engineering
Status Update on Phishing Emails Awareness: Jordanian Case;;;['Malik Qasaimeh', 'Hana Al-Manaseer', 'Haya Al-Manaseer', 'Firas Alghanim'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;Abstract—This study is a response to the rapid proliferation of high-risk phishing emails, representing one of the most dangerous cybercrimes and the primary medium for the deception of online users. This study aims to investigate the various characteristics of phishing email messages, and to measure Jordanian internet users’ awareness and knowledge about these threats. To achieve these objectives, a quantitative approach was used based on an online survey that included a total of 1531 participants. The results showed that only a few participants had the ability to distinguish illegitimate from legitimate emails, as the majority of participants could not recognize illegitimate emails by answering with “legitimate email” or “I don't know”. Similarly, only a few participants could distinguish phishing emails, with the majority being unable to recognize phishing emails by answering with “real email” or “I don't know”. Therefore, more work to increase public awareness of phishing emails is recommended at the individual and institutional levels, so as to protect users from any possible phishing email threats. This study focuses on the aspects that are related to email phishing that include techniques used to generate such phishing emails on the basis of which we will identity preventive measures to protect Jordanian users and increase their awareness of phishing emails.;;;https://dl.acm.org/doi/10.1145/3492547.3492565;;;Software AND Engineering
StateFormer: fine-grained type recovery from binaries using generative state modeling;;;['Kexin Pei', 'Jonas Guan', 'Matthew Broughton', 'Zhongtian Chen', 'Songchen Yao', 'David Williams-King', 'Vikas Ummadisetty', 'Junfeng Yang', 'Baishakhi Ray', 'Suman Jana'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Binary type inference is a critical reverse engineering task supporting many security applications, including vulnerability analysis, binary hardening, forensics, and decompilation. It is a difficult task because source-level type information is often stripped during compilation, leaving only binaries with untyped memory and register accesses. Existing approaches rely on hand-coded type inference rules defined by domain experts, which are brittle and require nontrivial effort to maintain and update. Even though machine learning approaches have shown promise at automatically learning the inference rules, their accuracy is still low, especially for optimized binaries.   We present StateFormer, a new neural architecture that is adept at accurate and robust type inference. StateFormer follows a two-step transfer learning paradigm. In the pretraining step, the model is trained with Generative State Modeling (GSM), a novel task that we design to teach the model to statically approximate execution effects of assembly instructions in both forward and backward directions. In the finetuning step, the pretrained model learns to use its knowledge of operational semantics to infer types.   We evaluate StateFormer's performance on a corpus of 33 popular open-source software projects containing over 1.67 billion variables of different types. The programs are compiled with GCC and LLVM over 4 optimization levels O0-O3, and 3 obfuscation passes based on LLVM. Our model significantly outperforms state-of-the-art ML-based tools by 14.6% in recovering types for both function arguments and variables. Our ablation studies show that GSM improves type inference accuracy by 33%.;;;https://dl.acm.org/doi/10.1145/3468264.3468607;;;Software AND Engineering
A Simple but Effective Gamification Methodology Based on Lego Type Models for the Attraction of More Students into STEM Programs in Developing Nations;;;['Israel Zamora-Hernandez', 'Miguel X. Rodriguez-Paz', 'Jorge A. Gonzalez-Mendivil'];;;October 2021;;;ICETC '21: Proceedings of the 13th International Conference on Education Technology and Computers;;;This paper presents a methodology based on Lego construction and applications in a context of simple games, for the development of soft competencies in sixth-semester high school students and helping them in the decision of which Engineering program is best for them. These students have declared interest in enrolling at our university, particularly at the School of Engineering and Science. Soft competencies have always been a valuable resource that employers look for in students that finish a college education. Universities around the world make many efforts to attract more students into Science, Technology, Engineering and Math (STEM) programs. This work presents a simple but effective methodology that has worked for us during visits and workshops to high schools as part of our attraction process. In this work we show how some soft competencies like creativity, teamwork, stress management and goal-oriented work are developed at a basic level within a gamification context. The results of a survey answered by two hundred students show the perception of students on how those competencies were developed, how their interest in STEM programs was confirmed and also, how their self confidence in pursuing a “hard” program was strengthened. We present this work so that other universities, particularly those in developing nations, could include this type of gamification activities in their attraction process and improve on the enrolling numbers of students in STEM programs.;;;https://dl.acm.org/doi/10.1145/3498765.3498788;;;Software AND Engineering
Encoding feature models using mainstream JSON technologies;;;['Hazim Shatnawi', 'H. Conrad Cunningham'];;;April 2021;;;ACM SE '21: Proceedings of the 2021 ACM Southeast Conference;;;Feature modeling is a process for identifying the common and variable parts of a software product line and recording them in a tree-structured feature model. However, feature models can be difficult for mainstream developers to specify and maintain because most tools rely on specialized theories, notations, or technologies. To address this issue, we propose a design that uses mainstream JSON-related technologies to encode and manipulate feature models and then uses the models to generate Web forms for product configuration. This JSON-based design can form part of a comprehensive, interactive environment that enables mainstream developers to specify, store, update, and exchange feature models and use them to configure members of product families.;;;https://dl.acm.org/doi/10.1145/3409334.3452048;;;Software AND Engineering
Machine Learning for Detecting Data Exfiltration: A Review;;;['Bushra Sabir', 'Faheem Ullah', 'M. Ali Babar', 'Raj Gaire'];;;None;;;ACM Computing Surveys;;;Context: Research at the intersection of cybersecurity, Machine Learning (ML), and Software Engineering (SE) has recently taken significant steps in proposing countermeasures for detecting sophisticated data exfiltration attacks. It is important to systematically review and synthesize the ML-based data exfiltration countermeasures for building a body of knowledge on this important topic. Objective: This article aims at systematically reviewing ML-based data exfiltration countermeasures to identify and classify ML approaches, feature engineering techniques, evaluation datasets, and performance metrics used for these countermeasures. This review also aims at identifying gaps in research on ML-based data exfiltration countermeasures. Method: We used Systematic Literature Review (SLR) method to select and review 92 papers. Results: The review has enabled us to: (a) classify the ML approaches used in the countermeasures into data-driven, and behavior-driven approaches; (b) categorize features into six types: behavioral, content-based, statistical, syntactical, spatial, and temporal; (c) classify the evaluation datasets into simulated, synthesized, and real datasets; and (d) identify 11 performance measures used by these studies. Conclusion: We conclude that: (i) The integration of data-driven and behavior-driven approaches should be explored; (ii) There is a need of developing high quality and large size evaluation datasets; (iii) Incremental ML model training should be incorporated in countermeasures; (iv) Resilience to adversarial learning should be considered and explored during the development of countermeasures to avoid poisoning attacks; and (v) The use of automated feature engineering should be encouraged for efficiently detecting data exfiltration attacks.;;;https://dl.acm.org/doi/10.1145/3442181;;;Software AND Engineering
Multi-interest sequence recommendation algorithm based on BERT;;;['Fei Wang', 'WeiSen Feng'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;Many studies use a fixed vector to represent the user ' s various interest preferences, and this embedding vector does not have enough ability to effectively capture the user ' s different interests, resulting in a lot of user interest representation missing. Therefore, A model based on BERT multi-interest sequence recommendation (BMISREC) is proposed. The model uses BERT for pre-training, and then divides the users historical interaction sequence into t time windows according to the timestamp. By fusing the cavity convolution and forward attention, the local preference within each time window and the global preference between time windows are obtained. Fusion local and global preferences for each window. Multiple different interest embeddings are generated for each user. In the target item preference module, multiple interests learned can adaptively perceive the correlation between different target items through the attention mechanism, and the target item preference changes with the different target items. Then, the deep neural network is used to recommend the fusion of user and target item preferences in a nonlinear manner. Finally, the effectiveness of the model is verified on two real datasets.;;;https://dl.acm.org/doi/10.1145/3494885.3494888;;;Software AND Engineering
BF-detector: an automated tool for CI build failure detection;;;['Islem Saidani', 'Ali Ouni', 'Moataz Chouchen', 'Mohamed Wiem Mkaouer'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Continuous Integration (CI) aims at supporting developers in inte-grating code changes quickly through automated building. How-ever, there is a consensus that CI build failure is a major barrierthat developers face, which prevents them from proceeding furtherwith development. In this paper, we introduceBF-Detector, anautomated tool to detect CI build failure. Based on the adaptationof Non-dominated Sorting Genetic Algorithm (NSGA-II), our toolaims at finding the best prediction rules based on two conflictingobjective functions to deal with both minority and majority classes.We evaluated the effectiveness of our tool on a benchmark of 56,019CI builds. The results reveal that our technique outperforms state-of-the-art approaches by providing a better balance between bothfailed and passed builds.BF-Detectortool is publicly available,with a demo video, at: https://github.com/stilab-ets/BF-Detector.;;;https://dl.acm.org/doi/10.1145/3468264.3473115;;;Software AND Engineering
Fairea: a model behaviour mutation approach to benchmarking bias mitigation methods;;;['Max Hort', 'Jie M. Zhang', 'Federica Sarro', 'Mark Harman'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;The increasingly wide uptake of Machine Learning (ML) has raised the significance of the problem of tackling bias (i.e., unfairness), making it a primary software engineering concern. In this paper, we introduce Fairea, a model behaviour mutation approach to benchmarking ML bias mitigation methods. We also report on a large-scale empirical study to test the effectiveness of 12 widely-studied bias mitigation methods. Our results reveal that, surprisingly, bias mitigation methods have a poor effectiveness in 49% of the cases. In particular, 15% of the mitigation cases have worse fairness-accuracy trade-offs than the baseline established by Fairea; 34% of the cases have a decrease in accuracy and an increase in bias.   Fairea has been made publicly available for software engineers and researchers to evaluate their bias mitigation methods.;;;https://dl.acm.org/doi/10.1145/3468264.3468565;;;Software AND Engineering
Sound and efficient concurrency bug prediction;;;['Yan Cai', 'Hao Yun', 'Jinqiu Wang', 'Lei Qiao', 'Jens Palsberg'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Concurrency bugs are extremely difficult to detect. Recently, several dynamic techniques achieve sound analysis. M2 is even complete for two threads. It is designed to decide whether two events can occur consecutively. However, real-world concurrency bugs can involve more events and threads. Some can occur when the order of two or more events can be exchanged even if they occur not consecutively. We propose a new technique SeqCheck to soundly decide whether a sequence of events can occur in a specified order. The ordered sequence represents a potential concurrency bug. And several known forms of concurrency bugs can be easily encoded into event sequences where each represents a way that the bug can occur. To achieve it, SeqCheck explicitly analyzes branch events and includes a set of efficient algorithms. We show that SeqCheck is sound; and it is also complete on traces of two threads.   We have implemented SeqCheck to detect three types of concurrency bugs and evaluated it on 51 Java benchmarks producing up to billions of events. Compared with M2 and other three recent sound race detectors, SeqCheck detected 333 races in ~30 minutes; while others detected from 130 to 285 races in ~6 to ~12 hours. SeqCheck detected 20 deadlocks in ~6 seconds. This is only one less than Dirk; but Dirk spent more than one hour. SeqCheck also detected 30 atomicity violations in ~20 minutes. The evaluation shows SeqCheck can significantly outperform existing concurrency bug detectors.;;;https://dl.acm.org/doi/10.1145/3468264.3468549;;;Software AND Engineering
A comparison of dataset search behaviour of internal versus search engine referred sessions;;;['Luis-Daniel Ibáñez', 'Elena Simperl'];;;March 2022;;;CHIIR '22: Proceedings of the 2022 Conference on Human Information Interaction and Retrieval;;;Dataset discovery is a first step for data-centric tasks, from data storytelling to labelling for supervised machine learning. Previous qualitative research suggests that people use two types of search affordances to find the data they need: they either go to a data portal that probably contains the data and search there; or they start on a regular web search engine, which sometimes returns results that are datasets. For the first type of search, prior works have analysed logs from different data portals to understand basic tenets of search behaviour such as query length or topics. In this paper, we advance the state of the art in dataset search behaviour with a comprehensive transaction log analysis study (n = 236441 sessions) of an international open data portal, in which we compare sessions straight on a data portal (internal searches) against sessions that land on a dataset or SERP (search engine result page) through a referral from a web search engine (external). Using dataset downloads as a proxy for successful searches, we find a statistically significant, though weak relationship between the use of keyword search and session type and between the use of search facets and session type (moderate). We also discover and discuss behavioural patterns and user profiles across session types.;;;https://dl.acm.org/doi/10.1145/3498366.3505821;;;Software AND Engineering
MAANA: an automated tool for DoMAin-specific HANdling of ambiguity;;;['Saad Ezzini', 'Sallam Abualhaija', 'Chetan Arora', 'Mehrdad Sabetzadeh', 'Lionel C. Briand'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;MAANA (in Arabic: "meaning") is a tool for performing domain-specific handling of ambiguity in requirements. Given a requirements document as input, MAANA detects the requirements that are potentially ambiguous. The focus of MAANA is on coordination ambiguity and prepositional-phrase attachment ambiguity; these are two common ambiguity types that have been studied in the requirements engineering literature. To detect ambiguity, MAANA utilizes structural patterns and a set of heuristics derived from a domain-specific corpus. The generated analysis file after running the tool can be reviewed by requirements analysts. Through combining different knowledge sources, MAANA highlights also the requirements that might contain unacknowledged ambiguity. That is when the analysts understand different interpretations for the same requirement, without explicitly discussing it with the other analysts due to time constraints. This artifact paper presents the details of MAANA. MAANA is associated with the ICSE 2021 technical paper titled "Using Domain-specific Corpora for Improved Handling of Ambiguity in Requirements". The tool is publicly available on GitHub and Zenodo.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00082;;;Software AND Engineering
Organizational implications of agile adoption: a case study from the public sector;;;['Parastoo Mohagheghi', 'Casper Lassenius'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;While agile software development is increasingly adopted in large organizations, there is still a lack of studies on how traditionally organized enterprises adopt and scale agile forms of organization. This industrial multiple embedded case study explores how the organizational model of a large public sector entity evolved over four years to support the adoption of agile software development methods. Data was collected through semi-structured interviews and document analysis. We describe the change in three phases: pre-transformation, initial transformation, and maturing. Changes in three subcases of organizational units are further described in detail. Moving from an outsourced project-based way-of-working with separate business, IT and vendor organizations, the new organizational design emphasizes internal development capability, cross-functional autonomous teams organized around products and grouped in product areas, and continuous delivery. Starting from the IT department, the transformation expanded to the whole organization, and went beyond software development to the finance and leadership. We describe the target and intermediate organizations employed when adopting agile development methods for the whole organization and three organizational units responsible for different services. Defining suitable product boundaries, achieving alignment across teams, enhancing the competence of product owners, the coexistence of old and new types of systems, processes, and structures, and balancing the teams’ need for autonomy with the organizational needs for coordination and control are remaining challenges.;;;https://dl.acm.org/doi/10.1145/3468264.3473937;;;Software AND Engineering
Knowledge-based Risk Management: A Systematic Literature Review;;;['Ademar Neto', 'Mirko Perkusich', 'Emanuel Dantas', 'Felipe Ramos', 'Alexandre Costa', 'Hyggo Almeida', 'Angelo Perkusich'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Knowledge management can enhance project risk management effectiveness by supporting the reuse of risk-related knowledge, supporting decision-making. This paper explores this hypothesis by identifying and analyzing the state of the art of studies addressing knowledge-based risk management, seeking solutions that present the process of reusing risk-related knowledge. To this end, we conducted a Systematic Literature Review, applying a hybrid approach that combined a search on the Scopus database with snowballing (backward and forward). We applied Thematic Analysis to the primary studies to identify the main attributes of existing knowledge-based risk management solutions and their relationships. In total, we evaluated 1363 papers and identified 7 reported solutions on the topic. The resulting thematic network comprises one higher-level theme: the Risk Repository; and five middle-level: Knowledge capture, Knowledge codification, Embed Knowledge, Shared Knowledge, and Knowledge application. An implication for research is the need to propose tools and algorithms to support the reuse of knowledge for project risk management. Also, provide practical assessments of the feasibility and utility of these solutions. Furthermore, the Thematic Network can be generalized and used as a basis for researchers who intend to explore knowledge-based risk management. For practitioners, the Thematic Network can help them understand reusing risk knowledge and use the resources already existing in the company to improve organizational learning in risk management.;;;https://dl.acm.org/doi/10.1145/3474624.3474635;;;Software AND Engineering
Component-based design of multi-objective evolutionary algorithms using the Tigon optimization library;;;['João A. Duro', 'Daniel C. Oara', 'Ambuj K. Sriwastava', 'Yiming Yan', 'Shaul Salomon', 'Robin C. Purshouse'];;;July 2021;;;GECCO '21: Proceedings of the Genetic and Evolutionary Computation Conference Companion;;;Multi-objective optimization problems involve several conflicting objectives that have to be optimized simultaneously. Generating a complete Pareto-optimal front (POF) can be computationally expensive or even infeasible, and for that reason there has been an enormous interest in using multi-objective evolutionary algorithms (MOEAs), which are known to generate a good approximation of the POF. MOEAs can be difficult to implement, and even for experienced optimization experts it can be a very time consuming task. For this reason several optimization libraries exist in the literature, providing off-the-shelf access to the most popular MOEAs. Some optimization libraries also provide a framework to design MOEAs. However, existing frameworks can be too stringent and do not provide sufficient flexibility for the design of more sophisticated MOEAs. To address this, a recently proposed optimization library, known as Tigon, features a component-based framework for the design of MOEAs with a focus on flexibility and re-usability. This paper demonstrates the generality of this new framework by showing how to implement different types of MOEAs, covering several paradigms in evolutionary computation. The work in this paper serves as a guide for researchers, and others alike, to build their own MOEAs by using the Tigon optimization library.;;;https://dl.acm.org/doi/10.1145/3449726.3463194;;;Software AND Engineering
EvoSpex: An Evolutionary Algorithm for Learning Postconditions;;;['Facundo Molina', 'Pablo Ponzio', 'Nazareno Aguirre', 'Marcelo Frias'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Software reliability is a primary concern in the construction of software, and thus a fundamental component in the definition of software quality. Analyzing software reliability requires a specification of the intended behavior of the software under analysis, and at the source code level, such specifications typically take the form of assertions. Unfortunately, software many times lacks such specifications, or only provides them for scenario-specific behaviors, as assertions accompanying tests. This issue seriously diminishes the analyzability of software with respect to its reliability. In this paper, we tackle this problem by proposing a technique that, given a Java method, automatically produces a specification of the method's current behavior, in the form of postcondition assertions. This mechanism is based on generating executions of the method under analysis to obtain valid pre/post state pairs, mutating these pairs to obtain (allegedly) invalid ones, and then using a genetic algorithm to produce an assertion that is satisfied by the valid pre/post pairs, while leaving out the invalid ones. The technique, which targets in particular methods of reference-based class implementations, is assessed on a benchmark of open source Java projects, showing that our genetic algorithm is able to generate post-conditions that are stronger and more accurate, than those generated by related automated approaches, as evaluated by an automated oracle assessment tool. Moreover, our technique is also able to infer an important part of manually written rich postconditions in verified classes, and reproduce contracts for methods whose class implementations were automatically synthesized from specifications.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00112;;;Software AND Engineering
Improving test case generation for REST APIs through hierarchical clustering;;;['Dimitri Stallenberg', 'Mitchell Olsthoorn', 'Annibale Panichella'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;With the ever-increasing use of web APIs in modern-day applications, it is becoming more important to test the system as a whole. In the last decade, tools and approaches have been proposed to automate the creation of system-level test cases for these APIs using evolutionary algorithms (EAs). One of the limiting factors of EAs is that the genetic operators (crossover and mutation) are fully randomized, potentially breaking promising patterns in the sequences of API requests discovered during the search. Breaking these patterns has a negative impact on the effectiveness of the test case generation process. To address this limitation, this paper proposes a new approach that uses Agglomerative Hierarchical Clustering (AHC) to infer a linkage tree model, which captures, replicates, and preserves these patterns in new test cases. We evaluate our approach, called LT-MOSA, by performing an empirical study on 7 real-world benchmark applications w.r.t. branch coverage and real-fault detection capability. We also compare LT-MOSA with the two existing state-of-the-art white-box techniques (MIO, MOSA) for REST API testing. Our results show that LT-MOSA achieves a statistically significant increase in test target coverage (i.e., lines and branches) compared to MIO and MOSA in 4 and 5 out of 7 applications, respectively. Furthermore, LT-MOSA discovers 27 and 18 unique real-faults that are left undetected by MIO and MOSA, respectively.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678586;;;Software AND Engineering
JEST: N+1-version differential testing of both Javascript engines and specification;;;['Jihyeok Park', 'Seungmin An', 'Dongjun Youn', 'Gyeongwon Kim', 'Sukyoung Ryu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Modern programming follows the continuous integration (CI) and continuous deployment (CD) approach rather than the traditional waterfall model. Even the development of modern programming languages uses the CI/CD approach to swiftly provide new language features and to adapt to new development environments. Unlike in the conventional approach, in the modern CI/CD approach, a language specification is no more the oracle of the language semantics because both the specification and its implementations (interpreters or compilers) can co-evolve. In this setting, both the specification and implementations may have bugs, and guaranteeing their correctness is non-trivial. In this paper, we propose a novel N+1-version differential testing to resolve the problem. Unlike the traditional differential testing, our approach consists of three steps: 1) to automatically synthesize programs guided by the syntax and semantics from a given language specification, 2) to generate conformance tests by injecting assertions to the synthesized programs to check their final program states, 3) to detect bugs in the specification and implementations via executing the conformance tests on multiple implementations, and 4) to localize bugs on the specification using statistical information. We actualize our approach for the JavaScript programming language via JEST, which performs N+1-version differential testing for modern JavaScript engines and ECMAScript, the language specification describing the syntax and semantics of JavaScript in a natural language. We evaluated JEST with four JavaScript engines that support all modern JavaScript language features and the latest version of ECMAScript (ES11, 2020). JEST automatically synthesized 1,700 programs that covered 97.78% of syntax and 87.70% of semantics from ES11. Using the assertion-injected JavaScript programs, it detected 44 engine bugs in four different engines and 27 specification bugs in ES11.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00065;;;Software AND Engineering
Does Search Engine Optimization come along with high-quality content?: A comparison between optimized and non-optimized health-related web pages;;;['Sebastian Schultheiß', 'Helena Häußler', 'Dirk Lewandowski'];;;March 2022;;;CHIIR '22: Proceedings of the 2022 Conference on Human Information Interaction and Retrieval;;;Searching for medical information is both a common and important activity since it influences decisions people make about their healthcare. Using search engine optimization (SEO), content producers seek to increase the visibility of their content. SEO is more likely to be practiced by commercially motivated content producers such as pharmaceutical companies than by non-commercial providers such as governmental bodies. In this study, we ask whether content quality correlates with the presence or absence of SEO measures on a web page. We conducted a user study in which N = 61 participants comprising laypeople as well as experts in health information assessment evaluated health-related web pages classified as either optimized or non-optimized. The subjects rated the expertise of non-optimized web pages as higher than the expertise of optimized pages, justifying their appraisal by the more competent and reputable appearance of non-optimized pages. In addition, comments about the website operators of the non-optimized pages were exclusively positive, while optimized pages tended to receive positive as well as negative assessments. We found no differences between the ratings of laypeople and experts. Since non-optimized, but high-quality content may be outranked by optimized content of lower quality, trusted sources should be prioritized in rankings.;;;https://dl.acm.org/doi/10.1145/3498366.3505811;;;Software AND Engineering
Mining Domain Terminologies Using Search Engine's Query Log;;;['Weijian Ni', 'Tong Liu', 'Qingtian Zeng', 'Nengfu Xie'];;;None;;;ACM Transactions on Asian and Low-Resource Language Information Processing;;;Domain terminologies are a basic resource for various natural language processing tasks. To automatically discover terminologies for a domain of interest, most traditional approaches mostly rely on a domain-specific corpus given in advance; thus, the performance of traditional approaches can only be guaranteed when collecting a high-quality domain-specific corpus, which requires extensive human involvement and domain expertise. In this article, we propose a novel approach that is capable of automatically mining domain terminologies using search engine's query log—a type of domain-independent corpus of higher availability, coverage, and timeliness than a manually collected domain-specific corpus. In particular, we represent query log as a heterogeneous network and formulate the task of mining domain terminology as transductive learning on the heterogeneous network. In the proposed approach, the manifold structure of domain-specificity inherent in query log is captured by using a novel network embedding algorithm and further exploited to reduce the need for the manual annotation efforts for domain terminology classification. We select Agriculture and Healthcare as the target domains and experiment using a real query log from a commercial search engine. Experimental results show that the proposed approach outperforms several state-of-the-art approaches.;;;https://dl.acm.org/doi/10.1145/3462327;;;Software AND Engineering
Architecting Internet of Things Systems with Blockchain: A Catalog of Tactics;;;['Wendy Yánez', 'Rami Bahsoon', 'Yuqun Zhang', 'Rick Kazman'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Blockchain offers a distributed ledger to record data collected from Internet of Thing (IoT) devices as immutable and tamper-proof transactions and securely shared among authorized participants in a Peer-to-Peer (P2P) network. Despite the growing interest in using blockchain for securing IoT systems, there is a general lack of systematic research and comprehensive review of the design issues on the integration of blockchain and IoT from the software architecture perspective. This article presents a catalog of architectural tactics for the design of IoT systems supported by blockchain as a result of a Systematic Literature Review (SLR) on IoT and blockchain to extract the commonly reported quality attributes, design decisions, and relevant architectural tactics for the architectural design of this category of systems. Our findings are threefold:<?brk?> (i) identification of security, scalability, performance, and interoperability as the commonly reported quality attributes; (ii) a catalog of twelve architectural tactics for the design of IoT systems supported by blockchain; and (iii) gaps in research that include tradeoffs among quality attributes and identified tactics. These tactics might provide architects and designers with different options when searching for an optimal architectural design that meets the quality attributes of interest and constraints of a system.;;;https://dl.acm.org/doi/10.1145/3442412;;;Software AND Engineering
OwlEyes-online: a fully automated platform for detecting and localizing UI display issues;;;['Yuhui Su', 'Zhe Liu', 'Chunyang Chen', 'Junjie Wang', 'Qing Wang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Graphical User Interface (GUI) provides visual bridges between software apps and end users. However, due to the compatibility of software or hardware, UI display issues such as text overlap, blurred screen, image missing always occur during GUI rendering on different devices. Because these UI display issues can be found directly by human eyes, in this paper, we implement an online UI display issue detection tool OwlEyes-Online, which provides a simple and easy-to-use platform for users to realize the automatic detection and localization of UI display issues. The OwlEyes-Online can automatically run the app and get its screenshots and XML files, and then detect the existence of issues by analyzing the screenshots. In addition, OwlEyes-Online can also find the detailed area of the issue in the given screenshots to further remind developers. Finally, OwlEyes-Online will automatically generate test reports with UI display issues detected in app screenshots and send them to users. The OwlEyes-Online was evaluated and proved to be able to accurately detect UI display issues. Tool Link: http://www.owleyes.online:7476 Github Link: https://github.com/franklinbill/owleyes Demo Video Link: https://youtu.be/002nHZBxtCY;;;https://dl.acm.org/doi/10.1145/3468264.3473109;;;Software AND Engineering
User and System Stories: An Agile Approach for Managing Requirements in AOSE;;;['Sebastian Rodriguez', 'John Thangarajah', 'Michael Winikoff'];;;May 2021;;;AAMAS '21: Proceedings of the 20th International Conference on Autonomous Agents and MultiAgent Systems;;;The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.;;;https://dl.acm.org/doi/10.5555/3463952.3464076;;;Software AND Engineering
An Empirical Examination of the Impact of Bias on Just-in-time Defect Prediction;;;['Jiri Gesi', 'Jiawei Li', 'Iftekhar Ahmed'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Just-In-Time (JIT) defect prediction models predict if a commit will introduce defects in the future. DeepJIT and CC2Vec are two state-of-the-art JIT Deep Learning (DL) techniques. Usually, defect prediction techniques are evaluated, treating all training data equally. However, data is usually imbalanced not only in terms of the overall class label (e.g., defect and non-defect) but also in terms of characteristics such as File Count, Edit Count, Multiline Comments, Inward Dependency Sum etc. Prior research has investigated the impact of class imbalance on prediction technique's performance but not the impact of imbalance of other characteristics. Aims: We aim to explore the impact of different commit related characteristic's imbalance on DL defect prediction. Method: We investigated different characteristic's impact on the overall performance of DeepJIT and CC2Vec. We also propose a Siamese network based few-shot learning framework for JIT defect prediction (SifterJIT) combining Siamese network and DeepJIT. Results: Our results show that DeepJIT and CC2Vec lose out on the performance by around 20% when trained and tested on imbalanced data. However, SifterJIT can outperform state-of-the-art DL techniques with an average of 8.65% AUC score, 11% precision, and 6% F1-score improvement. Conclusions: Our results highlight that dataset imbalanced in terms of commit characteristics can significantly impact prediction performance, and few-shot learning based techniques can help alleviate the situation.;;;https://dl.acm.org/doi/10.1145/3475716.3475791;;;Software AND Engineering
Using static analysis to address microservice architecture reconstruction;;;['Vincent Bushong', 'Dipta Das', 'Abdullah Al Maruf', 'Tomas Cerny'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Microservice design offers many advantages for enterprise applications, including increased scalability and faster deployment times. Microservices' independence from one another in development and deployment provides these advantages. This separation, however, results in the absence of a centralized view of the application's functionality, and each microservice's data model is isolated and replicated. As a result, it has the potential to deviate from the architectural design's original intent. To address this, we offer a method for analyzing a microservice mesh and generating a communication diagram, context map, and microservice-specific limited contexts using static code analysis.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678749;;;Software AND Engineering
Sustainable Solving: Reducing The Memory Footprint of IFDS-Based Data Flow Analyses Using Intelligent Garbage Collection;;;['Steven Arzt'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Static data flow analysis is an integral building block for many applications, ranging from compile-time code optimization to security and privacy analysis. When assessing whether a mobile app is trustworthy, for example, analysts need to identify which of the user's personal data is sent to external parties such as the app developer or cloud providers. Since accessing and sending data is usually done via API calls, tracking the data flow between source and sink API is often the method of choice. Precise algorithms such as IFDS help reduce the number of false positives, but also introduce significant performance penalties. With its fixpoint iteration over the program's entire exploded supergraph, IFDS is particularly memory-intensive, consuming hundreds of megabytes or even several gigabytes for medium-sized apps. In this paper, we present a technique called CleanDroid for reducing the memory footprint of a precise IFDS-based data flow analysis and demonstrate its effectiveness in the popular FlowDroid open-source data flow solver. CleanDroid efficiently removes edges from the path edge table used for the IFDS fixpoint iteration without affecting termination. As we show on 600 real-world Android apps from the Google Play Store, CleanDroid reduces the average per-app memory consumption by around 63% to 78%. At the same time, CleanDroid speeds up the analysis by up to 66%.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00102;;;Software AND Engineering
JEST: N+1-version Differential Testing of Both JavaScript Engines and Specification;;;['Jihyeok Park', 'Seungmin An', 'Dongjun Youn', 'Gyeongwon Kim', 'Sukyoung Ryu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Modern programming follows the continuous integration (CI) and continuous deployment (CD) approach rather than the traditional waterfall model. Even the development of modern programming languages uses the CI/CD approach to swiftly provide new language features and to adapt to new development environments. Unlike in the conventional approach, in the modern CI/CD approach, a language specification is no more the oracle of the language semantics because both the specification and its implementations (interpreters or compilers) can co-evolve. In this setting, both the specification and implementations may have bugs, and guaranteeing their correctness is non-trivial. In this paper, we propose a novel N+1-version differential testing to resolve the problem. Unlike the traditional differential testing, our approach consists of three steps: 1) to automatically synthesize programs guided by the syntax and semantics from a given language specification, 2) to generate conformance tests by injecting assertions to the synthesized programs to check their final program states, 3) to detect bugs in the specification and implementations via executing the conformance tests on multiple implementations, and 4) to localize bugs on the specification using statistical information. We actualize our approach for the JavaScript programming language via JEST, which performs N+1-version differential testing for modern JavaScript engines and ECMAScript, the language specification describing the syntax and semantics of JavaScript in a natural language. We evaluated JEST with four JavaScript engines that support all modern JavaScript language features and the latest version of ECMAScript (ES11, 2020). JEST automatically synthesized 1,700 programs that covered 97.78% of syntax and 87.70% of semantics from ES11. Using the assertion-injected JavaScript programs, it detected 44 engine bugs in four different engines and 27 specification bugs in ES11.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00015;;;Software AND Engineering
Motivating complexity understanding by profiling energy usage;;;['Joshua B. Gross', 'Daniel Jacoby', 'Kevin Coogan', 'Aaron Helman'];;;October 2021;;;Onward! 2021: Proceedings of the 2021 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software;;;Computer science and software engineering students are typically taught to evaluate resource use in terms of time complexity. Developers use asymptotic analysis to compare algorithms by calculating how time grows as a function of input size. However, two factors have limited traditional models of complexity as pedagogical tools. First, modern systems are so fast that even relatively inefficient algorithms can quickly process large sets of data. Second, analysis is not universally engaging; only some students care about efficiency for the sake of efficiency. Our project proposes using measurements of energy consumption and the concomitant environmental impact to better engage students with efficiency and its implications.   Since current students have a strong level of concern about environmental consequences, we believe energy usage data will be more concrete and motivating than differences in time and will deepen the appreciation students have for computational complexity by using real-world measurements and by tying energy usage to climate change. We also believe that these future software engineers will be better equipped to contribute to the field by understanding the broader impact of software choices and resource usage. This approach is meant to augment and give meaning to traditional measurements of computational complexity, rather than supplant them.;;;https://dl.acm.org/doi/10.1145/3486607.3486752;;;Software AND Engineering
A Deeper Investigation of the Importance of Wikipedia Links to Search Engine Results;;;['Nicholas Vincent', 'Brent Hecht'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;A growing body of work has highlighted the important role that Wikipedia's volunteer-created content plays in helping search engines achieve their core goal of addressing the information needs of hundreds of millions of people. In this paper, we report the results of an investigation into the incidence of Wikipedia links in search engine results pages (SERPs). Our results extend prior work by considering three U.S. search engines, simulating both mobile and desktop devices, and using a spatial analysis approach designed to study modern SERPs that are no longer just "ten blue links". We find that Wikipedia links are extremely common in important search contexts, appearing in 67-84% of desktop SERPs for common and trending queries, but less often for medical queries. Furthermore, we observe that Wikipedia links often appear in "Knowledge Panel" SERP elements and are in positions visible to users without scrolling, although Wikipedia appears less often and in less prominent positions on mobile devices. Our findings reinforce the complementary notions that (1) Wikipedia content and research has major impact outside of the Wikipedia domain and (2) powerful technologies like search engines are highly reliant on free content created by volunteers.;;;https://dl.acm.org/doi/10.1145/3449078;;;Software AND Engineering
ExecutionManager: a software system to control execution of third-party software that performs network computations;;;['Henry L. Carscadden', 'Lucas Machi', 'Aparna Kishore', 'Chris J. Kuhlman', 'Dustin Machi', 'S. S. Ravi'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;We describe a software system called ExecutionManager (abbreviated EM) that controls the execution of third-party software (TPS) for analyzing networks. Based on a configuration file that contains a specification for the execution of each TPS, the system launches any number of stand-alone TPS codes, if the projected execution time and the graph size are within user-imposed limits. A system capability is to estimate the running time of a TPS code on a given network through regression analysis, to support execution decision-making by EM. We demonstrate the usefulness of EM in generating network structure parameters and distributions, and in extracting meta-data information from these results. We evaluate its performance on directed and undirected, simple and multi-edge graphs that range in size over seven orders of magnitude in numbers of edges, up to 1.5 billion edges. The software system is part of a cyberinfrastructure called net.science for network science.;;;https://dl.acm.org/doi/10.5555/3522802.3522851;;;Software AND Engineering
Morphy: Software Defined Charge Storage for the IoT;;;['Fan Yang', 'Ashok Samraj Thangarajan', 'Sam Michiels', 'Wouter Joosen', 'Danny Hughes'];;;November 2021;;;SenSys '21: Proceedings of the 19th ACM Conference on Embedded Networked Sensor Systems;;;Recent innovations in energy harvesting promise extended operational life and reduced maintenance costs for the next generation of Internet of Things (IoT) platforms. However, energy management in these platforms remains problematic due to dynamism in energy supply and demand, inefficiency in storing and converting energy and a lack of per-task charge isolation. This paper tackles this problem by proposing a software defined charge storage module called Morphy, which combines a polymorphic capacitor array with intelligent power management software. Morphy delivers energy to application tasks in a flexible, efficient, and isolated manner. Morphy provides two software extensions to the Operating System scheduler: the energy semaphore blocks the execution of tasks until sufficient charge is available to safely run them, and the energy watchdog monitors and mitigates energy management bugs. We have realized a prototype of Morphy with the hardware form factor of a standard 9V (PP3) battery package and a software library that integrates with the FreeRTOS scheduler. Our evaluation shows that, in comparison to standard energy storage and management approaches, our prototype reaches an operational voltage more quickly, sustains operation longer in the case of power failure and effectively isolates charge storage for dedicated tasks with minimal compute, memory and energy overhead.;;;https://dl.acm.org/doi/10.1145/3485730.3485947;;;Software AND Engineering
HSAACE: Design a Cloud Platform Health Status Assessment Application to Support Continuous Evolution of Assessment Capabilities;;;['Yuzhu Hu', 'Yunxuan Wang'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;None;;;https://dl.acm.org/doi/10.1145/3520084.3520105;;;Software AND Engineering
The four dimensions of Variability and their impact on MBPLE: How to approach variability in the development of aircraft product lines at Airbus;;;['Marco Forlingieri'];;;February 2022;;;VaMoS '22: Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;;;The development of complex systems such as aircraft product lines requires the support of advanced modeling methodologies such as Model-Based Systems Engineering (MBSE) and Product-Line Engineering (PLE). To enable the development of such complex product lines, Airbus is adopting the combination of MBSE and PLE, a method previously applied in other industries and known as Model-Based Product Line Engineering (MBPLE). In adopting MBPLE it is necessary to understand the type of constraints that influences the definition of variability within a development program or project. This paper proposes four different dimensions of variability which facilitate and guide the application of MBPLE at Airbus but that can also be extended to other industries and organizations. Those four dimensions, namely Co-Variability in product, manufacturing and services, Variability in development lifecycle, Variability in layers of abstraction, and Variability in system hierarchy levels, are first described. Afterward, their impact on the MBPLE method steps, namely “Define Product Line Feature Models”, “Define Product Line Assets”, “Select Member Product Feature Configuration” and “Derive Member Product Assets”, is analyzed with the support of an Airbus example.;;;https://dl.acm.org/doi/10.1145/3510466.3511275;;;Software AND Engineering
DeepPayload: Black-box Backdoor Attack on Deep Learning Models through Neural Payload Injection;;;['Yuanchun Li', 'Jiayi Hua', 'Haoyu Wang', 'Chunyang Chen', 'Yunxin Liu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Deep learning models are increasingly used in mobile applications as critical components. Unlike the program bytecode whose vulnerabilities and threats have been widely-discussed, whether and how the deep learning models deployed in the applications can be compromised are not well-understood since neural networks are usually viewed as a black box. In this paper, we introduce a highly practical backdoor attack achieved with a set of reverse-engineering techniques over compiled deep learning models. The core of the attack is a neural conditional branch constructed with a trigger detector and several operators and injected into the victim model as a malicious payload. The attack is effective as the conditional logic can be flexibly customized by the attacker, and scalable as it does not require any prior knowledge from the original model. We evaluated the attack effectiveness using 5 state-of-the-art deep learning models and real-world samples collected from 30 users. The results demonstrated that the injected backdoor can be triggered with a success rate of 93.5%, while only brought less than 2ms latency overhead and no more than 1.4% accuracy decrease. We further conducted an empirical study on real-world mobile deep learning apps collected from Google Play. We found 54 apps that were vulnerable to our attack, including popular and security-critical ones. The results call for the awareness of deep learning application developers and auditors to enhance the protection of deployed models.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00035;;;Software AND Engineering
Lyzeli: a tool for identifying the clues in survey research data;;;['João Pedro Rodrigues', 'Nabor Mendonça', 'Ivan Machado'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Survey research is one of the most used empirical research methods, and it is a means to contribute to theory development. A survey can be exploratory, descriptive, or explanatory. Whatever the objective, it will generate data that may support the construction of a theory or validate it. However, researchers must carefully evaluate data so they can transform them into useful information for science. Little is said about how complex and susceptible to human failures this process can be. We note that all the data analysis work is still highly manual and exhausting for the researcher, who is not always qualified to perform data analysis and, sometimes, can make mistakes in this process, inserting wrong numbers or calculating something wrong. Some existing tools can support this process but do not specifically focus on analyzing survey responses, combining valuable qualitative and quantitative analysis of responses. In this study, we introduce Lyzeli, a tool designed to assist researchers in analyzing and correlating survey responses. The proposed tool aims to deliver automatic detection of question types, sentiment analysis of responses, data filtering, word cloud, word count, graphics, codification for open-based questions answers.  Tool Demonstration: https://youtu.be/e2w4TfhlxBY;;;https://dl.acm.org/doi/10.1145/3474624.3476018;;;Software AND Engineering
Combining domain expert knowledge and machine learning for the identification of error prone files;;;['Piyush Korlepara', 'Marios Grigoriou', 'Kostas Kontogiannis', 'Chris Brealey', 'Alberto Giammaria'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Identifying as early as possible fault prone modules in order to facilitate continuous delivery in large software systems, has been an area where significant attention has been paid over the past few years. Recent efforts consider source code metrics and process metrics for training machine learning models to predict whether a software source code file is fault prone or not. In such prediction frameworks the accuracy of the trained model relies heavily on the features selected and the profiles of the metrics used for training the model which are unique to each system. Furthermore, these models act as black-boxes, where the end-user does not know how a specific prediction was reached. In this paper, we propose an approach which allows for domain expert knowledge to be combined with machine learning in order to yield fault-proneness prediction models that both exhibit high levels of recall and at the same time are able to provide explanations to the developers as to how and why these predictions were reached. For this paper we apply two rule-based inferencing techniques namely, Fuzzy reasoning, and Markov Logic Networks. The main contribution of this work is that it allows for expert developers to identify in the form of if-then rules domain logic that pertains to the fault-proneness of a source code file in the specific system being analysed. Results obtained from 19 open source systens indicate that MLNs perform better than Fuzzy Logic models and that project-customized rules achieve better results than generic rules. Furthermore, results indicate that its possible to compile a common set of rules that yields consistently acceptable results across different projects.;;;https://dl.acm.org/doi/10.5555/3507788.3507810;;;Software AND Engineering
Bug Localization in Model-Based Systems in the Wild;;;['Lorena Arcega', 'Jaime Font', 'Øystein Haugen', 'Carlos Cetina'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;The companies that have adopted the Model-Driven Engineering (MDE) paradigm have the advantage of working at a high level of abstraction. Nevertheless, they have the disadvantage of the lack of tools available to perform bug localization at the model level. In addition, in an MDE context, a bug can be related to different MDE artefacts, such as design-time models, model transformations, or run-time models. Starting the bug localization in the wrong place or with the wrong tool can lead to a result that is unsatisfactory. We evaluate how to apply the existing model-based approaches in order to mitigate the effect of starting the localization in the wrong place. We also take into account that software engineers can refine the results at different stages. In our evaluation, we compare different combinations of the application of bug localization approaches and human refinement. The combination of our approaches plus manual refinement obtains the best results. We performed a statistical analysis to provide evidence of the significance of the results. The conclusions obtained from this evaluation are: humans have to be involved at the right time in the process (or results can even get worse), and artefact-independence can be achieved without worsening the results.;;;https://dl.acm.org/doi/10.1145/3472616;;;Software AND Engineering
RM3: A Risk Management Framework For IT Project Success;;;['Paulo Roberto Martins de Andrade', 'Samira Sadaoui'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;Risk Management (RM) is critical for projects’ success as it can predict undesirable events that may occur. Nevertheless, RM is lacking in industry, especially for projects in the IT sector. For this purpose, our study introduces RM3, a new framework for analyzing and measuring risks to compensate for known and unknown factors affecting the path to the projects’ success. RM3 comprises three primary processes: project complexity analysis, risk analysis, and risk monitoring and control. Based on a robust action-research study, we demonstrate RM3’s feasibility and effectiveness through an actual project within an IT company.;;;https://dl.acm.org/doi/10.1145/3494885.3494922;;;Software AND Engineering
A first look at developers’ live chat on Gitter;;;['Lin Shi', 'Xiao Chen', 'Ye Yang', 'Hanzhi Jiang', 'Ziyou Jiang', 'Nan Niu', 'Qing Wang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Modern communication platforms such as Gitter and Slack play an increasingly critical role in supporting software teamwork, especially in open source development.Conversations on such platforms often contain intensive, valuable information that may be used for better understanding OSS developer communication and collaboration. However, little work has been done in this regard. To bridge the gap, this paper reports a first comprehensive empirical study on developers' live chat, investigating when they interact, what community structures look like, which topics are discussed, and how they interact. We manually analyze 749 dialogs in the first phase, followed by an automated analysis of over 173K dialogs in the second phase. We find that developers tend to converse more often on weekdays, especially on Wednesdays and Thursdays (UTC), that there are three common community structures observed, that developers tend to discuss topics such as API usages and errors, and that six dialog interaction patterns are identified in the live chat communities. Based on the findings, we provide recommendations for individual developers and OSS communities, highlight desired features for platform vendors, and shed light on future research directions. We believe that the findings and insights will enable a better understanding of developers' live chat, pave the way for other researchers, as well as a better utilization and mining of knowledge embedded in the massive chat history.;;;https://dl.acm.org/doi/10.1145/3468264.3468562;;;Software AND Engineering
How Do Agile Practitioners Interpret and Foster “Technical Excellence”?;;;['Adam Alami', 'Maria Paasivaara'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;“Technical excellence” is a nebulous term in agile software development. This vagueness is risky, as it creates a gap in the understanding of agile that may have consequences on how software development practitioners operate. Technical excellence is the only reference to quality in the agile manifesto. Hence, it is fundamental to understand how agile software development practitioners both interpret and implement it. We conducted interviews with twenty agile practitioners about their understanding of the term “technical excellence” and how they approach the task of fostering it. To validate the ﬁndings, two focus group meetings were conducted after the interviews and the analysis of the data were completed. We found that the conﬁguration of technical excellence is made of four traits: (1) software craftsmanship; (2) software quality (3) mindset for excellence; and (4) consistency with good software engineering practices. Fostering technical excellence is a continuous endeavor. Further, we identified three key principles that were commonly cited as essential to implementing technical excellence, namely: 1) continuous learning; 2) continuous improvement; and 3) control of excellence. Based on our findings, we present several recommendations for software development teams seeking to better realize the goal of technical excellence in their agile implementation.;;;https://dl.acm.org/doi/10.1145/3463274.3463322;;;Software AND Engineering
Split-Protocol-Stack Wireless Network Emulation: Enabling PHY Modeling Diversity with Software-Radio-in-the-Loop;;;['Sebastian Boehm', 'Hartmut Koenig'];;;November 2021;;;Q2SWinet '21: Proceedings of the 17th ACM Symposium on QoS and Security for Wireless and Mobile Networks;;;Accurate evaluation of Wireless Sensor Networks (WSNs) is increasingly challenging due to precise physical requirements and application-specific algorithmic demands at the same time. In our previous research, we have already demonstrated various conceptual details of how a combination of different network evaluation techniques can increase accuracy and validity of evaluation results. In this paper, we present a novel emulation technique in which the node's protocol stack is split horizontally while using a Software-Defined Radio (SDR) environment with real hardware at the Physical Layer (PHY) and radio channel, and Discrete-Event Simulation (DES) at the link layer and higher layers. Throughout the emulation setup, we are able to change specific parameters or even switch different radio functions from the simulation, thus allowing for physically accurate and highly configurable PHY integration.;;;https://dl.acm.org/doi/10.1145/3479242.3487319;;;Software AND Engineering
Stylometric Study of the Fiction Using Sketch Engine;;;['Oksana S. Taran', 'Oleksandra S. Palchevska', 'Alla A. Luchyk', 'Viktoriia V. Shabunina', 'Oksana V. Labenko'];;;December 2021;;;DHW 2021: Digital Humanities Workshop;;;The paper deals with a stylometric study of I. Asimov’s idiostyle considering a corpus-based approach. For the analysis of stylometric features the I. Asimov “Foundation” cycle text corpus was created. The quantitative and statistical processing of the text corpus is done via Sketch Engine tool that enables comparison of phrases and words in the following variants: lemma, token, subcorpus. The last parameter is important for distinguishing individual authorial features, comparing their combinability and identifying the dynamics of idiostyle. The following stylometric features of a text corpus by I. Asimov are described: quantitative morphological and lexical characteristics of the vocabulary, quantitative characteristics of occasionalisms’ word formation and statistical estimation of occasionalisms’ collocations. It is sated that the frequency of occasionalisms in the cycle of novels undergoes chronological change, as well as their combinability. In this paper, a method of occasionalisms’ automated extraction due to keyness score was proposed, however, it requires the subsequent manual verification.;;;https://dl.acm.org/doi/10.1145/3526242.3526249;;;Software AND Engineering
From pairwise to family-based generic analysis of delta-oriented model-based SPLs;;;['Christopher Pietsch', 'Udo Kelter', 'Timo Kehrer'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;One way to implement model-based software product lines (MBSPLs) is to use a transformational approach known as Delta Modeling (DM). Here, an MBSPL is implemented by one core model and a set of delta modules. Delta modules define model transformations using edit operations which add, remove or modify model elements. Editings of different delta modules can be in conflict or depend on each other, leading to conflict and dependency relations between delta modules. Conflicts and unfulfilled dependencies can cause the generation of a product to fail or to lead to invalid models. In order to spot such defects, one needs analysis tools for each modeling (sub-)language used. Existing generic approaches to statically detect such defects in a language-agnostic manner analyze pairs of delta modules. However, the pairwise approach can lead to false positives, i.e., conflicts and unfulfilled dependencies are reported although product generation does not fail. Following the idea of family-based analysis, this paper presents a new approach to detect pseudo defects resolved by "healing effects" implied by the network of dependencies. These effects typically occur when a delta module (partially) reverts the effect of a preceding delta module. We have implemented our approach within the SiPL framework and evaluated our family-based analysis using a realistic MBSPL known as Body Comfort System (BCS).;;;https://dl.acm.org/doi/10.1145/3461001.3471150;;;Software AND Engineering
High-Available Cloud Platform Based on OpenStack;;;['Jie Li', 'Tianxiang Zhang', 'Leixiao Li', 'Zefeng Kang', 'Tieming Niu', 'Jing Gao'];;;January 2022;;;ICCDE '22: Proceedings of the 2022 8th International Conference on Computing and Data Engineering;;;The availability of cloud services is an important performance index of cloud platform. It is the premise and basis for a cloud platform to provide services. Aiming at the problem of insufficient reliability of cloud services in university data centers, this paper proposes a high available and decentralized cloud platform scheme based on OpenStack for university micro data center. Firstly, the scheme sets the super fusion of the network layer and detects the state through URL location, which effectively avoids the single points of failure. And then, the database layer adopts multi-master design to realize the super redundant architecture and ensure the high availability. Finally, the reliability evaluation model and experiments show that the service availability of this scheme is very high.;;;https://dl.acm.org/doi/10.1145/3512850.3512853;;;Software AND Engineering
Experience report on soft and project skills building through repetition;;;['Xavier Devroey', 'Moussa Amrani', 'Benoît Vanderose'];;;August 2021;;;EASEAI 2021: Proceedings of the 3rd International Workshop on Education through Advanced Software Engineering and Artificial Intelligence;;;Acquiring soft and project skills during their studies is of paramount importance for computer science students to integrate large development teams after graduating. Project-oriented learning offers interesting opportunities for teachers to tutor students, and allows them to acquire and train those skills in addition to the core topics of the course. However, since most existing curricula require courses to be as independent as possible (for organizational reasons for instance), some topics are covered in different courses in slightly different ways. This repetition is interesting for understanding difficult notions appropriately, but may also hamper students' understanding when closely related concepts are embedded in different ways. We report here on our teaching approach: we propose a series of projects that share a common theme, in order to (i) provide a transversal understanding of common notions seen in separate courses, and (ii) introduce soft and project skills in a progressive way, enabling students to iteratively experience and learn skills that are necessary for professional life. We report on the results of interviews conducted with the students and extract valuable lessons for reproducing this approach in different curricula.;;;https://dl.acm.org/doi/10.1145/3472673.3473959;;;Software AND Engineering
Parallax Engine: Head Controlled Motion Parallax Using Notebooks’ RGB Camera;;;['Jarbas Jácome', 'Arlindo Gomes', 'Willams de Lima Costa', 'Lucas Silva Figueiredo', 'Jader Abreu', 'Luana Porciuncula', 'Pedro K. Brant', 'Luis E. M. Alves', 'Walter F M Correia', 'Veronica Teichrieb', 'Jonysberg P. Quintino', 'Fabio Q. B. da Silva', 'Andre L M Santos', 'Helder de Sousa Pinho'];;;October 2021;;;SVR'21: Symposium on Virtual and Augmented Reality;;;Research on the Fish Tank Virtual Reality (FTVR) technique commonly uses specific sensors (e.g. infrared cameras and LEDs on glasses) to estimate user’s eye position. However, estimating the face position with an RGB camera is becoming more accessible. In this work, we explore community available face characteristics detection software to implement the FTVR technique for everyday uses of 3D-enabled applications on consumer notebooks without requiring extra devices. We introduce the Parallax Engine solution that can be added with ease to any Unity game engine application. The solution supports two parallax-related visualization options: 1) a monoscopic FTVR mode (FishTank), which locks the virtual camera of the 3D environment to the laptop’s screen 2) and a 2D parallax mode (Parallax2DoF), which allows horizontal and vertical displacement of 3D scene camera. Regarding face characteristics detection techniques, the Parallax Engine uses a standardized interface that can receive input from different methods and currently supports three options: Google’s MediaPipe, dlib, and PoseNet. We evaluated the proposed solution with five users, performing tasks using different options for viewing and face characteristics detection, aiming to understand how suitable it is for end-users. Besides some detection failures from dlib, results showed an overall good acceptance for both the FishTank and Parallax2DoF visualization options.;;;https://dl.acm.org/doi/10.1145/3488162.3488218;;;Software AND Engineering
Hero: On the Chaos When PATH Meets Modules;;;['Ying Wang', 'Liang Qiao', 'Chang Xu', 'Yepang Liu', 'Shing-Chi Cheung', 'Na Meng', 'Hai Yu', 'Zhiliang Zhu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Ever since its first release in 2009, the Go programming language (Golang) has been well received by software communities. A major reason for its success is the powerful support of library-based development, where a Golang project can be conveniently built on top of other projects by referencing them as libraries. As Golang evolves, it recommends the use of a new library-referencing mode to overcome the limitations of the original one. While these two library modes are incompatible, both are supported by the Golang ecosystem. The heterogeneous use of library-referencing modes across Golang projects has caused numerous dependency management (DM) issues, incurring reference inconsistencies and even build failures. Motivated by the problem, we conducted an empirical study to characterize the DM issues, understand their root causes, and examine their fixing solutions. Based on our findings, we developed HERO, an automated technique to detect DM issues and suggest proper fixing solutions. We applied HERO to 19,000 popular Golang projects. The results showed that HERO achieved a high detection rate of 98.5% on a DM issue benchmark and found 2,422 new DM issues in 2,356 popular Golang projects. We reported 280 issues, among which 181 (64.6%) issues have been confirmed, and 160 of them (88.4%) have been fixed or are under fixing. Almost all the fixes have adopted our fixing suggestions.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00022;;;Software AND Engineering
Merging Live Video Feeds for Remote Monitoring of a Mining Machine;;;['Andrew T Flangas', 'Javad Sattarvand', 'Sergiu M Dascalu', 'Frederick C Harris'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;This research entails using virtual reality to interpret video recordings in Unity from cameras on an unmanned machine used for mining excavations. The purpose of using a machine of this nature is to send it into hazardous mining environments rather than sending workers and having their lives jeopardized. This work is significant because it demonstrates how two separate fields, such as virtual reality and robotics, can be combined to complete useful tasks. It also illustrates how machines can be used to replace workers in hazardous conditions not only in the field of mining, but in other fields as well. The main contribution of the work presented in this paper is the creation of a panorama of live video feeds captured by several webcams, which can be seen using a VR headset. As also described in the paper the software developed for this engineering application has been created using appropriate software engineering techniques and tools. Results of merging live video feeds and testing camera placements are also presented and planned directions of future work are outlined.;;;https://dl.acm.org/doi/10.1145/3501774.3501776;;;Software AND Engineering
CSonNet: an agent-based modeling software system for discrete time simulation;;;['Joshua D. Priest', 'Aparna Kishore', 'Lucas Machi', 'Chris J. Kuhlman', 'Dustin Machi', 'S. S. Ravi'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;Contagion dynamics on networks are used to study many problems, including disease and virus epidemics, incarceration, obesity, protests and rebellions, needle sharing in drug use, and hurricane and other natural disaster events. Simulators to study these problems range from smaller-scale serial codes to large-scale distributed systems. In recent years, Python-based simulation systems have been built. In this work, we describe a new Python-based agent-based simulator called CSonNet. It differs from codes such as Epidemics on Networks in that it performs discrete time simulations based on the graph dynamical systems formalism. CSonNet is a parallel code; it implements concurrency through an embarrassingly parallel approach of running multiple simulation instances on a user-specified number of forked processes. It has a modeling framework whereby agent models are composed using a set of pre-defined state transition rules. We provide strong-scaling performance results and case studies to illustrate its features.;;;https://dl.acm.org/doi/10.5555/3522802.3522809;;;Software AND Engineering
CLAD: A Deep Learning Framework for Continually Learning in Anomaly Detection;;;['Yulu Cao', 'Honglu Gan'];;;January 2022;;;ICSIM '22: Proceedings of the 2022 5th International Conference on Software Engineering and Information Management;;;The rapid development and frequent revolutions in information technology (like Edge Computing, Wireless Sensor Network) highlight the significance of Internet of Things. Nowadays, a variety of infrastructures from diverse fields are limited by external and internal environmental factors. In actual operation, these factors may cause serious anomalies and aggravate the burden of facilities’ maintenance. With a rise in the number and running time, the performance of these facilities would be unstable and complex. This paper proposes a deep learning framework (CLAD) to do adaptive anomaly detection. It implements dynamic anomaly thresholding based on the prediction of incremental Long Short-Term Memory. This framework employs a replay buffer to solve the decline of detection accuracy. With this framework, models can keep perfect detection accuracy under a quite high load (time and number). This framework is valuable for further research of adaptive anomaly detection.;;;https://dl.acm.org/doi/10.1145/3520084.3520109;;;Software AND Engineering
A lightweight framework for function name reassignment based on large-scale stripped binaries;;;['Han Gao', 'Shaoyin Cheng', 'Yinxing Xue', 'Weiming Zhang'];;;July 2021;;;ISSTA 2021: Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis;;;Software in the wild is usually released as stripped binaries that contain no debug information (e.g., function names). This paper studies the issue of reassigning descriptive names for functions to help facilitate reverse engineering. Since the essence of this issue is a data-driven prediction task, persuasive research should be based on sufficiently large-scale and diverse data. However, prior studies can only be based on small-scale datasets because their techniques suffer from heavyweight binary analysis, making them powerless in the face of big-size and large-scale binaries.   This paper presents the Neural Function Rename Engine (NFRE), a lightweight framework for function name reassignment that utilizes both sequential and structural information of assembly code. NFRE uses fine-grained and easily acquired features to model assembly code, making it more effective and efficient than existing techniques. In addition, we construct a large-scale dataset and present two data-preprocessing approaches to help improve its usability. Benefiting from the lightweight design, NFRE can be efficiently trained on the large-scale dataset, thereby having better generalization capability for unknown functions. The comparative experiments show that NFRE outperforms two existing techniques by a relative improvement of 32% and 16%, respectively, while the time cost for binary analysis is much less.;;;https://dl.acm.org/doi/10.1145/3460319.3464804;;;Software AND Engineering
Trusted blockchain of ring signature in TEE environment;;;['LuWei Bao', 'GeHao Lu', 'LiYu Fu'];;;February 2022;;;ASSE' 22: 2022 3rd Asia Service Sciences and Software Engineering Conference;;;Traditional blockchain system has two problems: poor privacy protection and scalability. The public chain discloses all information, which can be seen by every node. The code of smart contract is clear-text, and the data is also clear-text. Every node in the public chain is untrustworthy, so it is necessary to design a complex consistency protocol, which often leads to poor performance (low TPS), waste of power, or lower overall credibility. TEE can construct a trusted execution environment Enclave (safe house), which is similar to a black box, the outside cannot access the inside, and it can allow the outside to authenticate the inside reliably through remote authentication. This paper focuses on how to integrate Intel SGX and ring signature algorithm into traditional blockchain to realize privacy calculation and transaction. To protect the anonymity of traders and to process trusted privacy calculation under the chain. Through the cooperation between on the chain and off the chain, "calculation" and "settlement" are completely decoupled, thus solving the performance bottleneck and privacy problems of traditional smart contracts.;;;https://dl.acm.org/doi/10.1145/3523181.3523183;;;Software AND Engineering
PyExplainer: explaining the predictions of just-in-time defect models;;;['Chanathip Pornprasit', 'Chakkrit Tantithamthavorn', 'Jirayus Jiarpakdee', 'Michael Fu', 'Patanamon Thongtanunam'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Just-In-Time (JIT) defect prediction (i.e., an AI/ML model to predict defect-introducing commits) is proposed to help developers prioritize their limited Software Quality Assurance (SQA) resources on the most risky commits. However, the explainability of JIT defect models remains largely unexplored (i.e., practitioners still do not know why a commit is predicted as defect-introducing). Recently, LIME has been used to generate explanations for any AI/ML models. However, the random perturbation approach used by LIME to generate synthetic neighbors is still suboptimal, i.e., generating synthetic neighbors that may not be similar to an instance to be explained, producing low accuracy of the local models, leading to inaccurate explanations for just-in-time defect models. In this paper, we propose PyExplainer---i.e., a local rule-based model-agnostic technique for generating explanations (i.e., why a commit is predicted as defective) of JIT defect models. Through a case study of two open-source software projects, we find that our PyExplainer produces (1) synthetic neighbors that are 41%-45% more similar to an instance to be explained; (2) 18%-38% more accurate local models; and (3) explanations that are 69%-98% more unique and 17%-54% more consistent with the actual characteristics of defect-introducing commits in the future than LIME (a state-of-the-art model-agnostic technique). This could help practitioners focus on the most important aspects of the commits to mitigate the risk of being defect-introducing. Thus, the contributions of this paper build an important step towards Explainable AI for Software Engineering, making software analytics more explainable and actionable. Finally, we publish our PyExplainer as a Python package to support practitioners and researchers (https://github.com/awsm-research/PyExplainer).;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678763;;;Software AND Engineering
Evolving Delta-Oriented Product Lines: A Case Study on Feature Interaction, Safe and Partially Safe Evolution;;;['Leomar Camargo', 'Luisa Fantin', 'Gabriel Lobão', 'Thiago Figueiredo', 'Rodrigo Bonifacio', 'Karine Gomes', 'Leopoldo Teixeira'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software product line engineering is a well-known approach for building a set of configurable systems for a specific domain, and different techniques have been used to manage product line variability, including source-code preprocessing, aspect-oriented programming (AOP), and delta-oriented programming (DOP). Although existing studies have explored the design and evolution of product lines using techniques such as source-code preprocessing and AOP, little is known about the practical implications of using DOP to bootstrap and evolve software product lines. In this paper we address this issue, reporting our experience of using DeltaJ to implement two product lines (Reminder-PL and Iris-PL). This experience covers different scenarios of evolution (such as the inclusion of mandatory, optional, and alternative features) that indeed led to several feature interactions. Altogether, this work brings several contributions, including evidence that existing templates for safe and partially safe evolution of product lines can also help developers to evolve delta-oriented SPLs—although we revealed the need for two additional templates for safe evolution. Also, we present a description of the feature interactions that appeared during the evolution of both product lines and how we modularized these interactions using DOP constructs.;;;https://dl.acm.org/doi/10.1145/3474624.3474645;;;Software AND Engineering
A novel technique for control flow obfuscation in JVM applications using InvokeDynamic with native bootstrapping;;;['Bradley Wood', 'Akramul Azim'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Protecting the intellectual property of end-user software is a challenging industry problem. Modern obfuscation techniques aim to prevent reverse engineering and unauthorized use or modification to software. Obfuscation algorithms are especially necessary in JVM applications due to the large amount of contextual information stored in JVM bytecode. However, many commercial-grade obfuscation methods can be easily be undone by deobfuscation software such that it can later be decompiled and refactored for illegitimate use. In this paper, we propose a method of control flow obfuscation using the InvokeDynamic instruction with native call site bootstrapping. The proposed method prevents JVM byte-code from leaking call site information in function invocations. We evaluate the proposed technique against a series of benchmarks comparing original software with its obfuscated form. To this end, we observe an insignificant difference in application running time.;;;https://dl.acm.org/doi/10.5555/3507788.3507824;;;Software AND Engineering
Genetic Improvement of Data for Maths Functions;;;['William B. Langdon', 'Oliver Krauss'];;;None;;;ACM Transactions on Evolutionary Learning and Optimization;;;We use continuous optimisation and manual code changes to evolve up to 1024 Newton-Raphson numerical values embedded in an open source GNU C library glibc square root sqrt to implement a double precision cube root routine cbrt, binary logarithm log2 and reciprocal square root function for C in seconds. The GI inverted square root x
-1/2 is far more accurate than Quake’s InvSqrt, Quare root. GI shows potential for automatically creating mobile or low resource mote smart dust bespoke custom mathematical libraries with new functionality.;;;https://dl.acm.org/doi/10.1145/3461016;;;Software AND Engineering
LCW: A Lightweight Recommendation Framework for Non-profit Crowdfunding Projects;;;['Jinxin Liu', 'Yingyuan Xiao', 'Wenguang Zheng'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;In recent years, crowdfunding platform has gradually emerged as a new economic model, and more and more people choose crowdfunding to obtain the initial funds needed by the project. However, with the increasing number of projects, it is difficult for sponsors to find suitable projects they want to invest in. Therefore, it is very important to build an efficient recommendation system on the crowdfunding platform. Different from previous crowdfunding recommendation systems designed to improve returns, this paper designs a lightweight recommendation framework LCW for non-profit crowdfunding platforms. A large number of experiments on real kiva data sets have proved the effectiveness of this method and it obtains the SOTA results.;;;https://dl.acm.org/doi/10.1145/3494885.3494928;;;Software AND Engineering
Enabling Collaborative Data Science Development with the Ballet Framework;;;['Micah J. Smith', 'Jürgen Cito', 'Kelvin Lu', 'Kalyan Veeramachaneni'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;While the open-source software development model has led to successful large-scale collaborations in building software systems, data science projects are frequently developed by individuals or small teams. We describe challenges to scaling data science collaborations and present a conceptual framework and ML programming model to address them. We instantiate these ideas in Ballet, the first lightweight framework for collaborative, open-source data science through a focus on feature engineering, and an accompanying cloud-based development environment. Using our framework, collaborators incrementally propose feature definitions to a repository which are each subjected to software and ML performance validation and can be automatically merged into an executable feature engineering pipeline. We leverage Ballet to conduct a case study analysis of an income prediction problem with 27 collaborators, and discuss implications for future designers of collaborative projects.;;;https://dl.acm.org/doi/10.1145/3479575;;;Software AND Engineering
LS-sampling: an effective local search based sampling approach for achieving high t-wise coverage;;;['Chuan Luo', 'Binqi Sun', 'Bo Qiao', 'Junjie Chen', 'Hongyu Zhang', 'Jinkun Lin', 'Qingwei Lin', 'Dongmei Zhang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;There has been a rapidly increasing demand for developing highly configurable software systems, which urgently calls for effective testing methods. In practice, t-wise coverage has been widely recognized as a useful metric to evaluate the quality of a test suite for testing highly configurable software systems, and achieving high t-wise coverage is important for ensuring test adequacy. However, state-of-the-art methods usually cost a fairly long time to generate large test suites for high pairwise coverage (i.e., 2-wise coverage), which would lead to ineffective and inefficient testing of highly configurable software systems. In this paper, we propose a novel local search based sampling approach dubbed LS-Sampling for achieving high t-wise coverage. Extensive experiments on a large number of public benchmarks, which are collected from real-world, highly configurable software systems, show that LS-Sampling achieves higher 2-wise and 3-wise coverage than the current state of the art. LS-Sampling is effective, since on average it achieves the 2-wise coverage of 99.64% and the 3-wise coverage of 97.87% through generating a small test suite consisting of only 100 test cases (90% smaller than the test suites generated by its state-of-the-art competitors). Furthermore, LS-Sampling is efficient, since it only requires an average execution time of less than one minute to generate a test suite with high 2-wise and 3-wise coverage.;;;https://dl.acm.org/doi/10.1145/3468264.3468622;;;Software AND Engineering
LifeStream: a high-performance stream processing engine for periodic streams;;;['Anand Jayarajan', 'Kimberly Hau', 'Andrew Goodwin', 'Gennady Pekhimenko'];;;April 2021;;;ASPLOS '21: Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Hospitals around the world collect massive amounts of physiological data from their patients every day. Recently, there has been an increase in research interest to subject this data to statistical analysis to gain more insights and provide improved medical diagnoses. Such analyses require complex computations on large volumes of data, demanding efficient data processing systems. This paper shows that currently available data processing solutions either fail to meet the performance requirements or lack simple and flexible programming interfaces. To address this problem, we propose LifeStream, a high-performance stream processing engine for physiological data. LifeStream hits the sweet spot between ease of programming by providing a rich temporal query language support and performance by employing optimizations that exploit the periodic nature of physiological data. We demonstrate that LifeStream achieves end-to-end performance up to 7.5× higher than state-of-the-art streaming engines and 3.2× than hand-optimized numerical libraries on real-world datasets and workloads.;;;https://dl.acm.org/doi/10.1145/3445814.3446725;;;Software AND Engineering
Multi-criteria Web Services Selection: Balancing the Quality of Design and Quality of Service;;;['Marwa Daaji', 'Ali Ouni', 'Mohamed Mohsen Gammoudi', 'Salah Bouktif', 'Mohamed Wiem Mkaouer'];;;None;;;ACM Transactions on Internet Technology;;;Web service composition allows developers to create applications via reusing available services that are interoperable to each other. The process of selecting relevant Web services for a composite service satisfying the developer requirements is commonly acknowledged to be hard and challenging, especially with the exponentially increasing number of available Web services on the Internet. The majority of existing approaches on Web Services Selection are merely based on the Quality of Service (QoS) as a basic criterion to guide the selection process. However, existing approaches tend to ignore the service design quality, which plays a crucial role in discovering, understanding, and reusing service functionalities. Indeed, poorly designed Web service interfaces result in service anti-patterns, which are symptoms of bad design and implementation practices. The existence of anti-pattern instances in Web service interfaces typically complicates their reuse in real-world service-based systems and may lead to several maintenance and evolution problems. To address this issue, we introduce a new approach based on the Multi-Objective and Optimization on the basis of Ratio Analysis method (MOORA) as a multi-criteria decision making (MCDM) method to select Web services based on a combination of their (1) QoS attributes and (2) QoS design. The proposed approach aims to help developers to maintain the soundness and quality of their service composite development processes. We conduct a quantitative and qualitative empirical study to evaluate our approach on a Quality of Web Service dataset. We compare our MOORA-based approach against four commonly used MCDM methods as well as a recent state-of-the-art Web service selection approach. The obtained results show that our approach outperforms state-of-the-art approaches by significantly improving the service selection quality of top-k selected services while providing the best trade-off between both service design quality and desired QoS values. Furthermore, we conducted a qualitative evaluation with developers. The obtained results provide evidence that our approach generates a good trade-off for what developers need regarding both QoS and quality of design. Our selection approach was evaluated as “relevant” from developers point of view, in improving the service selection task with an average score of 3.93, compared to an average of 2.62 for the traditional QoS-based approach.;;;https://dl.acm.org/doi/10.1145/3446388;;;Software AND Engineering
ANISMA: A Prototyping Toolkit to Explore Haptic Skin Deformation Applications Using Shape-Memory Alloys;;;['Moritz Alexander Messerschmidt', 'Sachith Muthukumarana', 'Nur Al-Huda Hamdan', 'Adrian Wagner', 'Haimo Zhang', 'Jan Borchers', 'Suranga Chandima Nanayakkara'];;;None;;;ACM Transactions on Computer-Human Interaction;;;We present ANISMA, a software and hardware toolkit to prototype on-skin haptic devices that generate skin deformation stimuli like pressure, stretch, and motion using shape-memory alloys (SMAs). Our toolkit embeds expert knowledge that makes SMA spring actuators more accessible to human–computer interaction (HCI) researchers. Using our software tool, users can design different actuator layouts, program their spatio-temporal actuation and preview the resulting deformation behavior to verify a design at an early stage. Our toolkit allows exporting the actuator layout and 3D printing it directly on skin adhesive. To test different actuation sequences on the skin, a user can connect the SMA actuators to our customized driver board and reprogram them using our visual programming interface. We report a technical analysis, verify the perceptibility of essential ANISMA skin deformation devices with 8 participants, and evaluate ANISMA regarding its usability and supported creativity with 12 HCI researchers in a creative design task.;;;https://dl.acm.org/doi/10.1145/3490497;;;Software AND Engineering
A Systematic Literature Review on Test Case Prioritization in Combinatorial Testing;;;['Muhammad Syafiq Abdul Manan', 'Dayang Norhayati Abang Jawawi', 'Johanna Ahmad'];;;September 2021;;;ICACS '21: Proceedings of the 5th International Conference on Algorithms, Computing and Systems;;;In recent years, regression testing is widely used and performed in industries during the maintenance phase of software system development. The increases of software regression test cases resulted in a higher complexity of the software system, due to the rapid change in the software development. Thus, many researchers had proposed the test cases prioritisation technique to overcome the raised issues. However, most of the applications needed the combinatorial testing due to the enormous size of the software inputs. The problem arises when the small t-way values were selected in combinatorial testing, which resulted in the ineffectiveness of the fault detection ability. This work presents the results of a systematic literature review on the test case prioritisation and combinatorial testing that report the main approach, problems, and evaluation metric that were being used from existing studies. This paper aims to identify the aspects of the test case prioritisation and combinatorial testing that have been studied before, provide a basis for the improvement, and evaluate the current trends of this research area. Apart from the recent works that were published in the last ten years, 20 papers were selected for further study in the systematic literature review. The results show that this area of study is open for improvement especially to efficiently generate the test cases, which minimise the number of test cases generated, and effectively prioritise the test cases that increase the fault detection ability in software testing. However, the use of both techniques still needs more enhancements for the existing proposed approach that could result in the increasing of the fault detection ability.;;;https://dl.acm.org/doi/10.1145/3490700.3490710;;;Software AND Engineering
REMOT: A Hardware-Software Architecture for Attention-Guided Multi-Object Tracking with Dynamic Vision Sensors on FPGAs;;;['Yizhao Gao', 'Song Wang', 'Hayden Kwok-Hay So'];;;February 2022;;;FPGA '22: Proceedings of the 2022 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays;;;In contrast to conventional vision sensors that produce images of the entire field-of-view at a fixed frame rate, dynamic vision sensors (DVS) are neuromorphic devices that only produce sparse events in response to changes in light intensity local to each pixel, making them promising technologies for use in demanding edge scenarios where energy-efficient intelligent computations are needed. While several early research have demonstrated promising results in performing high-level machine vision tasks using vision events only, these algorithms are often too complex for real-time deployments in edge systems with limited processing and storage capabilities. In this work, a novel hardware-software architecture, called REMOT, is proposed to leverage the unique properties of DVS to perform real-time multi-object tracking (MOT) on FPGAs. REMOT incorporates a parallel set of reconfigurable hardware attention units (AUs) that work in tandem with a modular attention-guided software framework running in the attached processor. Each hardware AU autonomously adjusts its region of attention by processing each vision event as they are produced by the DVS. Using information aggregated by the AUs, high-level analyses are performed in software. To demonstrate the flexibility and modularity of REMOT, a family of MOT algorithms with different hardware-software configurations and tradeoffs have been implemented on 2 different edge reconfigurable systems. Experimental results show that REMOT is capable of processing 0.43-2.22 million events per second at 1.75-5.68 watts, making them suitable for real-time operations while maintaining good MOT accuracy in our target datasets. When compared with a software-only implementation using the same edge platforms, our HW-SW implementation results in up to 33.6 times higher event processing throughput and 25.9 times higher power efficiency.;;;https://dl.acm.org/doi/10.1145/3490422.3502365;;;Software AND Engineering
What Evidence We Would Miss If We Do Not Use Grey Literature?;;;['Fernando Kamei', 'Gustavo Pinto', 'Igor Wiese', 'Márcio Ribeiro', 'Sérgio Soares'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Context: Multivocal Literature Reviews (MLR) search for evidence in both Traditional Literature (TL) and Grey Literature (GL). Despite the growing interest in MLR-based studies, the literature assessing how GL has contributed to MLR studies is still scarce. Objective: This research aims to assess how the use of GL contributed to MLR studies. By contributing, we mean, understanding to what extent GL is providing evidence that is indeed used by an MLR to answer its research question. Method: We start by conducting a tertiary study to identify MLR studies published between 2017 and 2019, selecting nine of them. We then identified the GL used in these studies and assessed to what extent the GLs are providing evidence that help these studies to answer their research questions. Results: Our analysis identified that 1) GL provided evidence not found in TL, 2) most of the GL sources were used to provide recommendations to solve problems, explain a topic, and classify the findings, and 3) 19 different GL types were used in the studies; these GLs were mainly produced by SE practitioners (including blog posts, slides presentations, or project descriptions). Conclusions: We evidence how GL contributed to MLR studies. We observed that if these GLs were not included in the MLR, several findings would have been omitted or weakened. We also described the challenges involved when conducting this investigation, along with potential ways to deal with them, which may help future SE researchers.;;;https://dl.acm.org/doi/10.1145/3475716.3475777;;;Software AND Engineering
Estimating residual risk in greybox fuzzing;;;['Marcel Böhme', 'Danushka Liyanage', 'Valentin Wüstholz'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;For any errorless fuzzing campaign, no matter how long, there is always some residual risk that a software error would be discovered if only the campaign was run for just a bit longer. Recently, greybox fuzzing tools have found widespread adoption. Yet, practitioners can only guess when the residual risk of a greybox fuzzing campaign falls below a specific, maximum allowable threshold.  In this paper, we explain why residual risk cannot be directly estimated for greybox campaigns, argue that the discovery probability (i.e., the probability that the next generated input increases code coverage) provides an excellent upper bound, and explore sound statistical methods to estimate the discovery probability in an ongoing greybox campaign. We find that estimators for blackbox fuzzing systematically and substantially under-estimate the true risk. An engineer—who stops the campaign when the estimators purport a risk below the maximum allowable risk—is vastly misled. She might need execute a campaign that is orders of magnitude longer to achieve the allowable risk. Hence, the key challenge we address in this paper is adaptive bias: The probability to discover a specific error actually increases over time. We provide the first probabilistic analysis of adaptive bias, and introduce two novel classes of estimators that tackle adaptive bias. With our estimators, the engineer can decide with confidence when to abort the campaign.;;;https://dl.acm.org/doi/10.1145/3468264.3468570;;;Software AND Engineering
Mimicry: Genetic-algorithm-based Real-time System of Virtual Insects in a Living Environment-A New and Altered Nature;;;['Ziwei Wu', 'Lingdong Huang'];;;None;;;Proceedings of the ACM on Computer Graphics and Interactive Techniques;;;The authors have collaborated on a machine learning multiscreen video installation powered by computer algorithms and inspired by mimicry in the natural world. The artwork explores a pseudo-environment loop system in nature and artificial mechanical organisms combining living flowers with projectors, webcams, and computer monitors. Technically, the software adopts a genetic algorithm to simulate the process of mimicry; conceptually, this real-time art installation is in conversation with Nam June Paik's piece TV Garden. The project explores the possibilities of integrating artificial intelligence and nature in the landscape of the future.;;;https://dl.acm.org/doi/10.1145/3465615;;;Software AND Engineering
CodeShovel: a reusable and available tool for extracting source code histories;;;['Felix Grund', 'Shaiful Chowdhury', 'Nick C. Bradley', 'Braxton Hall', 'Reid Holmes'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Being able to accurately understand how source code evolved is fundamentally important for both software engineers and researchers. Our ICSE 2021 Research Paper CodeShovel: Constructing Method-Level Source Code Histories describes a novel approach for quickly uncovering these method histories. The approach, codified in the CodeShovel tool, is available for researchers and practitioners alike to use and extend. It is available both as a public web service that can be used interactively or through a REST API and as a stand-alone Java component. This document details how to install and use CodeShovel, although all pertinent details are available online enabling CodeShovel to be reused as desired.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00100;;;Software AND Engineering
hIPPYlib: An Extensible Software Framework for Large-Scale Inverse Problems Governed by PDEs: Part I: Deterministic Inversion and Linearized Bayesian Inference;;;['Umberto Villa', 'Noemi Petra', 'Omar Ghattas'];;;None;;;ACM Transactions on Mathematical Software;;;We present an extensible software framework, hIPPYlib, for solution of large-scale deterministic and Bayesian inverse problems governed by partial differential equations (PDEs) with (possibly) infinite-dimensional parameter fields (which are high-dimensional after discretization). hIPPYlib overcomes the prohibitively expensive nature of Bayesian inversion for this class of problems by implementing state-of-the-art scalable algorithms for PDE-based inverse problems that exploit the structure of the underlying operators, notably the Hessian of the log-posterior. The key property of the algorithms implemented in hIPPYlib is that the solution of the inverse problem is computed at a cost, measured in linearized forward PDE solves, that is independent of the parameter dimension. The mean of the posterior is approximated by the MAP point, which is found by minimizing the negative log-posterior with an inexact matrix-free Newton-CG method. The posterior covariance is approximated by the inverse of the Hessian of the negative log posterior evaluated at the MAP point. The construction of the posterior covariance is made tractable by invoking a low-rank approximation of the Hessian of the log-likelihood. Scalable tools for sample generation are also discussed. hIPPYlib makes all of these advanced algorithms easily accessible to domain scientists and provides an environment that expedites the development of new algorithms.;;;https://dl.acm.org/doi/10.1145/3428447;;;Software AND Engineering
DABT: A Dependency-aware Bug Triaging Method;;;['Hadi Jahanshahi', 'Kritika Chhabra', 'Mucahit Cevik', 'Ayþe Baþar'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;In software engineering practice, fixing a bug promptly reduces the associated costs. On the other hand, the manual bug fixing process can be time-consuming, cumbersome, and error-prone. In this work, we introduce a bug triaging method, called Dependency-aware Bug Triaging (DABT), which leverages natural language processing and integer programming to assign bugs to appropriate developers. Unlike previous works that mainly focus on one aspect of the bug reports, DABT considers the textual information, cost associated with each bug, and dependency among them. Therefore, this comprehensive formulation covers the most important aspect of the previous works while considering the blocking effect of the bugs. We report the performance of the algorithm on three open-source software systems, i.e., EclipseJDT, LibreOffice, and Mozilla. Our result shows that DABT is able to reduce the number of overdue bugs up to 12%. It also decreases the average fixing time of the bugs by half. Moreover, it reduces the complexity of the bug dependency graph by prioritizing blocking bugs.;;;https://dl.acm.org/doi/10.1145/3463274.3463342;;;Software AND Engineering
ISPY: automatic issue-solution pair extraction from community live chats;;;['Lin Shi', 'Ziyou Jiang', 'Ye Yang', 'Xiao Chen', 'Yumin Zhang', 'Fangwen Mu', 'Hanzhi Jiang', 'Qing Wang'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Collaborative live chats are gaining popularity as a development communication tool. In community live chatting, developers are likely to post issues they encountered (e.g., setup issues and compile issues), and other developers respond with possible solutions. Therefore, community live chats contain rich sets of information for reported issues and their corresponding solutions, which can be quite useful for knowledge sharing and future reuse if extracted and restored in time. However, it remains challenging to accurately mine such knowledge due to the noisy nature of interleaved dialogs in live chat data. In this paper, we first formulate the problem of issue-solution pair extraction from developer live chat data, and propose an automated approach, named ISPY, based on natural language processing and deep learning techniques with customized enhancements, to address the problem. Specifically, ISPY automates three tasks: 1) Disentangle live chat logs, employing a feedforward neural network to disentangle a conversation history into separate dialogs automatically; 2) Detect dialogs discussing issues, using a novel convolutional neural network (CNN), which consists of a BERT-based utterance embedding layer, a context-aware dialog embedding layer, and an output layer; 3) Extract appropriate utterances and combine them as corresponding solutions, based on the same CNN structure but with different feeding inputs. To evaluate ISPY, we compare it with six baselines, utilizing a dataset with 750 dialogs including 171 issue-solution pairs and evaluate ISPY from eight open source communities. The results show that, for issue-detection, our approach achieves the F1 of 76%, and outperforms all baselines by 30%. Our approach achieves the F1 of 63% for solution-extraction and outperforms the baselines by 20%. Furthermore, we apply ISPY on three new communities to extensively evaluate ISPY's practical usage. Moreover, we publish over 30K issue-solution pairs extracted from 11 communities. We believe that ISPY can facilitate community-based software development by promoting knowledge sharing and shortening the issue-resolving process.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678894;;;Software AND Engineering
AutoCCAG: An Automated Approach to Constrained Covering Array Generation;;;['Chuan Luo', 'Jinkun Lin', 'Shaowei Cai', 'Xin Chen', 'Bing He', 'Bo Qiao', 'Pu Zhao', 'Qingwei Lin', 'Hongyu Zhang', 'Wei Wu', 'Saravanakumar Rajmohan', 'Dongmei Zhang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Combinatorial interaction testing (CIT) is an important technique for testing highly configurable software systems with demonstrated effectiveness in practice. The goal of CIT is to generate test cases covering the interactions of configuration options, under certain hard constraints. In this context, constrained covering arrays (CCAs) are frequently used as test cases in CIT. Constrained Covering Array Generation (CCAG) is an NP-hard combinatorial optimization problem, solving which requires an effective method for generating small CCAs. In particular, effectively solving t-way CCAG with t ≥ 4 is even more challenging. Inspired by the success of automated algorithm configuration and automated algorithm selection in solving combinatorial optimization problems, in this paper, we investigate the efficacy of automated algorithm configuration and automated algorithm selection for the CCAG problem, and propose a novel, automated CCAG approach called AutoCCAG. Extensive experiments on public benchmarks show that AutoCCAG can find much smaller-sized CCAs than current state-of-the-art approaches, indicating the effectiveness of AutoCCAG. More encouragingly, to our best knowledge, our paper reports the first results for CCAG with a high coverage strength (i.e., 5-way CCAG) on public benchmarks. Our results demonstrate that AutoCCAG can bring considerable benefits in testing highly configurable software systems.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00030;;;Software AND Engineering
DeepHyperion: exploring the feature space of deep learning-based systems through illumination search;;;['Tahereh Zohdinasab', 'Vincenzo Riccio', 'Alessio Gambi', 'Paolo Tonella'];;;July 2021;;;ISSTA 2021: Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis;;;Deep Learning (DL) has been successfully applied to a wide range of application domains, including safety-critical ones. Several DL testing approaches have been recently proposed in the literature but none of them aims to assess how different interpretable features of the generated inputs affect the system's behaviour.   In this paper, we resort to Illumination Search to find the highest-performing test cases (i.e., misbehaving and closest to misbehaving), spread across the cells of a map representing the feature space of the system. We introduce a methodology that guides the users of our approach in the tasks of identifying and quantifying the dimensions of the feature space for a given domain. We developed DeepHyperion, a search-based tool for DL systems that illuminates, i.e., explores at large, the feature space, by providing developers with an interpretable feature map where automatically generated inputs are placed along with information about the exposed behaviours.;;;https://dl.acm.org/doi/10.1145/3460319.3464811;;;Software AND Engineering
Bounded Exhaustive Search of Alloy Specification Repairs;;;['Simón Gutiérrez Brida', 'Germán Regis', 'Guolong Zheng', 'Hamid Bagheri', 'ThanhVu Nguyen', 'Nazareno Aguirre', 'Marcelo Frias'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The rising popularity of declarative languages and the hard to debug nature thereof have motivated the need for applicable, automated repair techniques for such languages. However, despite significant advances in the program repair of imperative languages, there is a dearth of repair techniques for declarative languages. This paper presents BeAFix, an automated repair technique for faulty models written in Alloy, a declarative language based on first-order relational logic. BeAFix is backed with a novel strategy for bounded exhaustive, yet scalable, exploration of the spaces of fix candidates and a formally rigorous, sound pruning of such spaces. Moreover, different from the state-of-the-art in Alloy automated repair, that relies on the availability of unit tests, BeAFix does not require tests and can work with assertions that are naturally used in formal declarative languages. Our experience with using BeAFix to repair thousands of real-world faulty models, collected by other researchers, corroborates its ability to effectively generate correct repairs and outperform the state-of-the-art.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00105;;;Software AND Engineering
Land of the lost: privacy patterns' forgotten properties: enhancing selection-support for privacy patterns;;;["Ala'a Al-Momani", 'Kim Wuyts', 'Laurens Sion', 'Frank Kargl', 'Wouter Joosen', 'Benjamin Erb', 'Christoph Bösch'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;Privacy patterns describe core aspects of privacy-enhancing solutions to recurring problems and can, therefore, be instrumental to the privacy-by-design paradigm. However, the privacy patterns domain is still evolving. While the main focus is currently put on compiling and structuring high-quality privacy patterns in catalogs, the support for developers to select suitable privacy patterns is still limited. Privacy patterns selection-support means, in essence, the quick and easy scoping of a collection of patterns to the most applicable ones based on a set of predefined criteria. To evaluate patterns against these criteria, a thorough understanding of the privacy patterns landscape is required. In this paper, (i) we show that there is currently a lack of extensive support for privacy patterns selection due to the insufficient understanding of pattern properties, (ii) we propose additional properties that need to be analyzed and can serve as a first step towards a robust selection criteria, (iii) we analyze and present the properties for 70 privacy patterns, and (iv) we discuss a potential approach of how such a selection-support method can be realized.;;;https://dl.acm.org/doi/10.1145/3412841.3441996;;;Software AND Engineering
flack: Counterexample-Guided Fault Localization for Alloy Models;;;['Guolong Zheng', 'ThanhVu Nguyen', 'Simón Gutiérrez Brida', 'Germán Regis', 'Marcelo F. Frias', 'Nazareno Aguirre', 'Hamid Bagheri'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Fault localization is a practical research topic that helps developers identify code locations that might cause bugs in a program. Most existing fault localization techniques are designed for imperative programs (e.g., C and Java) and rely on analyzing correct and incorrect executions of the program to identify suspicious statements. In this work, we introduce a fault localization approach for models written in a declarative language, where the models are not "executed," but rather converted into a logical formula and solved using backend constraint solvers. We present FLACK, a tool that takes as input an Alloy model consisting of some violated assertion and returns a ranked list of suspicious expressions contributing to the assertion violation. The key idea is to analyze the differences between counterexamples, i.e., instances of the model that do not satisfy the assertion, and instances that do satisfy the assertion to find suspicious expressions in the input model. The experimental results show that FLACK is efficient (can handle complex, real-world Alloy models with thousand lines of code within 5 seconds), accurate (can consistently rank buggy expressions in the top 1.9% of the suspicious list), and useful (can often narrow down the error to the exact location within the suspicious expressions).;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00065;;;Software AND Engineering
Research on application development and implementation method based on "Platform +APP" mode;;;['Yang Xie', 'Guiyu Tian', 'Yizheng Tao', 'Gongliang Li', 'Qian Hu'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;With the rise of the Internet, Internet software process methods have been introduced into the field of enterprise informatization, hoping to adapt to the rapid change of business and deliver value quickly. However, the requirements of enterprise informatization on software quality and security are usually ignored, which makes the software insufficient to solve the problems that enterprises pay more attention to, such as business complexity and consistency. At present, enterprise digital transformation and upgrading needs to simultaneously solve the problems of complexity, consistency, variability and invisibility, and efficiently deliver high quality, high security software to realize business value. Focusing on this demand, this paper analyzes and studies software process methods such as software engineering quality system management, safety software development life cycle and Devops method, and puts forward the "four-stages and twelve-nodes" software development and implementation method based on "Platform +APP" mode. This method carries out APP research and development activities and manages the software development process based on the common capabilities provided by the Cloud platform based on the Internet mode. The overall idea of "big agility, small waterfall" is adopted to give consideration to reliability, security and development efficiency. This method has been applied to the application system construction of the digital transformation of a large enterprise, and the practice proves that this method can take into account the reliability, security and variability of software, and the improvement of software batch supply ability is remarkable.;;;https://dl.acm.org/doi/10.1145/3501409.3501533;;;Software AND Engineering
Rule-Based Expert System for Diagnosing Common Childhood Illnesses: Smartphone App to Assist in Curbing the Spread of COVID-19;;;['Eiman M. Saleh', 'Salwa Elakeili', 'Omar Sallabi', 'Howayda Elmajpri'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;Since the World Health Organization declared the COVID-19 outbreak a global pandemic, constraints on face-to-face clinical consultation have become more challenging to implement in healthcare institutions. In common childhood illnesses, inexperienced parents may have difficulties determining whether a child is in a severe condition that requires hospitalization, thus increasing the risk of catching the Coronavirus. During the current COVID-19 pandemic, information technologies play a significant role in maintaining social distancing, such as telemedicine applications. Developing expert systems using Artificial Intelligence techniques can substitute experts (doctors) for remote patient consultation and care in the medical field. This paper discusses the design and implementation of a Rule-Base Expert system based on a mobile application on the Android platform, a healthcare expert system for diagnosing common childhood illnesses. The proposed application acts as an intelligent medical assistant, providing remote medical consultations and detecting emergencies for pediatric patients undergoing treatment in areas where medical services are limited or curfew. The proposed application asks a series of questions regarding a group of frequent symptoms in children's diseases, the inference engine generates instant recommendations for performing specific basic medical treatment steps when necessary. The proposed approach is applicable, effective, and efficient when comparing the application's diagnostic results with a physician's diagnosis on pediatric patients.;;;https://dl.acm.org/doi/10.1145/3492547.3492609;;;Software AND Engineering
What Makes a Great Maintainer of Open Source Projects?;;;['Edson Dias', 'Paulo Meirelles', 'Fernando Castor', 'Igor Steinmacher', 'Igor Wiese', 'Gustavo Pinto'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Although Open Source Software (OSS) maintainers devote a significant proportion of their work to coding tasks, great maintainers must excel in many other activities beyond coding. Maintainers should care about fostering a community, helping new members to find their place, while also saying "no" to patches that although are well-coded and well-tested, do not contribute to the goal of the project. To perform all these activities masterfully, maintainers should exercise attributes that software engineers (working on closed source projects) do not always need to master. This paper aims to uncover, relate, and prioritize the unique attributes that great OSS maintainers might have. To achieve this goal, we conducted 33 semi-structured interviews with well-experienced maintainers that are the gatekeepers of notable projects such as the Linux Kernel, the Debian operating system, and the GitLab coding platform. After we analyzed the interviews and curated a list of attributes, we created a conceptual framework to explain how these attributes are connected. We then conducted a rating survey with 90 OSS contributors. We noted that "technical excellence" and "communication" are the most recurring attributes. When grouped, these attributes fit into four broad categories: management, social, technical, and personality. While we noted that "sustain a long term vision of the project" and being "extremely careful" seem to form the basis of our framework, we noted through our survey that the communication attribute was perceived as the most essential one.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00093;;;Software AND Engineering
Are we speaking the industry language? The practice and literature of modernizing legacy systems with microservices;;;['Thelma Colanzi', 'Aline Amaral', 'Wesley Assunção', 'Arthur Zavadski', 'Douglas Tanno', 'Alessandro Garcia', 'Carlos Lucena'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;Microservice architecture has gained much attention in the last few years in both industry and academia. Microservice is an architectural style that enables developing systems as a suite of small loosely coupled, and autonomous (micro)services that encapsulate business capabilities and communicate with each other using language-agnostic APIs. Despite the microservice adoption for modernizing legacy systems, few studies investigate how microservices are used in practice. Furthermore, the literature still scarce on presenting studies on why and how the modernization is conducted in practice in comparison to existing literature on the subject. Thus, our goal is to investigate if industry and academy are speaking the same language concerning the modernization of legacy systems with microservices, by means of a rigorous study on the use of microservices in the industry. For doing so, we design a survey to understand the state of practice from the perspective of a modernization process roadmap derived from the literature. In this paper, we report the results of a survey with 56 software companies, from which 35 (63.6%) adopt the microservice architecture in their legacy systems. Results pointed out the most expected benefits that drive the migration to microservices are easier software maintenance, better scalability, ease of deployment, and technology flexibility. Besides, we verified, based on a set of activities defined in the modernization process, that the practitioners are performing their migration process according to the best literature practices.;;;https://dl.acm.org/doi/10.1145/3483899.3483904;;;Software AND Engineering
Traffic travel service selection based on hybrid optimization algorithm;;;['Wanchun Yang', 'Chenxi Zhang'];;;September 2021;;;WSSE '21: Proceedings of the 3rd World Symposium on Software Engineering;;;With the development of information technology in transportation industry, it becomes an important application of intelligent transportation system to provide real-time and effective travel services. The existing traffic travel service composition model is based on the assumption of single request, and it can not build composition according to granularity. Aiming at the problem of requests and granularity, from the two dimensions of transaction and quality of service (QoS), this paper presents an evaluation model of service composition which considers concurrent requests and multi-granularity. Based on the model, the paper proposed a method based on hybrid optimization algorithm. The proposed algorithm combined particle swarm optimization, crossover and mutation operators with priority, simulated annealing algorithm to get the optimal value. Experimental results show that our approach can guarantee QoS of service selection with low time cost.;;;https://dl.acm.org/doi/10.1145/3488838.3488875;;;Software AND Engineering
Research on Engine Simulation and Assembly Based on Computer Digital Twin;;;['Mu Lin', 'Weidong He', 'Lijun Shan'];;;October 2021;;;AIAM2021: 2021 3rd International Conference on Artificial Intelligence and Advanced Manufacture;;;The current digital engine model only considers the surface geometric errors generated during the part manufacturing process and does not include information such as feature registration constraints and physical properties. The virtual assembly simulation results based on this digital model will be quite different from the actual assembly. This paper proposes a digital twin assembly model expression method that integrates multi-level information. Based on the engine geometry layer model, the shape, pose, and physical characteristics of the engine parts that affect subsequent assembly are considered to generate a real physical engine. A digital twin with identical parts. First, collect feature point cloud, registration element, center of mass information and other information from real engine parts, divide them into geometric shape layer, pose constraint layer, and physical state layer to construct a hierarchical model of engine part features. Secondly, perform reverse modeling for different levels, including geometric shape models based on polynomial fitting and discrete cosine transformation, pose constraint models based on element feature registration, and physical state models based on contact deformation, so as to obtain engine parts containing real information Digital twin. Based on the digital twin of engine parts, the assembly twin frame is constructed by fusing assembly process information. Finally, the research on the engine assembly technology example driven by the digital twin is carried out. Through the interaction and integration of the physical process of engine assembly and the digital model, the intelligence, initiative and predictability of the engine assembly process are improved, and the assembly level is promoted.;;;https://dl.acm.org/doi/10.1145/3495018.3495032;;;Software AND Engineering
Design and Implementation of a Test Automation Framework for Configurable Devices;;;['Nan Than Than Soe', 'Nils Wild', 'Sansiri Tanachutiwat', 'Horst Lichter'];;;January 2022;;;APIT '22: Proceedings of the 2022 4th Asia Pacific Information Technology Conference;;;Test automation supports organizations in developing better products as they gain quick feedback and thus lower the risk of bottlenecks and service disruptions that hinder customer experience. Nevertheless, software testing has always been a time-consuming task. Furthermore, the feedback gained from test execution results has to be accurate to be beneficial. Testing software product lines is particularly time-consuming, as different software variants are needed to reach good coverage. Maintaining separate test suites for different variants is hard. In this paper, we present an approach, that matches the capabilities of available test environments with the requirements of test cases and executes only those test cases that are relevant for a given variant. The approach is meant to reduce execution times by skipping those tests that will never be able to be executed in a given environment and avoid false-negative test execution results. The framework was developed in the context of systems for public transportation, where different hard- and software setups are used depending on the use case (e.g., SIM-Card, GPS-Antenna, Voice-Radio).;;;https://dl.acm.org/doi/10.1145/3512353.3512383;;;Software AND Engineering
Research on simulation and optimization technology of needle valve seating force of engine high pressure common rail injector;;;['Jie Liu', 'Haixing Yu', 'Haiyan Shen', 'Cuiping Jia', 'Qin Xu', 'Huamei Zhu'];;;March 2022;;;ICSRT '22: Proceedings of the 3rd International Conference on Service Robotics Technologies;;;None;;;https://dl.acm.org/doi/10.1145/3529763.3529772;;;Software AND Engineering
Layout and Image Recognition Driving Cross-Platform Automated Mobile Testing;;;['Shengcheng Yu', 'Chunrong Fang', 'Yexiao Yun', 'Yang Feng'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The fragmentation problem has extended from Android to different platforms, such as iOS, mobile web, and even mini-programs within some applications (app), like WeChat1. In such a situation, recording and replaying test scripts is one of the most popular automated mobile app testing approaches. However, such approach encounters severe problems when crossing platforms. Different versions of the same app need to be developed to support different platforms relying on different platform supports. Therefore, mobile app developers need to develop and maintain test scripts for multiple platforms aimed at completely the same test requirements, greatly increasing testing costs. However, we discover that developers adopt highly similar user interface layouts for versions of the same app on different platforms. Such a phenomenon inspires us to replay test scripts from the perspective of similar UI layouts. In this paper, we propose an image-driven mobile app testing framework, utilizing Widget Feature Matching and Layout Characterization Matching to analyze app UIs. We use computer vision (CV) technologies to perform UI feature comparison and layout hierarchy extraction on mobile app screenshots to obtain UI structures containing rich contextual information of app widgets, including coordinates, relative relationship, etc. Based on acquired UI structures, we can form a platform-independent test script, and then locate the target widgets under test. Thus, the proposed framework non-intrusively replays test scripts according to a novel platform-independent test script model. We also design and implement a tool named LIRAT to devote the proposed framework into practice, based on which, we conduct an empirical study to evaluate the effectiveness and usability of the proposed testing framework. The results show that the overall replay accuracy reaches around 65.85% on Android (8.74% improvement over state-of-the-art approaches) and 35.26% on iOS (35% improvement over state-of-the-art approaches).;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00139;;;Software AND Engineering
Frontmatter: mining Android user interfaces at scale;;;['Konstantin Kuznetsov', 'Chen Fu', 'Song Gao', 'David N. Jansen', 'Lijun Zhang', 'Andreas Zeller'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;We introduce Frontmatter: the largest open-access dataset containing user interface models of about 160,000 Android apps. Frontmatter opens the door for comprehensive mining of mobile user interfaces, jumpstarting empirical research at a large scale, addressing questions such as "How many travel apps require registration?", "Which apps do not follow accessibility guidelines?", "Does the user interface correspond to the description?", and many more. The Frontmatter UI analysis tool and the Frontmatter dataset are available under an open-source license.;;;https://dl.acm.org/doi/10.1145/3468264.3473125;;;Software AND Engineering
Prioritize Crowdsourced Test Reports via Deep Screenshot Understanding;;;['Shengcheng Yu', 'Chunrong Fang', 'Zhenfei Cao', 'Xu Wang', 'Tongyu Li', 'Zhenyu Chen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Crowdsourced testing is increasingly dominant in mobile application (app) testing, but it is a great burden for app developers to inspect the incredible number of test reports. Many researches have been proposed to deal with test reports based only on texts or additionally simple image features. However, in mobile app testing, texts contained in test reports are condensed and the information is inadequate. Many screenshots are included as complements that contain much richer information beyond texts. This trend motivates us to prioritize crowdsourced test reports based on a deep screenshot understanding. In this paper, we present a novel crowdsourced test report prioritization approach, namely DeepPrior. We first represent the crowdsourced test reports with a novelly introduced feature, namely DeepFeature, that includes all the widgets along with their texts, coordinates, types, and even intents based on the deep analysis of the app screenshots, and the textual descriptions in the crowdsourced test reports. DeepFeature includes the Bug Feature, which directly describes the bugs, and the Context Feature, which depicts the thorough context of the bug. The similarity of the DeepFeature is used to represent the test reports' similarity and prioritize the crowdsourced test reports. We formally define the similarity as DeepSimilarity. We also conduct an empirical experiment to evaluate the effectiveness of the proposed technique with a large dataset group. The results show that DeepPrior is promising, and it outperforms the state-of-the-art approach with less than half the overhead.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00090;;;Software AND Engineering
Detecting concurrency vulnerabilities based on partial orders of memory and thread events;;;['Kunpeng Yu', 'Chenxu Wang', 'Yan Cai', 'Xiapu Luo', 'Zijiang Yang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Memory vulnerabilities are the main causes of software security problems. However, detecting vulnerabilities in multi-threaded programs is challenging because many vulnerabilities occur under specific executions, and it is hard to explore all possible executions of a multi-threaded program. Existing approaches are either computationally intensive or likely to miss some vulnerabilities due to the complex thread interleaving. This paper introduces a novel approach to detect concurrency memory vulnerabilities based on partial orders of events. A partial order on a set of events represents the definite execution orders of events. It allows constructing feasible traces exposing specific vulnerabilities by exchanging the execution orders of vulnerability-potential events. It also reduces the search space of possible executions and thus improves computational efficiency. We propose new algorithms to extract vulnerability-potential event pairs for three kinds of memory vulnerabilities. We also design a novel algorithm to compute a potential event pair's feasible set, which contains the relevant events required by a feasible trace. Our method extends existing approaches for data race detection by considering that two events are protected by the same lock. We implement a prototype of our approach and conduct experiments to evaluate its performance. Experimental results show that our tool exhibits superiority over state-of-the-art algorithms in both effectiveness and efficiency.;;;https://dl.acm.org/doi/10.1145/3468264.3468572;;;Software AND Engineering
M-CUBE: A Millimeter-Wave Massive MIMO Software Radio;;;['Renjie Zhao', 'Timothy Woodford', 'Teng Wei', 'Kun Qian', 'Xinyu Zhang'];;;March 2021;;;GetMobile: Mobile Computing and Communications;;;Millimeter-wave (mmWave) technologies represent a cornerstone for emerging wireless network infrastructure, and for RF sensing systems in security, health, and automotive domains. However, the lack of an experimental platform has been impeding research in this field. In this article, we propose to fill the gap with M3 (M-Cube), the first mmWave massive MIMO software radio. M3 features a fully reconfigurable array of phased arrays, with up to 8 RF chains and 256 antenna elements. Despite the orders of magnitude larger antenna arrays, its cost is orders of magnitude lower, even when compared with state-of-the-art single RF chain mmWave software radios. Case studies have demonstrated the usefulness of M3 design for research in mmWave massive MIMO communication and sensing.;;;https://dl.acm.org/doi/10.1145/3471440.3471449;;;Software AND Engineering
Programming as architecture, design, and urban planning;;;['Tomas Petricek'];;;October 2021;;;Onward! 2021: Proceedings of the 2021 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software;;;Our thinking about software is shaped by basic assumptions and metaphors that we rarely question. Computer science has the term science in its very name; we think of programming languages as formal mathematical objects and we hope to make better software by treating it as an engineering discipline. Those perspectives enabled a wide range of useful developments, but I believe they have outlived their usefulness. We need new ways of thinking about software that are able to cope with ill-defined problems and the increasing complexity of software. In this essay, I draw a parallel between the world of software and the world of architecture, design and urban planning. I hope to convince the reader that this is a well-justified parallel and I point to a number of discussions in architecture, design and urban planning from which the software world could learn. What kind of software may we be able to build if we think of programming as a design problem and aim to create navigable and habitable software for all its users?;;;https://dl.acm.org/doi/10.1145/3486607.3486770;;;Software AND Engineering
Applying discrete-event simulation and value stream mapping to reduce waste in an automotive engine manufacturing plant;;;['Ana Carolina M. Moreira', 'Daniel F. Silva'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;This paper aims to apply a combination of Value Stream Mapping (VSM) and Discrete-Event Simulation (DES) in an automotive engine manufacturing plant. First, a current state VSM was created and the sources of waste were identified. The leak-test area and engine impregnation process were identified as major sources of waste. Based on that, two potential improvement scenarios were developed and analyzed using DES. The simulation was used to compare key measures of performance in the current state and the proposed scenarios, using different setting for adjustable system parameters. Results showed improvements of up to 29% in annual engine impregnation cost for one scenario, without detriment to other measures. The study's major takeaway is demonstrating that VSM in conjunction with DES is a powerful alternative in studying changes in production processes, which leverages the advantages of both methodologies.;;;https://dl.acm.org/doi/10.5555/3522802.3522911;;;Software AND Engineering
Towards a Consistent Interpretation of AIOps Models;;;['Yingzhe Lyu', 'Gopi Krishnan Rajbahadur', 'Dayi Lin', 'Boyuan Chen', 'Zhen Ming (Jack) Jiang'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Artificial Intelligence for IT Operations (AIOps) has been adopted in organizations in various tasks, including interpreting models to identify indicators of service failures. To avoid misleading practitioners, AIOps model interpretations should be consistent (i.e., different AIOps models on the same task agree with one another on feature importance). However, many AIOps studies violate established practices in the machine learning community when deriving interpretations, such as interpreting models with suboptimal performance, though the impact of such violations on the interpretation consistency has not been studied.In this article, we investigate the consistency of AIOps model interpretation along three dimensions: internal consistency, external consistency, and time consistency. We conduct a case study on two AIOps tasks: predicting Google cluster job failures and Backblaze hard drive failures. We find that the randomness from learners, hyperparameter tuning, and data sampling should be controlled to generate consistent interpretations. AIOps models with AUCs greater than 0.75 yield more consistent interpretation compared to low-performing models. Finally, AIOps models that are constructed with the Sliding Window or Full History approaches have the most consistent interpretation with the trends presented in the entire datasets. Our study provides valuable guidelines for practitioners to derive consistent AIOps model interpretation.;;;https://dl.acm.org/doi/10.1145/3488269;;;Software AND Engineering
PyART: Python API Recommendation in Real-Time;;;['Xincheng He', 'Lei Xu', 'Xiangyu Zhang', 'Rui Hao', 'Yang Feng', 'Baowen Xu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;API recommendation in real-time is challenging for dynamic languages like Python. Many existing API recommendation techniques are highly effective, but they mainly support static languages. A few Python IDEs provide API recommendation functionalities based on type inference and training on a large corpus of Python libraries and third-party libraries. As such, they may fail to recommend or make poor recommendations when type information is missing or target APIs are project-specific. In this paper, we propose a novel approach, PyART, to recommending APIs for Python programs in real-time. It features a light-weight analysis to derive so-called optimistic data-flow, which is neither sound nor complete, but simulates the local data-flow information humans can derive. It extracts three kinds of features: data-flow, token similarity, and token co-occurrence, in the context of the program point where a recommendation is solicited. A predictive model is trained on these features using the Random Forest algorithm. Evaluation on 8 popular Python projects demonstrates that PyART can provide effective API recommendations. When historic commits can be leveraged, which is the target scenario of a state-of-the-art tool ARIREC, our average top-1 accuracy is over 50% and average top-10 accuracy over 70%, outperforming APIREC and Intellicode (i.e., the recommendation component in Visual Studio) by 28.48%-39.05% for top-1 accuracy and 24.41%-30.49% for top-10 accuracy. In other applications such as when historic comments are not available and cross-project recommendation, PyART also shows better overall performance. The time to make a recommendation is less than a second on average, satisfying the real-time requirement.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00145;;;Software AND Engineering
Scarecrow - Intelligent Annotation platform for Engine Health Management;;;['Deepak S. Srinivasan', 'Rohit Pruthi'];;;October 2021;;;AIMLSystems '21: Proceedings of the First International Conference on AI-ML Systems;;;Engine Health Management (EHM) in the context of applications such as gas turbines, power packs is dependent on massive amount of data captured by onboard sensors. The data streams are then processed to extract key points and trends capturing events related to failures and deterioration, which subsequently need to be enhanced by insights and judgements from Subject Matter Experts (SME). Data volumes and extremely demanding requirements, commercial and regulatory, cause human efforts to quickly emerge as bottleneck in EHM service delivery. We have developed an intelligent data annotation platform called Scarecrow which records SME inputs, generates machine learning models in near real-time which are then deployed into analytic pipelines for EHM diagnostics. Scarecrow enables seamless ML ops strategy through human assisted feature learning, model building and deployment;;;https://dl.acm.org/doi/10.1145/3486001.3486238;;;Software AND Engineering
”It’s Just Everything Outside of the IDE that’s the Problem”:: Information Seeking by Software Developers with Visual Impairments;;;['Kevin M Storer', 'Harini Sampath', 'M. Alice Alice Merrick'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;Many efforts to increase accessibility in coding for developers with visual impairments (DWVI) focus on supporting interactions with development tools. But, to understand how to appropriately modify and write source code, developers must seek information from a variety of disparate and highly technical sources. DWVI might benefit from technological support in this process. But, it is unclear what accessibility issues arise in technical information sources, whether accessibility impacts strategies for seeking technical information, or how best to support DWVI in information seeking. We conducted observations and interviews with twelve DWVI, to explore their information behaviors. We found that DWVI seek information in many of the same sources as their sighted peers, and accessibility issues in technical information sources were similar to those in nontechnical sources. But, despite these similarities, examining development as an information seeking process highlighted the role of contextual and social factors in determining accessibility for DWVI.;;;https://dl.acm.org/doi/10.1145/3411764.3445090;;;Software AND Engineering
Performance Monitoring Guidelines;;;['Maria Carla Calzarossa', 'Luisa Massari', 'Daniele Tessera'];;;April 2021;;;ICPE '21: Companion of the ACM/SPEC International Conference on Performance Engineering;;;Monitoring, that is, the process of collecting measurements on infrastructures and services, is an important subject of performance engineering. Although monitoring is not a new education topic, nowadays its relevance is rapidly increasing and its application is particularly demanding due to the complex distributed architectures of new and emerging technologies. As a consequence, monitoring has become a "must have" skill for students majoring in computer science and in computing-related fields. In this paper, we present a set of guidelines and recommendations to plan, design and setup sound monitoring projects. Moreover, we investigate and discuss the main challenges to be faced to build confidence in the entire monitoring process and ensure measurement quality. Finally, we describe practical applications of these concepts in teaching activities.;;;https://dl.acm.org/doi/10.1145/3447545.3451195;;;Software AND Engineering
ProSE: the architecture and design of a protein discovery engine;;;['Eyes Robson', 'Ceyu Xu', 'Lisa Wu Wills'];;;February 2022;;;ASPLOS '22: Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems;;;Protein language models have enabled breakthrough approaches to protein structure prediction, function annotation, and drug discovery. A primary limitation to the widespread adoption of these powerful models is the high computational cost associated with the training and inference of these models, especially at longer sequence lengths. We present the architecture, microarchitecture, and hardware implementation of a protein design and discovery accelerator, ProSE (Protein Systolic Engine). ProSE has a collection of custom heterogeneous systolic arrays and special functions that process transfer learning model inferences efficiently. The architecture marries SIMD-style computations with systolic array architectures, optimizing coarse-grained operation sequences across model layers to achieve efficiency without sacrificing generality. ProSE performs Protein BERT inference at up to 6.9× speedup and 48× power efficiency (performance/Watt) compared to one NVIDIA A100 GPU. ProSE achieves up to 5.5 × (12.7×) speedup and 173× (249×) power efficiency compared to TPUv3 (TPUv2).;;;https://dl.acm.org/doi/10.1145/3503222.3507722;;;Software AND Engineering
"They Can Only Ever Guide": How an Open Source Software Community Uses Roadmaps to Coordinate Effort;;;['Daniel Klug', 'Christopher Bogart', 'James D. Herbsleb'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Unlike in commercial software development, open source software (OSS) projects do not generally have managers with direct control over how developers spend their time, yet for projects with large, diverse sets of contributors, the need exists to focus and steer development in a particular direction in a coordinated way. This is especially important for "infrastructure" projects, such as critical libraries and programming languages that many other people depend on. Some projects have taken the approach of borrowing planning tools that originated in commercial development, despite the fact that these techniques were designed for very different contexts, e.g. strong top-down control and profit motives. Little research has been done to understand how these practices are adapted to a new context. In this paper, we examine the Rust project's use of roadmaps: how has an important OSS infrastructure project adapted an inherently top-down tool to the freewheeling world of OSS? We find that because Rust's roadmaps are built in part by summarizing what motivated developers most prefer to work on, they are in some ways more a description of the motivated labor available than they are a directive that the community move in a particular direction. They allow the community to avoid wasting time on unpopular proposals by revealing that there will be little help in building them, and encouraging work on popular features by making visible the amount of consensus in those features. Roadmaps generate a collective focus without limiting the full scope of what developers work on: roadmap issues consume proportionally more effort than other issues, but constitute a minority of the work done (i.e issues and pull requests made) by both central and peripheral participants. They also create transparency among and beyond the community into what central contributors' plans are, and allow more rational decision-making by providing a way for evidence about community needs to be linked to decision-making.;;;https://dl.acm.org/doi/10.1145/3449232;;;Software AND Engineering
An automatic refactoring framework for replacing test-production inheritance by mocking mechanism;;;['Xiao Wang', 'Lu Xiao', 'Tingting Yu', 'Anne Woepse', 'Sunny Wong'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Unit testing focuses on verifying the functions of individual units of a software system. It is challenging due to the high inter-dependencies among software units. Developers address this by mocking-replacing the dependency by a "faked" object. Despite the existence of powerful, dedicated mocking frameworks, developers often turn to a "hand-rolled" approach-inheritance. That is, they create a subclass of the dependent class and mock its behavior through method overriding. However, this requires tedious implementation and compromises the design quality of unit tests. This work contributes a fully automated refactoring framework to identify and replace the usage of inheritance by using Mockito-a well received mocking framework. Our approach is built upon the empirical experience from five open source projects that use inheritance for mocking. We evaluate our approach on four other projects. Results show that our framework is efficient, generally applicable to new datasets, mostly preserves test case behaviors in detecting defects (in the form of mutants), and decouples test code from production code. The qualitative evaluation by experienced developers suggests that the auto-refactoring solutions generated by our framework improve the quality of the unit test cases in various aspects, such as making test conditions more explicit, as well as improved cohesion, readability, understandability, and maintainability with test cases.;;;https://dl.acm.org/doi/10.1145/3468264.3468590;;;Software AND Engineering
LastPyMile: identifying the discrepancy between sources and packages;;;['Duc-Ly Vu', 'Fabio Massacci', 'Ivan Pashchenko', 'Henrik Plate', 'Antonino Sabetta'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Open source packages have source code available on repositories for inspection (e.g. on GitHub) but developers use pre-built packages directly from the package repositories (such as npm for JavaScript, PyPI for Python, or RubyGems for Ruby). Such convenient practice assumes that there are no discrepancies between source code and packages. These differences pose both operational risks (e.g. making dependent projects unable to compile) and security risks (e.g. deploying malicious code during package installation) in the software supply chain. Our empirical assessment of 2438 popular packages in PyPI with an analysis of around 10M lines of code shows several differences in the wild: modifications cannot be just attributed to malicious injections. Yet, scanning again all and whole ‘most likely good but modified’ packages is hard to manage for FOSS downstream users. We propose a methodology, LastPyMile, for identifying the differences between build artifacts of software packages and the respective source code repository. We show how it can be used to extend current package scanning practices for malware injection (which only covers less than 1% of the code of deployed packages).;;;https://dl.acm.org/doi/10.1145/3468264.3468592;;;Software AND Engineering
Synthesising Privacy by Design Knowledge Toward Explainable Internet of Things Application Designing in Healthcare;;;['Lamya Alkhariji', 'Nada Alhirabi', 'Mansour Naser Alraja', 'Mahmoud Barhamgi', 'Omer Rana', 'Charith Perera'];;;None;;;ACM Transactions on Multimedia Computing, Communications, and Applications;;;Privacy by Design (PbD) is the most common approach followed by software developers who aim to reduce risks within their application designs, yet it remains commonplace for developers to retain little conceptual understanding of what is meant by privacy. A vision is to develop an intelligent privacy assistant to whom developers can easily ask questions to learn how to incorporate different privacy-preserving ideas into their IoT application designs. This article lays the foundations toward developing such a privacy assistant by synthesising existing PbD knowledge to elicit requirements. It is believed that such a privacy assistant should not just prescribe a list of privacy-preserving ideas that developers should incorporate into their design. Instead, it should explain how each prescribed idea helps to protect privacy in a given application design context—this approach is defined as “Explainable Privacy.” A total of 74 privacy patterns were analysed and reviewed using ten different PbD schemes to understand how each privacy pattern is built and how each helps to ensure privacy. Due to page limitations, we have presented a detailed analysis in Reference [3]. In addition, different real-world Internet of Things (IoT) use-cases, including a healthcare application, were used to demonstrate how each privacy pattern could be applied to a given application design. By doing so, several knowledge engineering requirements were identified that need to be considered when developing a privacy assistant. It was also found that, when compared to other IoT application domains, privacy patterns can significantly benefit healthcare applications. In conclusion, this article identifies the research challenges that must be addressed if one wishes to construct an intelligent privacy assistant that can truly augment software developers’ capabilities at the design phase.;;;https://dl.acm.org/doi/10.1145/3434186;;;Software AND Engineering
Evaluating SZZ Implementations Through a Developer-informed Oracle;;;['Giovanni Rosa', 'Luca Pascarella', 'Simone Scalabrino', 'Rosalia Tufano', 'Gabriele Bavota', 'Michele Lanza', 'Rocco Oliveto'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The SZZ algorithm for identifying bug-inducing changes has been widely used to evaluate defect prediction techniques and to empirically investigate when, how, and by whom bugs are introduced. Over the years, researchers have proposed several heuristics to improve the SZZ accuracy, providing various implementations of SZZ. However, fairly evaluating those implementations on a reliable oracle is an open problem: SZZ evaluations usually rely on (i) the manual analysis of the SZZ output to classify the identified bug-inducing commits as true or false positives; or (ii) a golden set linking bug-fixing and bug-inducing commits. In both cases, these manual evaluations are performed by researchers with limited knowledge of the studied subject systems. Ideally, there should be a golden set created by the original developers of the studied systems. We propose a methodology to build a "developer-informed" oracle for the evaluation of SZZ variants. We use Natural Language Processing (NLP) to identify bug-fixing commits in which developers explicitly reference the commit(s) that introduced a fixed bug. This was followed by a manual filtering step aimed at ensuring the quality and accuracy of the oracle. Once built, we used the oracle to evaluate several variants of the SZZ algorithm in terms of their accuracy. Our evaluation helped us to distill a set of lessons learned to further improve the SZZ algorithm.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00049;;;Software AND Engineering
Godot engine and checklist-based specifications: revising a game programming class for asynchronous online teaching;;;['Paul Gestwicki'];;;None;;;Journal of Computing Sciences in Colleges;;;This experience report describes the revisions to an undergraduate elective game programming course that were made in response to the COVID-19 pandemic. The course transitioned from a lab-based, in-person class to an online, asynchronous one. This required a change in teaching technology from Unreal Engine 4 to Godot Engine. The course expanded its use of checklist-based specifications grading in order to facilitate student autonomy with minimal reduction in creativity and motivation. The course revisions required significant time investment, but the results were positive.;;;https://dl.acm.org/doi/10.5555/3512528.3512531;;;Software AND Engineering
Are Undergraduate Creative Coders Clean Coders?: A Correlation Study;;;['Wouter Groeneveld', 'Dries Martin', 'Tibo Poncelet', 'Kris Aerts'];;;February 2022;;;SIGCSE 2022: Proceedings of the 53rd ACM Technical Symposium on Computer Science Education - Volume 1;;;Research on global competencies of computing students suggests that next to technical programming knowledge, the teaching of non-technical skills such as creativity is becoming very relevant. Many CS1 courses introduce a layer of creative freedom by employing open project assignments. We are interested in the quality of the submitted projects in relation to the creativity that students show when tackling these open assignments. We have analyzed 110 projects from two academic years to investigate whether there is a relation between creativity and clean code in CS1 student projects. Seven judges were recruited that evaluated the creativity based on Amabile's Consensual Assessment Technique, while the PMD tool was used to explore code quality issues in the Java projects. Results indicate that the more projects are deemed as creative, the more likely code quality issues arise in these projects, and thus the less clean the code will be. We argue that next to promoting creativity in order to solve programming problems, the necessary attention should also be given to the clean code principles.;;;https://dl.acm.org/doi/10.1145/3478431.3499345;;;Software AND Engineering
Contract-based verification of model transformations: a formally founded approach;;;['Guillaume Brau', 'Mohammed Foughali'];;;March 2021;;;SAC '21: Proceedings of the 36th Annual ACM Symposium on Applied Computing;;;In safety-critical applications, using a Model-Driven Engineering (MDE) approach requires a high-level of trust in its underlying model transformations, i.e. the latter's correctness should be verified formally. Yet, the applicability of formal methods to transformations correctness remains limited due to the absence of formal foundations of popular MDE languages and frameworks such as AADL and SysML. In this paper, we propose a formally founded environment to verify model transformations in MDE. First, we define a transformation in a formal way: this involves formalizing input and output models at some level of abstraction, as well as the transformation rules. Then, we build a verification environment, formalized as a transition system (TS), by extending the transformation with contracts. Finally, we formulate and verify some correctness properties which we reduce, based on the previous steps, to reachability properties over the TS. We show how our approach can be implemented in Ocarina, an open-source transformation tool for AADL, and how it applies, for example, to build correct transformations from AADL models to their Cheddar ADL counterpart.;;;https://dl.acm.org/doi/10.1145/3412841.3442031;;;Software AND Engineering
Designing Uncorrelated Address Constrain for DNA Storage by DMVO Algorithm;;;['Ben Cao', 'Xue Ii', 'Xiaokang Zhang', 'Bin Wang', 'Qiang Zhang', 'Xiaopeng Wei'];;;None;;;IEEE/ACM Transactions on Computational Biology and Bioinformatics;;;At present, huge amounts of data are being produced every second, a situation that will gradually overwhelm current storage technology. DNA is a storage medium that features high storage density and long-term stability and is now considered to be a feasible storage solution. Errors are easily made during the sequencing and synthesis of DNA, however. In order to reduce the error rate, novel uncorrelated address constrain are reported, and a Damping Multi-Verse Optimizer (DMVO)algorithm is proposed to construct a set of DNA coding, which is used as the non-payload. The DMVO algorithm exchanges objects through black/white holes in order to achieve a stable state and adds damping factors as disturbances. Compared with previous work, the coding set obtained by the DMVO algorithm is larger in size and of higher quality. The results of this study reveal that the size of the DNA storage coding set obtained by the DMVO algorithm increased by 4&#x2013;16 percent, and the variance of the melting temperature decreased by 3&#x2013;18 percent.;;;https://dl.acm.org/doi/10.1109/TCBB.2020.3011582;;;Software AND Engineering
Combining a Novel Scoring Approach with Arabic Stemming Techniques for Arabic Chatbots Conversation Engine;;;['Nasser O. Alshammari', 'Fawaz D. Alharbi'];;;None;;;ACM Transactions on Asian and Low-Resource Language Information Processing;;;Arabic is recognized as one of the main languages around the world. Many attempts and efforts have been done to provide computing solutions to support the language. Developing Arabic chatbots is still an evolving research field and requires extra efforts due to the nature of the language. One of the common tasks of any natural language processing application is the stemming step. It is important for developing chatbots, since it helps with pre-processing the input data and it can be involved with different phases of the chatbot development process. The aim of this article is to combine a scoring approach with Arabic stemming techniques for developing an Arabic chatbot conversation engine. Two experiments are conducted to evaluate the proposed solution. The first experiment is to select which stemmer is more accurate when applying our solution, since our algorithm can support various stemmers. The second experiment was conducted to evaluate our proposed approach against various machine learning models. The results show that the ISRIS stemming algorithm is the best fit for our solution with accuracy 78.06%. The results also indicate that our novel solution achieved an F1 score of 65.5%, while the other machine learning models achieved slightly lower scores. Our study presents a novel technique by combining scoring mechanisms with stemming processes to produce the best answer for every query sent by chatbots users compared to other approaches. This can be helpful for developing Arabic chatbot and can support many domains such as education, business, and health. This technique is among the first techniques that developed purposefully to serve the development of Arabic chatbots conversation engine.;;;https://dl.acm.org/doi/10.1145/3511215;;;Software AND Engineering
Towards Formal Verification of Dynamic Memory Allocator Properties Using BIP Framework;;;['Xiutai Lu', 'Yang Gao', 'Wensheng Guo', 'Fengbo Zhang', 'Xia Yang', 'Jun Wan'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;Dynamic storage allocation (DSA) algorithms play an important role in the Real-Time Operating systems (RTOSs) community. It allows the RTOS to use limited memory efficiently. To ensure the DSA properties of a dynamic memory allocator, it is important to verify the implementation of its DSA algorithms. However, most previous works ignore memory interactive behaviors and just verify individually each function involved in DSA. Our main contribution in this paper is to verify the consistency of the memory interactive properties and its implementation. For this purpose, we use the BIP (Behavior, Interaction, Priority) Framework to deal with abstract behaviors, properties, and cross references to implementation code. We chose the TLSF as a testbed for formal verification of dynamic memory allocator properties and have produced a verification of TLSF. Both the behavior operations and property requirements of the TLSF have been specified in the BIP framework and the entire verification process is automated.;;;https://dl.acm.org/doi/10.1145/3487075.3487122;;;Software AND Engineering
Understanding community smells variability: A statistical approach: replication package instructions;;;['Gemma Catolino', 'Fabio Palomba', 'Damian Andrew Tamburri', 'Alexander Serebrenik'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;In this document, we present the replication package of the paper "Understanding Community Smells Variability: A Statistical Approach" accepted at the 43rd International Conference on Software Engineering - Software Engineering in Society Track (ICSE '21).;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00086;;;Software AND Engineering
Integrating usage monitoring for continuous evaluation and testing in the UI of an industry application;;;['Stefan Fischer', 'Claus Klammer', 'Rudolf Ramler'];;;August 2021;;;A-TEST 2021: Proceedings of the 12th International Workshop on Automating TEST Case Design, Selection, and Evaluation;;;Developing interactive systems and testing with realistic scenarios requires a detailed understanding of how these systems are used in their real environment. In this paper, we report on our experience from implementing a usage monitoring approach for the touch-enabled human machine interface of an industrial machine. The approach supports automated recording of user interface events as basis for analyzing interactions of users with the system. It collects information about navigation paths to different screens, activities on these screens, and the usage of functionality provided by the application. We evaluated three different approaches to integrate the required usage monitoring into the UI, considering aspects such as necessary changes to the existing code base, dependencies to third-party libraries, and the entailed performance overhead. The paper provides a detailed description of the implementation of the selected approach and a discussion of the lessons we learned from integrating the monitoring in an existing application.;;;https://dl.acm.org/doi/10.1145/3472672.3473955;;;Software AND Engineering
Executing certified model transformations on Apache Spark;;;['Jolan Philippe', 'Massimo Tisi', 'Hélène Coullon', 'Gerson Sunyé'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;Formal reasoning on model transformation languages allows users to certify model transformations against contracts. CoqTL includes a specification of a transformation engine in the Coq interactive theorem prover. An executable engine can be automatically extracted from this specification. Transformation contracts are proved by the user against the CoqTL specification and guaranteed to hold on the transformation running on the extracted implementation of CoqTL. The design of the transformation engine specification in CoqTL aims at easing the certification step, but this requirement harms the execution performance of the extracted engine.   In this paper, we aim at providing a scalable distributed implementation of the CoqTL specification. To achieve this objective we proceed in two steps. First, we introduce a refined specification of CoqTL that increases the engine parallelization. We present a mechanized proof of the equivalence with standard CoqTL. Second, we develop a prototype implementation of the refined specification on top of Spark. Finally, by evaluating the performance of a simple case study, we assess the speedup our solution can reach.;;;https://dl.acm.org/doi/10.1145/3486608.3486901;;;Software AND Engineering
Compatibility-Aware Web API Recommendation for Mashup Creation via Textual Description Mining;;;['Lianyong Qi', 'Houbing Song', 'Xuyun Zhang', 'Gautam Srivastava', 'Xiaolong Xu', 'Shui Yu'];;;None;;;ACM Transactions on Multimedia Computing, Communications, and Applications;;;With the ever-increasing prosperity of web Application Programming Interface (API) sharing platforms, it is becoming an economic and efficient way for software developers to design their interested mashups through web API re-use. Generally, a software developer can browse, evaluate, and select his or her preferred web APIs from the API's sharing platforms to create various mashups with rich functionality. The big volume of candidate APIs places a heavy burden on software developers’ API selection decisions. This, in turn, calls for the support of intelligent API recommender systems. However, existing API recommender systems often face two challenges. First, they focus more on the functional accuracy of APIs while neglecting the APIs’ actual compatibility. This then creates incompatible mashups. Second, they often require software developers to input a set of keywords that can accurately describe the expected functions of the mashup to be developed. This second challenge tests partial developers who have little background knowledge in the fields. To tackle the above-mentioned challenges, in this article we propose a compatibility-aware and text description-driven web API recommendation approach (named WARtext). WARtext guarantees the compatibility among the recommended APIs by utilizing the APIs’ composition records produced by historical mashup creations. Besides, WARtext entitles a software developer to type a simple text document that describes the expected mashup functions as input. Then through textual description mining, WARtext can precisely capture the developers’ functional requirements and then return a set of APIs with the highest compatibility. Finally, through a real-world mashup dataset ProgrammableWeb, we validate the feasibility of our novel approach.;;;https://dl.acm.org/doi/10.1145/3417293;;;Software AND Engineering
Automated Query Reformulation for Efficient Search based on Query Logs From Stack Overflow;;;['Kaibo Cao', 'Chunyang Chen', 'Sebastian Baltes', 'Christoph Treude', 'Xiang Chen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;As a popular Q&A site for programming, Stack Overflow is a treasure for developers. However, the amount of questions and answers on Stack Overflow make it difficult for developers to efficiently locate the information they are looking for. There are two gaps leading to poor search results: the gap between the user's intention and the textual query, and the semantic gap between the query and the post content. Therefore, developers have to constantly reformulate their queries by correcting misspelled words, adding limitations to certain programming languages or platforms, etc. As query reformulation is tedious for developers, especially for novices, we propose an automated software-specific query reformulation approach based on deep learning. With query logs provided by Stack Overflow, we construct a large-scale query reformulation corpus, including the original queries and corresponding reformulated ones. Our approach trains a Transformer model that can automatically generate candidate reformulated queries when given the user's original query. The evaluation results show that our approach outperforms five state-of-the-art baselines, and achieves a 5.6% to 33.5% boost in terms of ExactMatch and a 4.8% to 14.4% boost in terms of GLEU.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00116;;;Software AND Engineering
Relating Reading, Visualization, and Coding for New Programmers: A Neuroimaging Study;;;['Madeline Endres', 'Zachary Karas', 'Xiaosu Hu', 'Ioulia Kovelman', 'Westley Weimer'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Understanding how novices reason about coding at a neurological level has implications for training the next generation of software engineers. In recent years, medical imaging has been increasingly employed to investigate patterns of neural activity associated with coding activity. However, such studies have focused on advanced undergraduates and professionals. In a human study of 31 participants, we use functional near-infrared spectroscopy to measure the neural activity associated with introductory programming. In a controlled, contrast-based experiment, we relate brain activity when coding to that of reading natural language or mentally rotating objects (a spatial visualization task). Our primary result is that all three tasks--- coding, prose reading, and mental rotation---are mentally distinct for novices. However, while those tasks are neurally distinct, we find more significant differences between prose and coding than between mental rotation and coding. Intriguingly, we generally find more activation in areas of the brain associated with spatial ability and task difficulty for novice coding compared to that reported in studies with more expert developers. Finally, in an exploratory analysis, we also find a neural activation pattern predictive of programming performance 11 weeks later. While preliminary, these findings both expand on previous results (e.g., relating expertise to a similarity between coding and prose reading) and also provide a new understanding of the cognitive processes underlying novice programming.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00062;;;Software AND Engineering
A generalizability measure for program synthesis with genetic programming;;;['Dominik Sobania', 'Franz Rothlauf'];;;June 2021;;;GECCO '21: Proceedings of the Genetic and Evolutionary Computation Conference;;;The generalizability of programs synthesized by genetic programming (GP) to unseen test cases is one of the main challenges of GP-based program synthesis. Recent work showed that increasing the amount of training data improves the generalizability of the programs synthesized by GP. However, generating training data is usually an expensive task as the output value for every training case must be calculated manually by the user. Therefore, this work suggests an approximation of the expected generalization ability of solution candidates found by GP. To obtain candidate solutions that all solve the training cases, but are structurally different, a GP run is not stopped after the first solution is found that solves all training instances but search continues for more generations. For all found candidate solutions (solving all training cases), we calculate the behavioral vector for a set of randomly generated additional inputs. The proportion of the number of different found candidate solutions generating the same behavioral vector with highest frequency compared to all other found candidate solutions with different behavior can serve as an approximation for the generalizability of the found solutions. The paper presents experimental results for a number of standard program synthesis problems confirming the high prediction accuracy.;;;https://dl.acm.org/doi/10.1145/3449639.3459305;;;Software AND Engineering
SEALS: a framework for building self-adaptive virtual machines;;;['Gwendal Jouneaux', 'Olivier Barais', 'Benoit Combemale', 'Gunter Mussbacher'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;Over recent years, self-adaptation has become a major concern for software systems that evolve in changing environments. While expert developers may choose a manual implementation when self-adaptation is the primary concern, self-adaptation should be abstracted for non-expert developers or when it is a secondary concern. We present SEALS, a framework for building self-adaptive virtual machines for domain-specific languages. This framework provides first-class entities for the language engineer to promote domain-specific feedback loops in the definition of the DSL operational semantics. In particular, the framework supports the definition of (i) the abstract syntax and the semantics of the language as well as the correctness envelope defining the acceptable semantics for a domain concept, (ii) the feedback loop and associated trade-off reasoning, and (iii) the adaptations and the predictive model of their impact on the trade-off. We use this framework to build three languages with self-adaptive virtual machines and discuss the relevance of the abstractions, effectiveness of correctness envelopes, and compare their code size and performance results to their manually implemented counterparts. We show that the framework provides suitable abstractions for the implementation of self-adaptive operational semantics while introducing little performance overhead compared to a manual implementation.;;;https://dl.acm.org/doi/10.1145/3486608.3486912;;;Software AND Engineering
Identifying Key Features from App User Reviews;;;['Huayao Wu', 'Wenjun Deng', 'Xintao Niu', 'Changhai Nie'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Due to the rapid growth and strong competition of mobile application (app) market, app developers should not only offer users with attractive new features, but also carefully maintain and improve existing features based on users' feedbacks. User reviews indicate a rich source of information to plan such feature maintenance activities, and it could be of great benefit for developers to evaluate and magnify the contribution of specific features to the overall success of their apps. In this study, we refer to the features that are highly correlated to app ratings as key features, and we present KEFE, a novel approach that leverages app description and user reviews to identify key features of a given app. The application of KEFE especially relies on natural language processing, deep machine learning classifier, and regression analysis technique, which involves three main steps: 1) extracting feature-describing phrases from app description; 2) matching each app feature with its relevant user reviews; and 3) building a regression model to identify features that have significant relationships with app ratings. To train and evaluate KEFE, we collect 200 app descriptions and 1,108,148 user reviews from Chinese Apple App Store. Experimental results demonstrate the effectiveness of KEFE in feature extraction, where an average F-measure of 78.13% is achieved. The key features identified are also likely to provide hints for successful app releases, as for the releases that receive higher app ratings, 70% of features improvements are related to key features.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00088;;;Software AND Engineering
Doping Tests for Cyber-physical Systems;;;['Sebastian Biewer', 'Pedro R. D’argenio', 'Holger Hermanns'];;;None;;;ACM Transactions on Modeling and Computer Simulation;;;The software running in embedded or cyber-physical systems is typically of proprietary nature, so users do not know precisely what the systems they own are (in)capable of doing. Most malfunctionings of such systems are not intended by the manufacturer, but some are, which means these cannot be classified as bugs or security loopholes. The most prominent examples have become public in the diesel emissions scandal, where millions of cars were found to be equipped with software violating the law, altogether polluting the environment and putting human health at risk. The behaviour of the software embedded in these cars was intended by the manufacturer, but it was not in the interest of society, a phenomenon that has been called software doping. Due to the unavailability of a specification, the analysis of doped software is significantly different from that for buggy or insecure software and hence classical verification and testing techniques have to be adapted.The work presented in this article builds on existing definitions of software doping and lays the theoretical foundations for conducting software doping tests, so as to enable uncovering unethical manufacturers. The complex nature of software doping makes it very hard to effectuate doping tests in practice. We explain the main challenges and provide efficient solutions to realise doping tests despite this complexity.;;;https://dl.acm.org/doi/10.1145/3449354;;;Software AND Engineering
Towards a workflow for model-based testing of embedded systems;;;['Muhammad Nouman Zafar', 'Wasif Afzal', 'Eduard Enoiu'];;;August 2021;;;A-TEST 2021: Proceedings of the 12th International Workshop on Automating TEST Case Design, Selection, and Evaluation;;;Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.;;;https://dl.acm.org/doi/10.1145/3472672.3473956;;;Software AND Engineering
A hybrid model for predicting Mobile Price Range using machine learning techniques;;;['Ahsanul Hoque Sakib', 'Asif Khan Shakir', 'Shanjoy Sutradhar', 'MD.Abu Saleh', 'Washim Akram', 'Khalid Been MD.Badruzzaman Biplop'];;;January 2022;;;ICCDE '22: Proceedings of the 2022 8th International Conference on Computing and Data Engineering;;;Machine learning based classification techniques helps to solve the problem related to decision making. In many areas of price prediction are used like housing price prediction, stock price prediction different classification algorithm used. Some of them are used artificial neural network. In this study, different classification techniques used for prediction the mobile price range. The first one is Decision Tree second one is Random forest machine learning algorithm. The accuracy got by first two techniques respectively 83% and 84%. So, for improving the accuracy of Decision Tree, the parameter has been pruned and later Random Forest has been used. It gives 90% accuracy for this dataset. Here, also a hybrid ensemble method is implemented using combination of five different heterogeneous weak learners because it has a record of manifesting performance in machine learning techniques and was not used before on this dataset. And also, performance evaluation is performed for Decision Tree, Random forest and also for hybrid model like Precision, Recall.;;;https://dl.acm.org/doi/10.1145/3512850.3512860;;;Software AND Engineering
Explaining mispredictions of machine learning models using rule induction;;;['Jürgen Cito', 'Isil Dillig', 'Seohyun Kim', 'Vijayaraghavan Murali', 'Satish Chandra'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;While machine learning (ML) models play an increasingly prevalent role in many software engineering tasks, their prediction accuracy is often problematic. When these models do mispredict, it can be very difficult to isolate the cause. In this paper, we propose a technique that aims to facilitate the debugging process of trained statistical models. Given an ML model and a labeled data set, our method produces an interpretable characterization of the data on which the model performs particularly poorly. The output of our technique can be useful for understanding limitations of the training data or the model itself; it can also be useful for ensembling if there are multiple models with different strengths. We evaluate our approach through case studies and illustrate how it can be used to improve the accuracy of predictive models used for software engineering tasks within Facebook.;;;https://dl.acm.org/doi/10.1145/3468264.3468614;;;Software AND Engineering
A mocktail of source code representations;;;['Dheeraj Vagavolu', 'Karthik Chandra Swarna', 'Sridhar Chimalakonda'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Efficient representation of source code is essential for various software engineering tasks such as code classification and code clone detection. Most recent approaches for representing source code still use AST and do not leverage semantic graphs such as CFG and PDG. One effective technique for representing source code involves extracting paths from the AST and using a learning model to capture program properties. Code2vec is one such path-based approach that uses an attention-based neural network to learn code embeddings which can then be used for various downstream tasks. However, this approach uses only AST and does not leverage CFG and PDG. Even though an integrated graph approach (Code Property Graph) exists for representing source code, it has only been explored in the domain of software security. Moreover, it does not leverage the paths from the individual graphs. Our idea is to extend the path-based approach code2vec to include the semantic graphs CFG and PDG with AST, which is largely unexplored in software engineering. We evaluate our approach on the task of MethodNaming using a C dataset of 730K methods collected from GitHub. In comparison to code2vec, our approach improves the F1 score by 11% on the full dataset and up to 100% with individual projects. We show that semantic features from the CFG and PDG paths drastically improve the performance of the software engineering tasks. We envision that looking at a mocktail of source code representations for various software engineering tasks can lay the foundation for a new line of research and a re-haul of existing research.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678551;;;Software AND Engineering
FCOSMask: Fully Convolutional One-Stage Face Mask Wearing Detection Based on MobileNetV3;;;['Yang Yu', 'Jie Lu', 'Chao Huang', 'Bo Xiao'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;Wearing masks correctly in public is one major self-prevention method against the worldwide Coronavirus disease 2019 (COVID-19). This paper proposes FCOSMask, a fully convolutional one-stage face mask wearing detector based on the lightweight network, for emergency epidemic control and long-term epidemic prevention work. MobileNetV3 is applied as the backbone network to reduce computational overhead. Thus, complex calculation related to anchor boxes is avoided in the anchor-free method, and Complete Intersection over Union (CIoU) loss is selected as the bounding box regression loss function to speed up model convergence. Experiments show that compared to other anchor-based methods, detection speed of FCOSMask is improved around 3 to 4 times on self-established datasets and mean average precision (mAP) achieves 92.4%, which meets the accuracy and real-time requirements of the face mask wearing detection task in most public areas. Finally, a Web-based face mask wearing system is developed that can support public epidemic prevention and control management.;;;https://dl.acm.org/doi/10.1145/3487075.3487078;;;Software AND Engineering
csDetector: an open source tool for community smells detection;;;['Nuri Almarimi', 'Ali Ouni', 'Moataz Chouchen', 'Mohamed Wiem Mkaouer'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Community smells represent symptoms of sub-optimal organizational and social issues within software development communities that often lead to additional project costs and reduced software quality. Previous research identified a variety of community smells that are connected to sub-optimal patterns under different perspectives of organizational-social structures in the software development community. To detect community smells and understanding the characteristics of such organizational-social structures in a project, we propose csDetector, an open source tool that is able to automatically detect community smells within a project and provide relevant socio-technical metrics. csDetector uses a machine learning based detection approach that learns from various existing bad community development practices to provide automated support in detecting related community smells. We evaluate the effectiveness of csDetector on a benchmark of 143 open source projects from GitHub. Our results show that the csDetector tool can detect ten commonly occurring community smells in open software projects with an average F1 score of 84%. csDetector is publicly available, with a demo video, at: https://github.com/Nuri22/csDetector.;;;https://dl.acm.org/doi/10.1145/3468264.3473121;;;Software AND Engineering
Experience report on teaching testing through gamification;;;['Beáta Lőrincz', 'Bogdan Iudean', 'Andreea Vescan'];;;August 2021;;;EASEAI 2021: Proceedings of the 3rd International Workshop on Education through Advanced Software Engineering and Artificial Intelligence;;;Software systems become increasingly complex and testing is a vital component of the development process. Teaching software testing concepts are now more than ever acknowledged as essential.   The aim of this paper is to report on our software testing teaching approach, using game-based activities to engage students and facilitate learning, making them aware of their actions and related testing concepts. Agile testing and Session-Based Test Management are learned through lego-based context, exploratory testing is learned through a dice-based game, and various testing concepts are learned during the laboratory using storification.   We report on the results of activities with students, extracting valuable lessons for reproducing this approach in teaching software testing: game-based learning motivated students to participate in the activities, reflection on their actions allowed them to self-discover the testing concepts encapsulated into the game. In addition, we adapt and analyse an industry-like environment that serves as experience for their future careers.;;;https://dl.acm.org/doi/10.1145/3472673.3473960;;;Software AND Engineering
Improving the effectiveness of peer code review in identifying security defects;;;['Rajshakhar Paul'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Prior studies found peer code review useful in identifying security defects. That is why most of the commercial and open-source software (OSS) projects embraced peer code review and mandated the use of it in the software development life cycle. However, despite conducting mandatory peer code review practices, many security-critical OSS projects such as Chromium, Mozilla, and Qt are reporting a high number of post-release vulnerabilities to the Common Vulnerabilities and Exposures (CVE) database. Practitioners may wonder if there is any missing piece in the puzzle that leads code reviews to miss those security defects. Therefore, the primary objective of this dissertation study is to improve the effectiveness of peer code review in identifying security defects.   To meet this goal, I plan to empirically investigate: (i) why security defects escape code reviews, (ii) what are the challenges developers face to conduct effective security code reviews, (iii) how to build effective security code review strategy, and (iv) how to make effective utilization of security experts during code reviews.;;;https://dl.acm.org/doi/10.1145/3468264.3473107;;;Software AND Engineering
Integration of modeling and verification for system model based on KARMA language;;;['Jie Ding', 'Michel Reniers', 'Jinzhi Lu', 'Guoxin Wang', 'Lei Feng', 'Dimitris Kiritsis'];;;October 2021;;;DSM 2021: Proceedings of the 18th ACM SIGPLAN International Workshop on Domain-Specific Modeling;;;Model-based systems engineering (MBSE) enables to verify the system performance using system behavior models, which can identify design faults that do not meet the stakeholders’ requirements as early as possible, thus reducing the R&D cost and error risks. Currently, different domain engineers make use of different modeling languages to create their own behavior models. Different behavior models are verified by different approaches. It is difficult to adopt a unified integrated platform to support the modeling and verification of heterogeneous behavior models during the conceptual design phase. This paper proposes a unified modeling and verification approach supporting system formalisms and verification. The KARMA language is used to support the unified formalisms across MBSE models and dynamic simulations for different domain specific models. In order to describe the behavior model more precisely and to facilitate verification, the syntax of hybrid automata is integrated into KARMA. We implemented behavior models and their verification in MetaGraph, a multi-architecture modeling tool. Finally, the effectiveness of the proposed approach is validated by two cases: 1) the scenario of booking railway tickets using BPMN models; 2) the behavior performance simulation of unmanned vehicles using a SysML state machine diagram.;;;https://dl.acm.org/doi/10.1145/3486603.3486775;;;Software AND Engineering
Risks to the Public;;;['Peter G. Neumann'];;;April 2021;;;ACM SIGSOFT Software Engineering Notes;;;Mini-editorial (PGN) 2020 was a crazy year, with all kinds of risks on display. As usual, many of the lessons noted in past issues of SEN and RISKS have been largely ignored, and failures continue to mirror events from the past that have long been discussed here. Issues such as safety, security, and reliability always seem to need more foresight than they receive. Y2K con- tinues to hit somewhere each New Year's Day, when short- term remediations that demanded periodic upgrading have been forgotten. (I suppose old COBOL code will still ex- ist in year 2100, when there may be ambiguities relating to dates that could be 21xx or 20xx (although 19xx is unlikely), and the narrow windowing xes will fail even more dramati- cally.) Election integrity continues to be a real concern, where we are caught in the crosshairs between computer systems and networks that are not meaningfully trustworthy or au- ditable, and the nontechnological risks are still pervasive from unbalanced redistricting, creative dysinformation, poli- tics, Citzens United, and foreign interference. We need non- partisan scrutiny and defense against would-be subverters to overcome potential attacks and inadvertent mistakes. In pres- ence of potential risks in every part of the process, a strong sense of risk-awareness is required by voters, election officials, and the media (both proactively and remedially, as needed).;;;https://dl.acm.org/doi/10.1145/3448992.3448994;;;Software AND Engineering
A Remote Sensing Image Based Convolutional Neural Network for Target Detection of Electric Power;;;['Huanxin Wang', 'Hai Jiang', 'Xin Liu', 'Weiqing Yu', 'Licai Yan', 'Shixiong Jin'];;;October 2021;;;ICITEE '21: Proceedings of the 4th International Conference on Information Technologies and Electrical Engineering;;;As the basic content of urban construction and development, electric power facilities target detection can guarantee the basic work of urban electricity safety. In the rapid development of remote sensing technology, there are more and more remote sensing image data information, which plays a positive role in the processing and application of remote sensing image. Therefore, how to efficiently and accurately identify typical targets in remote sensing images has become the focus of electric power exploration at this stage, which can not only effectively solve the problem of low accuracy of traditional remote sensing image target detection methods, but also further grasp the application of power facilities. In this paper, the deep convolutional neural network is combined with remote sensing image target detection, and the ftL-RCNN neural network model is used to train the VGG16 convolutional network on the relevant data machine, and the input remote sensing image is marked with the regional recommendation network, so as to realize the remote sensing image target detection and analysis. The final results show that the actual test data sets have obtained high detection accuracy and confidence, so the relevant research results can be applied to power remote sensing image analysis;;;https://dl.acm.org/doi/10.1145/3513142.3513207;;;Software AND Engineering
Design and Analysis of Intelligent Text Entry Systems with Function Structure Models and Envelope Analysis;;;['Per Ola Kristensson', 'Thomas Müllners'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;Designing intelligent interactive text entry systems often relies on factors that are difficult to estimate or assess using traditional HCI design and evaluation methods. We introduce a complementary approach by adapting function structure models from engineering design. We extend their use by extracting controllable and uncontrollable parameters from function structure models and visualizing their impact using envelope analysis. Function structure models allow designers to understand a system in terms of its functions and flows between functions and decouple functions from function carriers. Envelope analysis allows the designer to further study how parameters affect variables of interest, for example, accuracy, keystroke savings and other dependent variables. We provide examples of function structure models and illustrate a complete envelope analysis by investigating a parameterized function structure model of predictive text entry. We discuss the implications of this design approach for both text entry system design and for critique of system contributions.;;;https://dl.acm.org/doi/10.1145/3411764.3445566;;;Software AND Engineering
Program Obfuscation via ABI Debiasing;;;['David Demicco', 'Rukayat Erinfolami', 'Aravind Prakash'];;;December 2021;;;ACSAC '21: Proceedings of the 37th Annual Computer Security Applications Conference;;;The Itanium ABI is the most popular C++ ABI that defines data structures essential to implement underlying object-oriented concepts in C++. Specifically, name mangling rules, object and VTable layouts, alignment, etc. are all mandated by the ABI. Adherence to the ABI comes with undesirable side effects. While it allows interoperability, past research efforts have shown that it provides robust inference points that an attacker can leverage to reveal sensitive design information through binary reverse engineering. In this work, we aim to reduce the ability of an attacker to successfully reverse engineer a binary. We do this via removal of what we call ABI Bias, i.e., the reverse engineering bias that manifests due to a compiler’s adherence to the ABI.  Specifically, we identify two types of ABI biases that are central to past reverse engineering works on C++ binaries: VTable ordering bias and Function Pointer bias. We present compiler-based techniques that can correctly and efficiently debias a given binary from the aforementioned biases. We evaluate our proof-of-concept implementation on a corpus of real world programs for binary size, correctness and performance. We report an average increase of 1.42% in binary size compared to the baseline, very low performance overhead and lastly, correct execution of evaluation programs in comparison to the baseline. Finally, we demonstrate efficacy of our approach by hindering DeClassifier, a state-of-the-art C++ reverse engineering framework.;;;https://dl.acm.org/doi/10.1145/3485832.3488017;;;Software AND Engineering
Architecture Scheme of DevOps for Cross Network and Multiple Environment Collaboration;;;['Li Liu', 'Dongmei Xie', 'YunChang Cheng', 'Gongliang Li'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;In the process of traditional enterprises exploring the middle platform architecture, DevOps is the cornerstone of its digital platform's long-term iterative construction and sustainable operation and maintenance. Aiming at the problems of physical isolation of multiple environments and cross regional collaboration of R&D teams faced by high security applications, based on the systematic analysis of DevOps concept, support tools and adoption situation, and based on the DevOps standard, this paper designs a DevOps architecture scheme for internal and external collaboration within cross-network multiple environments.;;;https://dl.acm.org/doi/10.1145/3487075.3487116;;;Software AND Engineering
Adaptive brokerage framework for the cloud with functional testing;;;['Sheriffo Ceesay', 'Yuhui Lin', 'Adam Barker'];;;December 2021;;;UCC '21: Proceedings of the 14th IEEE/ACM International Conference on Utility and Cloud Computing Companion;;;In this paper, we present an Adaptive Brokerage for the Cloud (ABC) that can be used to simplify application deployment, monitoring and management processes in the cloud. The broker uses modern cloud infrastructure automation tools to test, deploy, monitor and optimise cloud resources. We used an e-commerce application to evaluate the entire functionality of the broker, we found out that different deployment options such as single-tier vs two-tier lead to interesting hardware and application performance insights. These insights are used to make effective infrastructure optimisation decisions.;;;https://dl.acm.org/doi/10.1145/3492323.3495624;;;Software AND Engineering
DeepCVA: automated commit-level vulnerability assessment with deep multi-task learning;;;['Triet Huynh Minh Le', 'David Hin', 'Roland Croft', 'M. Ali Babar'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;It is increasingly suggested to identify Software Vulnerabilities (SVs) in code commits to give early warnings about potential security risks. However, there is a lack of effort to assess vulnerability-contributing commits right after they are detected to provide timely information about the exploitability, impact and severity of SVs. Such information is important to plan and prioritize the mitigation for the identified SVs. We propose a novel Deep multi-task learning model, DeepCVA, to automate seven Commit-level Vulnerability Assessment tasks simultaneously based on Common Vulnerability Scoring System (CVSS) metrics. We conduct large-scale experiments on 1,229 vulnerability-contributing commits containing 542 different SVs in 246 real-world software projects to evaluate the effectiveness and efficiency of our model. We show that DeepCVA is the best-performing model with 38% to 59.8% higher Matthews Correlation Coefficient than many supervised and unsupervised baseline models. DeepCVA also requires 6.3 times less training and validation time than seven cumulative assessment models, leading to significantly less model maintenance cost as well. Overall, DeepCVA presents the first effective and efficient solution to automatically assess SVs early in software systems.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678622;;;Software AND Engineering
MigrationAdvisor: recommending library migrations from large-scale open-source data;;;['Hao He', 'Yulin Xu', 'Xiao Cheng', 'Guangtai Liang', 'Minghui Zhou'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;During software maintenance, developers may need to migrate an already in-use library to another library with similar functionalities. However, it is difficult to make the optimal migration decision with limited information, knowledge, or expertise. In this paper, we present MigrationAdvisor, an evidence-based tool to recommend library migration targets through intelligent analysis upon a large number of GitHub repositories and Java libraries. The migration advisories are provided through a search engine style web service where developers can seek migration suggestions for a specific library. We conduct systematic evaluations on the correctness of results, and evaluate the usefulness of the tool by collecting usage feedback from industry developers. Video: https://youtu.be/4I75W22TqwQ.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00023;;;Software AND Engineering
Security Smells Pervade Mobile App Servers;;;['Pascal Gadient', 'Marc-Andrea Tarnutzer', 'Oscar Nierstrasz', 'Mohammad Ghafari'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;[Background] Web communication is universal in cyberspace, and security risks in this domain are devastating. [Aims] We analyzed the prevalence of six security smells in mobile app servers, and we investigated the consequence of these smells from a security perspective. [Method] We used an existing dataset that includes 9 714 distinct URLs used in 3 376 Android mobile apps. We exercised these URLs twice within 14 months and investigated the HTTP headers and bodies. [Results] We found that more than 69% of tested apps suffer from three kinds of security smells, and that unprotected communication and misconfigurations are very common in servers. Moreover, source-code and version leaks, or the lack of update policies expose app servers to security risks. [Conclusions] Poor app server maintenance greatly hampers security.;;;https://dl.acm.org/doi/10.1145/3475716.3475780;;;Software AND Engineering
PERFUME: Programmatic Extraction and Refinement for Usability of Mathematical Expression;;;['Nicolaas Weideman', 'Virginia K. Felkner', 'Wei-Cheng Wu', 'Jonathan May', 'Christophe Hauser', 'Luis Garcia'];;;November 2021;;;Checkmate '21: Proceedings of the 2021 Research on offensive and defensive techniques in the Context of Man At The End (MATE) Attacks;;;Algorithmic identification is the crux for several binary analysis applications, including malware analysis, vulnerability discovery, and embedded firmware reverse engineering. However, data-driven and signature-based approaches often break down when encountering outlier realizations of a particular algorithm. Moreover, reverse engineering of domain-specific binaries often requires collaborative analysis between reverse engineers and domain experts. Communicating the behavior of an unidentified binary program to non-reverse engineers necessitates the recovery of algorithmic semantics in a human-digestible form. This paper presents PERFUME, a framework that extracts symbolic math expressions from low-level binary representations of an algorithm. PERFUME works by translating a symbolic output representation of a binary function to a high-level mathematical expression. In particular, we detail how source and target representations are generated for training a machine translation model. We integrate PERFUME as a plug-in for Ghidra--an open-source reverse engineering framework. We present our preliminary findings for domain-specific use cases and formalize open challenges in mathematical expression extraction from algorithmic implementations.;;;https://dl.acm.org/doi/10.1145/3465413.3488575;;;Software AND Engineering
Projecting Robot Navigation Paths: Hardware and Software for Projected AR;;;['Zhao Han', 'Jenna Parrillo', 'Alexander Wilkinson', 'Holly A. Yanco', 'Tom Williams'];;;March 2022;;;HRI '22: Proceedings of the 2022 ACM/IEEE International Conference on Human-Robot Interaction;;;For mobile robots, mobile manipulators, and autonomous vehicles to safely navigate around populous places such as streets and warehouses, human observers must be able to understand their navigation intent. One way to enable such understanding is by visualizing this intent through projections onto the surrounding environment. But despite the demonstrated effectiveness of such projections, no open codebase with an integrated hardware setup exists. In this work, we detail the empirical evidence for the effectiveness of such directional projections, and share a robot-agnostic implementation of such projections, coded in C++ using the widely-used Robot Operating System (ROS) and rviz. Additionally, we demonstrate a hardware configuration for deploying this software, using a Fetch robot, and briefly summarize a full-scale user study that motivates this configuration. The code, configuration files (roslaunch and rviz files), and documentation are freely available on GitHub at https://github.com/umhan35/arrow_projection.;;;https://dl.acm.org/doi/10.5555/3523760.3523843;;;Software AND Engineering
Formation control and coordination of swarm robotic systems;;;['Abzal Ermekbayuly Kyzyrkanov', 'Sabyrzhan Kubeisinovich Atanov', 'Shadi Abdel Rahman Aljawarneh'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;In many applications, a group of autonomous mobile robots must follow a given trajectory while maintaining a certain geometric structure. If the motion in formation is properly organized, many advantages over traditional systems can be obtained: system cost can be reduced, system reliability and efficiency can be increased, while ensuring the reconfigurability and flexibility of the system's structure. Movement while maintaining a certain geometric structure has a wide range of applications. For example, in military missions, autonomous vehicles must maintain a certain structure of formation to cover terrain and conduct reconnaissance; in Smart Highway systems, the capacity of the transportation network can be greatly increased if vehicles can be grouped together at the same speed while maintaining a certain distance between them. This paper provides an algorithm for movement with a certain geometric structure of a group of autonomous mobile robots.;;;https://dl.acm.org/doi/10.1145/3492547.3492704;;;Software AND Engineering
Asset management in machine learning: a survey;;;['Samuel Idowu', 'Daniel Strüber', 'Thorsten Berger'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Machine Learning (ML) techniques are becoming essential components of many software systems today, causing an increasing need to adapt traditional software engineering practices and tools to the development of ML-based software systems. This need is especially pronounced due to the challenges associated with the large-scale development and deployment of ML systems. Among the most commonly reported challenges during the development, production, and operation of ML-based systems are experiment management, dependency management, monitoring, and logging of ML assets. In recent years, we have seen several efforts to address these challenges as witnessed by an increasing number of tools for tracking and managing ML experiments and their assets. To facilitate research and practice on engineering intelligent systems, it is essential to understand the nature of the current tool support for managing ML assets. What kind of support is provided? What asset types are tracked? What operations are offered to users for managing those assets? We discuss and position ML asset management as an important discipline that provides methods and tools for ML assets as structures and the ML development activities as their operations. We present a feature-based survey of 17 tools with ML asset management support identified in a systematic search. We overview these tools' features for managing the different types of assets used for engineering ML-based systems and performing experiments. We found that most of the asset management support depends on traditional version control systems, while only a few tools support an asset granularity level that differentiates between important ML assets, such as datasets and models.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00014;;;Software AND Engineering
Listening to the Crowd for the Change File Localization of Mobile Apps;;;['Jianmao Xiao', 'Jia Zeng', 'Su Yao', 'Yuanlong Cao', 'Yiwen Jiang', 'Wenle Wang'];;;December 2021;;;ACM ICEA '21: Proceedings of the 2021 ACM International Conference on Intelligent Computing and its Emerging Applications;;;In order to allow developers to implement operable code-level modification tasks based on user feedback directly, so as to achieve rapid and continuous app updates and releases. We propose an efficient automated approach named LCFCR, which leverages natural language processing and clustering algorithms to group user reviews. Then, it enriches the semantic information of each group. Further, by combining the textual information from both commit messages and source code, it automatically localizes potential change files. We have evaluated the LCFCR on 10 open source mobile apps. The experiments demonstrate that the proposed approach outperforms the state-of-the-art baseline work in terms of clustering and localization accuracy, and thus produces more reliable results.;;;https://dl.acm.org/doi/10.1145/3491396.3506530;;;Software AND Engineering
Turnover-induced knowledge loss in practice;;;['Martin P. Robillard'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;When contributors to a software project leave, the knowledge they hold may become lost, thus impacting code quality and team productivity. Although well-known strategies can be used to mitigate knowledge loss, these strategies have to be tailored to their target context to be effective. To help software development organizations mitigate turnover-induced knowledge loss, we sought to better understand the different contexts in which developers experience this knowledge loss, and the resulting implications. We conducted qualitative interviews with 27 professional developers and managers from three different companies that provide software products and services. Leveraging the experience of these practitioners, we contribute a framework for characterizing turnover-induced knowledge loss and descriptions of the implications of knowledge loss, synthesized into 20 observations. These observations about knowledge loss in practice are organized into four themes, validated by the participants, and discussed within the context of the research literature in software engineering.;;;https://dl.acm.org/doi/10.1145/3468264.3473923;;;Software AND Engineering
Students perception on the impact of their involvement in the learning process: an empirical study;;;['Ioana Todericiu', 'Camelia Serban', 'Andreea Vescan'];;;August 2021;;;EASEAI 2021: Proceedings of the 3rd International Workshop on Education through Advanced Software Engineering and Artificial Intelligence;;;Nowadays, when the changes that appear in programming paradigms and in software process development methodologies are extremely frequent, teaching a Software Engineering related course has become a demanding task. To all these are added changes caused by the dynamics of the society and the traits of the current learners and how they learn.  To cope with the challenges mentioned above, the paper proposes a complementary method for Project Based Learning in teaching two Software Engineering related courses, at undergraduate and master level at Babeş-Bolyai University. Its contribution is twofold: firstly, it frames a new pedagogical approach based on “Students Generating Questions” as a learning strategy, defined in a collaborative way. The approach is supported by an e-learning platform designed as smart learning environment. Secondly, it investigates through a quantitative and qualitative analysis, the students perceptions, their feedback and learning experiences on the use of applying this learning method.  The results of the survey indicate that the proposed learning method helped students to better regulate their learning and to achieve their goals. It also revealed some advantages reported by the students such as reduction of test anxiety, productive collaborative learning and the creation of a question bank which represents a consistent and comprehensive material for training during the semester and for their exam preparation.;;;https://dl.acm.org/doi/10.1145/3472673.3473964;;;Software AND Engineering
Research on Full-Chip Programming for Sunway Heterogeneous Many-core Processor;;;['Wei Wu', 'Hong Qian', 'Qi Zhu', 'Jue Wang', 'XingJian Fan'];;;September 2021;;;WSSE '21: Proceedings of the 3rd World Symposium on Software Engineering;;;Programming on many-core processors is a challenging task. It's a difficult topic to program and compile on heterogeneous many-core architectures in high-performance computing area. The bottom-level programming support on Sunway many-core processors is insufficient and can hardly satisfy the growing need in applications. This paper conducts an thread accelerated programming model and a multi-mode accelerating thread library on Sunway architectures. A fast thread group mode is proposed, which can reduce the consumption of thread spawn and join according to hardware's features. Compared to GPU, it achieves a speedup of 24.88. We also designs a globally sharing executing mode, which supports many-core acceleration programming from the view of full-chip. Evaluation results on the Parboil benchmark shows that, the average performance is 1.16 times as NVIDIA V100 GPU.;;;https://dl.acm.org/doi/10.1145/3488838.3488868;;;Software AND Engineering
CURE: Code-Aware Neural Machine Translation for Automatic Program Repair;;;['Nan Jiang', 'Thibaud Lutellier', 'Lin Tan'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Automatic program repair (APR) is crucial to improve software reliability. Recently, neural machine translation (NMT) techniques have been used to fix software bugs automatically. While promising, these approaches have two major limitations. Their search space often does not contain the correct fix, and their search strategy ignores software knowledge such as strict code syntax. Due to these limitations, existing NMT-based techniques underperform the best template-based approaches. We propose CURE, a new NMT-based APR technique with three major novelties. First, CURE pre-trains a programming language (PL) model on a large software codebase to learn developer-like source code before the APR task. Second, CURE designs a new code-aware search strategy that finds more correct fixes by focusing on compilable patches and patches that are close in length to the buggy code. Finally, CURE uses a subword tokenization technique to generate a smaller search space that contains more correct fixes. Our evaluation on two widely-used benchmarks shows that CURE correctly fixes 57 Defects4J bugs and 26 QuixBugs bugs, outperforming all existing APR techniques on both benchmarks.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00107;;;Software AND Engineering
Automatically deciding on the integration of commits based on their descriptions;;;['Samuel C. Fonseca', 'Mateus C. Lucena', 'Tiago M. Reis', 'Pedro F. Cabral', 'Walmir A. Silva', 'Flavia de S. Santos', 'Felipe T. Giuntini', 'Juliano Sales'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Continuous Integration is a critical problem for software maintenance in global projects, compromising companies' performance, which tends to accumulate a high-resolution time due to the approval process, conflict resolution, tests, and validations. The process of the validation involves the commit description interpretation and can be automated by NLP-mechanisms. This paper presents an intelligent NLP-based approach to evaluate whether the commits can be integrated into a certain software release based only on their descriptions. Our experiments showed an accuracy of 92.9%.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678906;;;Software AND Engineering
Measuring Discrimination to Boost Comparative Testing for Multiple Deep Learning Models;;;['Linghan Meng', 'Yanhui Li', 'Lin Chen', 'Zhi Wang', 'Di Wu', 'Yuming Zhou', 'Baowen Xu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The boom of DL technology leads to massive DL models built and shared, which facilitates the acquisition and reuse of DL models. For a given task, we encounter multiple DL models available with the same functionality, which are considered as candidates to achieve this task. Testers are expected to compare multiple DL models and select the more suitable ones w.r.t. the whole testing context. Due to the limitation of labeling effort, testers aim to select an efficient subset of samples to make an as precise rank estimation as possible for these models. To tackle this problem, we propose Sample Discrimination based Selection (SDS) to select efficient samples that could discriminate multiple models, i.e., the prediction behaviors (right/wrong) of these samples would be helpful to indicate the trend of model performance. To evaluate SDS, we conduct an extensive empirical study with three widely-used image datasets and 80 real world DL models. The experimental results show that, compared with state-of-the-art baseline methods, SDS is an effective and efficient sample selection method to rank multiple DL models.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00045;;;Software AND Engineering
Feature trace recording;;;['Paul Maximilian Bittner', 'Alexander Schultheiß', 'Thomas Thüm', 'Timo Kehrer', 'Jeffrey M. Young', 'Lukas Linsbauer'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Tracing requirements to their implementation is crucial to all stakeholders of a software development process. When managing software variability, requirements are typically expressed in terms of features, a feature being a user-visible characteristic of the software. While feature traces are fully documented in software product lines, ad-hoc branching and forking, known as clone-and-own, is still the dominant way for developing multi-variant software systems in practice. Retroactive migration to product lines suffers from uncertainties and high effort because knowledge of feature traces must be recovered but is scattered across teams or even lost. We propose a semi-automated methodology for recording feature traces proactively, during software development when the necessary knowledge is present. To support the ongoing development of previously unmanaged clone-and-own projects, we explicitly deal with the absence of domain knowledge for both existing and new source code. We evaluate feature trace recording by replaying code edit patterns from the history of two real-world product lines. Our results show that feature trace recording reduces the manual effort to specify traces. Recorded feature traces could improve automation in change-propagation among cloned system variants and could reduce effort if developers decide to migrate to a product line.;;;https://dl.acm.org/doi/10.1145/3468264.3468531;;;Software AND Engineering
gazel: supporting source code edits in eye-tracking studies;;;['Sarah Fakhoury', 'Devjeet Roy', 'Harry Pines', 'Tyler Cleveland', 'Cole S. Peterson', 'Venera Arnaoudova', 'Bonita Sharif', 'Jonathan I. Maletic'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Eye tracking tools are used in software engineering research to study various software development activities. However, a major limitation of these tools is their inability to track gaze data for activities that involve source code editing. We present a novel solution to support eye tracking experiments for tasks involving source code edits as an extension of the iTrace [9] community infrastructure. We introduce the iTrace-Atom plugin and gazel [gǝ'zel]---a Python data processing pipeline that maps gaze information to changing source code elements and provides researchers with a way to query this dynamic data. iTrace-Atom is evaluated via a series of simulations and is over 99% accurate at high eye-tracking speeds of over 1,000Hz. iTrace and gazel completely revolutionize the way eye tracking studies are conducted in realistic settings with the presence of scrolling, context switching, and now editing. This opens the doors to support many day-to-day software engineering tasks such as bug fixing, adding new features, and refactoring.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00038;;;Software AND Engineering
Analysis of Machine Learning techniques for Predicting Student Success in an Educational Institution;;;['P. Aruna', 'N. Priya'];;;October 2021;;;CSSE '21: Proceedings of the 4th International Conference on Computer Science and Software Engineering;;;The student success is one of the essential components to assess the quality of the educational institutions. Monitoring student performance is of no use unless or otherwise it is done from the early stage. This research work will definitely consider two factors in mind about student success, firstly, Academic success. Secondly, Placement success. The goal of the proposed system is to predict the student's success using machine learning techniques and give feedback to the educational institutions. In this work , discussion of factors which affect the prediction, finding out the data sources and discussion about the various techniques used in prediction have been done.;;;https://dl.acm.org/doi/10.1145/3494885.3494916;;;Software AND Engineering
Context- and Fairness-Aware In-Process Crowdworker Recommendation;;;['Junjie Wang', 'Ye Yang', 'Song Wang', 'Jun Hu', 'Qing Wang'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Identifying and optimizing open participation is essential to the success of open software development. Existing studies highlighted the importance of worker recommendation for crowdtesting tasks in order to improve bug detection efficiency, i.e., detect more bugs with fewer workers. However, there are a couple of limitations in existing work. First, these studies mainly focus on one-time recommendations based on expertise matching at the beginning of a new task. Second, the recommendation results suffer from severe popularity bias, i.e., highly experienced workers are recommended in almost all the tasks, while less experienced workers rarely get recommended. This article argues the need for context- and fairness-aware in-process crowdworker recommendation in order to address these limitations. We motivate this study through a pilot study, revealing the prevalence of long-sized non-yielding windows, i.e., no new bugs are revealed in consecutive test reports during the process of a crowdtesting task. This indicates the potential opportunity for accelerating crowdtesting by recommending appropriate workers in a dynamic manner, so that the non-yielding windows could be shortened. Besides, motivated by the popularity bias in existing crowdworker recommendation approach, this study also aims at alleviating the unfairness in recommendations.Driven by these observations, this article proposes a context- and fairness-aware in-process crowdworker recommendation approach, iRec2.0, to detect more bugs earlier, shorten the non-yielding windows, and alleviate the unfairness in recommendations. It consists of three main components: (1) the modeling of dynamic testing context, (2) the learning-based ranking component, and (3) the multi-objective optimization-based re-ranking component. The evaluation is conducted on 636 crowdtesting tasks from one of the largest crowdtesting platforms, and results show the potential of iRec2.0 in improving the cost-effectiveness of crowdtesting by saving the cost, shortening the testing process, and alleviating the unfairness among workers. In detail, iRec2.0 could shorten the non-yielding window by a median of 50%–66% in different application scenarios, and consequently have potential of saving testing cost by a median of 8%–12%. Meanwhile, the recommendation frequency of the crowdworker drop from 34%–60% to 5%–26% under different scenarios, indicating its potential in alleviating the unfairness among crowdworkers.;;;https://dl.acm.org/doi/10.1145/3487571;;;Software AND Engineering
From logistics process models to automated integration testing: proof-of-concept using open-source simulation software;;;['Paul Reichardt', 'Wladimir Hofmann', 'Tobias Reggelin', 'Sebastian Lang'];;;December 2021;;;WSC '21: Proceedings of the Winter Simulation Conference;;;This paper explores the practical integration of simulation methods into software development processes. An automated integration testing approach is presented, which enables continuous virtual commissioning. For this purpose, an analysis of the current state of knowledge and the standards of software development is presented. This is followed by a case study on logistics order management, referring to a typical B2B application in the retail logistics sector. The proof-of-concept shows how the usage of a simulation model for automated integration testing and its inclusion into continuous-integration can help to ensure software quality, particularly for process-centered logistics applications. The implemented setup proves the feasibility of the approach, using standard open-source development tools, and a Python-based open-source simulation library.;;;https://dl.acm.org/doi/10.5555/3522802.3522901;;;Software AND Engineering
An Evolutionary Study of Configuration Design and Implementation in Cloud Systems;;;['Yuanliang Zhang', 'Haochen He', 'Owolabi Legunsen', 'Shanshan Li', 'Wei Dong', 'Tianyin Xu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Many techniques were proposed for detecting software misconfigurations in cloud systems and for diagnosing unintended behavior caused by such misconfigurations. Detection and diagnosis are steps in the right direction: misconfigurations cause many costly failures and severe performance issues. But, we argue that continued focus on detection and diagnosis is symptomatic of a more serious problem: configuration design and implementation are not yet first-class software engineering endeavors in cloud systems. Little is known about how and why developers evolve configuration design and implementation, and the challenges that they face in doing so. This paper presents a source-code level study of the evolution of configuration design and implementation in cloud systems. Our goal is to understand the rationale and developer practices for revising initial configuration design/implementation decisions, especially in response to consequences of misconfigurations. To this end, we studied 1178 configuration-related commits from a 2.5 year version-control history of four large-scale, actively-maintained open-source cloud systems (HDFS, HBase, Spark, and Cassandra). We derive new insights into the software configuration engineering process. Our results motivate new techniques for proactively reducing misconfigurations by improving the configuration design and implementation process in cloud systems. We highlight a number of future research directions.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00029;;;Software AND Engineering
How can manual testing processes be optimized? developer survey, optimization guidelines, and case studies;;;['Roman Haas', 'Daniel Elsner', 'Elmar Juergens', 'Alexander Pretschner', 'Sven Apel'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Manual software testing is tedious and costly as it involves significant human effort. Yet, it is still widely applied in industry and will be in the foreseeable future. Although there is arguably a great need for optimization of manual testing processes, research focuses mostly on optimization techniques for automated tests. Accordingly, there is no precise understanding of the practices and processes of manual testing in industry nor about pitfalls and optimization potential that is untapped. To shed light on this issue, we conducted a survey among 38 testing professionals from 16 companies, to investigate their manual testing processes and to identify potential for optimization. We synthesize guidelines when optimization techniques from automated testing can be implemented for manual testing. By means of case studies on two industrial software projects, we show that fault detection likelihood, test feedback time and test creation efforts can be improved when following our guidelines.;;;https://dl.acm.org/doi/10.1145/3468264.3473922;;;Software AND Engineering
Résumé-driven development: a definition and empirical characterization;;;['Jonas Fritzsch', 'Marvin Wyrich', 'Justus Bogner', 'Stefan Wagner'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;Technologies play an important role in the hiring process for software professionals. Within this process, several studies revealed misconceptions and bad practices which lead to suboptimal recruitment experiences. In the same context, grey literature anecdotally coined the term Résumé-Driven Development (RDD), a phenomenon describing the overemphasis of trending technologies in both job offerings and resumes as an interaction between employers and applicants. While RDD has been sporadically mentioned in books and online discussions, there are so far no scientific studies on the topic, despite its potential negative consequences. We therefore empirically investigated this phenomenon by surveying 591 software professionals in both hiring (130) and technical (558) roles and identified RDD facets in substantial parts of our sample: 60% of our hiring professionals agreed that trends influence their job offerings, while 82% of our software professionals believed that using trending technologies in their daily work makes them more attractive for prospective employers. Grounded in the survey results, we conceptualize a theory to frame and explain Resume-Driven Development. Finally, we discuss influencing factors and consequences and propose a definition of the term. Our contribution provides a foundation for future research and raises awareness for a potentially systemic trend that may broadly affect the software industry.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00011;;;Software AND Engineering
Learning Modular Programming using Realistic Scenarios: an Experience Report;;;['Paulo Santos', 'Jobson Massollar'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software Engineering is essentially an applied research field. Students will only understand some of the abstract concepts and principles taught in software engineering courses if they see the intricacies of the real world in practice. Industrial or close-to-real scenarios are increasingly being incorporated into classrooms. It tends to enable the students to appreciate software development as an engineering process in which aspects such as quality must be considered in decision-making. This paper presents an instructional proposal adopted in the Modular Programming course at Federal University of the State of Rio de Janeiro (UNIRIO). The proposed instructional design is based on Project-Based Learning theory, mixing group and individual tasks during the software development activities of a software project. It capitalizes on the microservice architectural pattern so that the students work in parallel developing different system modules. Also, to increase the perception of realism by the students, the instructional design employs modern software development tools commonly found in software organizations. Our preliminary results indicate students are more engaged in the course activities, and they feel more technically productive in their jobs. On the other hand, students pointed out some issues such as better accommodating task dependencies in the developed project and facilitating the configuration of software development tools. In conclusion, we believe that our proposal can be used in or adapted to other institutions interested in providing a more realistic experience to students in learning Modular Programming.;;;https://dl.acm.org/doi/10.1145/3474624.3476974;;;Software AND Engineering
EvoSpex: an evolutionary algorithm for learning postconditions (artifact);;;['Facundo Molina', 'Pablo Ponzio', 'Nazareno Aguirre', 'Marcelo Frias'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Having the expected behavior of software specified in a formal language can greatly improve the automation of software verification activities, since these need to contrast the intended behavior with the actual software implementation. Unfortunately, software many times lacks such specifications, and thus providing tools and techniques that can assist developers in the construction of software specifications are relevant in software engineering. As an aid in this context, we present EvoSpex, a tool that given a Java method, automatically produces a specification of the method's current behavior, in the form of postcondition assertions. EvoSpex is based on generating software runs from the implementation (valid runs), making modifications to the runs to build divergent behaviors (invalid runs), and executing a genetic algorithm that tries to evolve a specification to satisfy the valid runs, and leave out the invalid ones. Our tool supports a rich JML-like assertion language, that can capture complex specifications, including sophisticated object structural properties.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00080;;;Software AND Engineering
Multi-Persona Mobility: Joint Cost-Effective and Resource-Aware Mobile-Edge Computation Offloading;;;['Hanine Tout', 'Azzam Mourad', 'Nadjia Kara', 'Chamseddine Talhi'];;;None;;;IEEE/ACM Transactions on Networking;;;Multi-persona mobile computing has begun to make its way to determine the battle about practical strategy for adopting personal devices in workplace. Though its competency, multi-persona performance and viability are critically threatened by the limited resources of mobile devices. In recent years, mobile edge computing (MEC) has risen as promising paradigm within the internet of things era bringing benefits to the proximity of mobile terminals, leveraging intelligent computations offloading services to address the severity of their resource scarcity. Yet, embracing mobile edge-based services to augment personas resources and performance raises new concerns including determining what computations to offload for serving the highest number of mobile devices and reducing the remote execution fees imposed on the institution. In this context, we propose new cost-effective MEC-based solution to address these issues. We develop two-level multi-objective optimization realized through an intelligent offloading decision model able to settle both concerns, by minimizing processing, memory and energy while augmenting virtual mobile instances performance on a wide range of physical devices with minimal offloading service fees. We also propose a redesigned smart genetic-based method able to accelerate and reduce the overhead of offloading decision evaluation. Extensive analysis is performed and the results show that our proposition can get more quickly the offloading strategy than other schemes. The results also demonstrate the ability to enforce the virtual mobile devices by reducing local processing, memory usage, energy consumption and execution time along with acceptable minimal additional fees compared to other techniques.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3066558;;;Software AND Engineering
AC²: towards understanding architectural changes in Python projects;;;['A. Eashaan Rao', 'Dheeraj Vagavolu', 'Sridhar Chimalakonda'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Open source projects are adopting faster release cycles that reflect various changes in the software. Therefore, comprehending the effects of these changes as software architecture evolves over multiple releases becomes necessary. However, it is challenging to keep architecture in-check and add new changes simultaneously for every release. To this end, we propose a visualization tool called AC2, which allows users to examine the alterations in the architecture at both higher and lower levels of abstraction for Python projects. AC2 uses call graphs and collaboration graphs to show the interaction between different architectural components. The tool provides four different views to see the architectural changes. Users can examine two releases at a time to comprehend architectural changes between them. AC2 can support the maintainers and developers, observing changes in the project and their influence on the architecture, which allows them to examine its increasing complexity over many releases at component level. AC2 can be downloaded from <a>https://github.com/rishalab/AC2</a> and the demo can be seen at <a>https://www.youtube.com/watch?v=GNrJfZ0RCVI</a>.;;;https://dl.acm.org/doi/10.1145/3468264.3473120;;;Software AND Engineering
Distribution awareness for AI system testing;;;['David Berend'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;As Deep Learning (DL) is continuously adopted in many safety critical applications, its quality and reliability start to raise concerns. Similar to the traditional software development process, testing the DL software to uncover its defects at an early stage is an effective way to reduce risks after deployment. Although recent progress has been made in designing novel testing techniques for DL software, the distribution of generated test data is not taken into consideration. It is therefore hard to judge whether the identified errors are indeed meaningful errors to the DL application. Therefore, we propose a new distribution aware testing technique which aims to generate new unseen test cases relevant to the underlying DL system task. Our results show that this technique is able to filter up to 55.44% of error test case on CIFAR-10 and is 10.05% more effective in enhancing robustness.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00045;;;Software AND Engineering
Challenges and lessons learned introducing an evolving open source technology into an established legacy Ada and C++ program;;;['Brian Kleinke'];;;December 2020;;;ACM SIGAda Ada Letters;;;When the Federal Aviation Administration (FAA) launched the System Wide Information Management (SWIM) initiative, the FAA had the goal of using the same portable, open infrastructure across all participating systems in the National Airspace System (NAS). Around 2008 for SWIM Segment 1, the FAA chose Iona Software's Free/Open Source Software (FOSS) based bundle, which was known and supported under the Fuse brand. The FAA obtained the licenses used by programs, including EnRoute Automation Modernization (ERAM), through Iona, which was later acquired by Progress and RedHat.;;;https://dl.acm.org/doi/10.1145/3463478.3463485;;;Software AND Engineering
Reactive synthesis with spectra: a tutorial;;;['Shahar Maoz', 'Jan Oliver Ringert'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Spectra is a formal specification language specifically tailored for use in the context of reactive synthesis, an automated procedure to obtain a correct-by-construction reactive system from its temporal logic specification. Spectra comes with the Spectra Tools, a set of analyses, including a synthesizer to obtain a correct-by-construction implementation, several means for executing the resulting controller, and additional analyses aimed at helping engineers write higher-quality specifications. This hands-on tutorial will introduce participants to the language and the tool set, using examples and exercises, covering an end-to-end process from specification writing to synthesis to execution. The tutorial may be of interest to software engineers and researchers who are interested in the potential applications of formal methods to software engineering.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00136;;;Software AND Engineering
Design of University Intelligence Course Management System and Realization of Knowledge Graph;;;['MinChuan Huang'];;;January 2022;;;ICCMB '22: Proceedings of the 2022 5th International Conference on Computers in Management and Business;;;The function upgrading requirements of intelligent course scheduling system for university teaching management. The principle of knowledge map and the evolutionary analysis of starting course scheduling system. Interview the actual work analysis and expectation survey of college operators, improve the algorithm of the intelligent course scheduling system, and systematically analyze and design the system requirements according to the principle of software engineering. Design entity relationship, conduct entity analysis, and establish system function modules. B/S architecture mode of system prototype design. Realize system debugging, testing and operation.;;;https://dl.acm.org/doi/10.1145/3512676.3512683;;;Software AND Engineering
On the lack of consensus among technical debt detection tools;;;['Jason Lefever', 'Yuanfang Cai', 'Humberto Cervantes', 'Rick Kazman', 'Hongzhou Fang'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;A vigorous and growing set of technical debt analysis tools have been developed in recent years---both research tools and industrial products---such as Structure 101, SonarQube, and DV8. Each of these tools identifies problematic files using their own definitions and measures. But to what extent do these tools agree with each other in terms of the files that they identify as problematic? If the top-ranked files reported by these tools are largely consistent, then we can be confident in using any of these tools. Otherwise, a problem of accuracy arises. In this paper, we report the results of an empirical study analyzing 10 projects using multiple tools. Our results show that: 1) these tools report very different results even for the most common measures, such as size, complexity, file cycles, and package cycles. 2) These tools also differ dramatically in terms of the set of problematic files they identify, since each implements its own definitions of "problematic". After normalizing by size, the most problematic file sets that the tools identify barely overlap. 3) Our results show that code-based measures, other than size and complexity, do not even moderately correlate with a file's change-proneness or error-proneness. In contrast, co-change-related measures performed better. Our results suggest that, to identify files with true technical debt---those that experience excessive changes or bugs---co-change information must be considered. Code-based measures are largely ineffective at pinpointing true debt. Finally, this study reveals the need for the community to create benchmarks and data sets to assess the accuracy of software analysis tools in terms of commonly used measures.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00021;;;Software AND Engineering
"Is my mic on?": preparing SE students for collaborative remote work and hybrid team communication;;;['Makayla Moster', 'Denae Ford', 'Paige Rodeghero'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Communication is essential for the success of student and professional software engineering (SE) team development projects. The projects delivered by SE courses provide valuable learning experiences for students because they teach industry-required skills such as teamwork, communication, and scheduling. Professional SE teams have adopted communication software such as Slack, Miro, Microsoft Teams, and GitHub Discussions to share files and convey information between team members. Likewise, they have distributed software development tools such as Visual Studio CodeSpaces and Jira to support productivity. In contrast, within academia, students have focused on having face-to-face meetings for team communication and communication tools for file sharing. Due to the COVID-19 pandemic, universities have been forced to switch to an online or hybrid modality abruptly, thus compelling SE students to quickly adopt communication software. This paper proposes a study on the use of communication software in industry to prepare students for remote software development positions after graduation.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00018;;;Software AND Engineering
On the configuration of multi-objective evolutionary algorithms for PLA design optimization;;;['Willian Freire', 'Simone Tonhão', 'Tiago Bonetti', 'Marcelo Shigenaga', 'William Cadette', 'Fernando Felizardo', 'Aline Amaral', 'Edson OliveiraJr', 'Thelma Colanzi'];;;September 2021;;;SBCARS '21: Proceedings of the 15th Brazilian Symposium on Software Components, Architectures, and Reuse;;;Search-based algorithms have been successfully applied in the Product Line Architecture (PLA) optimization using the seminal approach called Multi-Objective Approach for Product-Line Architecture Design (MOA4PLA). This approach produces a set of alternative PLA designs intending to improve the different factors being optimized. Currently, the MOA4PLA uses the NSGA-II algorithm, a multi-objective evolutionary algorithm (MOEA) that can optimize several architectural properties simultaneously. Despite the promising results, studying the best values for the algorithm parameters is essential to obtain even better results. This is also crucial to ease the adoption of MOA4PLA by newcomers or non-expert companies willing to start using search-based software engineering to PLA design. Three crossover operators for the PLA design optimization were proposed recently. However, reference values for parameters have not been defined for PLA design optimization using crossover operators. In this context, the objective of this work is conducting an experimental study to discover which are the most effective crossover operators and the best values to configure the MOEA parameters, such as population size, number of generations, and mutation and crossover rates. A quantitative analysis based on quality indicators and statistical tests was performed using four PLA designs to determine the most suitable parameter values to the search-based algorithm. Empirical results pointed out the best combination of crossover operators and the most suitable values to configure MOA4PLA.;;;https://dl.acm.org/doi/10.1145/3483899.3483905;;;Software AND Engineering
Automatic HMI structure exploration via curiosity-based reinforcement learning;;;['Yushi Cao', 'Yan Zheng', 'Shang-Wei Lin', 'Yang Liu', 'Yon Shin Teo', 'Yuxuan Toh', 'Vinay Vishnumurthy Adiga'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Discovering the underlying structure of HMI software efficiently and sufficiently for the purpose of testing without any prior knowledge on the software logic remains a difficult problem. The key challenge lies in the complexity of the HMI software and the high variance in the coverage of current methods. In this paper, we introduce the PathFinder, an effective and automatic HMI software exploration framework. PathFinder adopts a curiosity-based reinforcement learning framework to choose actions that lead to the discovery of more unknown states. Additionally, PathFinder progressively builds a navigation model during the exploration to further improve state coverage. We have conducted experiments on both simulations and real-world HMI software testing environment, which comprise a full tool chain of automobile dashboard instrument cluster. The exploration coverage outperforms manual and fuzzing methods which are the current industrial standards.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678703;;;Software AND Engineering
To read or to rotate? comparing the effects of technical reading training and spatial skills training on novice programming ability;;;['Madeline Endres', 'Madison Fansher', 'Priti Shah', 'Westley Weimer'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Understanding how to best support and train novice programmers is a critical component of producing better and more diverse software engineers. In this paper, we present the results of a controlled 11-week longitudinal study with 57 CS1 students comparing two skill-based interventions to improve programming performance. The first intervention involves spatial training, an established baseline known to be helpful in engineering contexts. The second intervention is a novel CS-focused technical reading training.  In our reading training, we teach strategies for summarizing scientific papers and understanding scientific charts and figures; most of the covered readings were CS1-accessible portions of computer science research papers. For the spatial training, we use a standardized training curriculum previously found to improve programming skills by focusing on spatial ability (i.e., the ability to mentally manipulate objects). We first replicate findings that both reading ability and spatial ability correlate with programming success. Significantly, however, we find that those in our reading training exhibit larger programming ability gains than those in the standard spatial training (p = 0.02, f2=0.10). We also find that reading trained participants perform particularly well on programming problems that require tracing through code (p = 0.03, f2=0.10). Our results suggest that technical reading training could be beneficial for novice programmers. Finally, we discuss the implications of our results for future CS1 interventions, the possibility for non-programming based training to positively impact developers, and future directions for software engineering education research.;;;https://dl.acm.org/doi/10.1145/3468264.3468583;;;Software AND Engineering
PY2SRC: towards the automatic (and reliable) identification of sources for PyPI package;;;['Duc-Ly Vu'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Selecting which libraries ('dependencies' or 'packages' in the industry's jargon) to adopt in a project is an essential task in software development. The quality of the corresponding source code is a key factor behind this selection (from security to timeliness). Yet, how easy is it to find the 'actual' source? How reliable is this information? To address this problem, we developed an approach called py2src to automatically identify GitHub source code repositories corresponding to packages in PyPI and automatically provide an indicator of the reliability of such information. We also report a preliminary empirical evaluation of the approach on the top PyPI packages.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678526;;;Software AND Engineering
Incorporating energy efficiency measurement into CI\CD pipeline;;;['Artem Kruglov', 'Giancarlo Succi', 'Xavier Vasuez'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;In this paper we present the method and tool for linking the analysis of a software at the development stage with the efficiency of the developed product during operation mode from the energy consumption perspective. The purpose of the method is to recognize the bottlenecks of a program and provide recommendations for improving the structure and run-time behavior of the software. The developed tool consists of two subsystems: first is responsible for static analysis of the code and relevant software metrics, second performs analysis of the power consumption of the application. Analysis of the outputs of both components allows us to create a close-loop system for continuous analysis and optimization of the developing software product.;;;https://dl.acm.org/doi/10.1145/3501774.3501777;;;Software AND Engineering
Incorporating energy efficiency measurement into CI\CD pipeline;;;['Artem Kruglov', 'Giancarlo Succi', 'Xavier Vasuez'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;In this paper we present the method and tool for linking the analysis of a software at the development stage with the efficiency of the developed product during operation mode from the energy consumption perspective. The purpose of the method is to recognize the bottlenecks of a program and provide recommendations for improving the structure and run-time behavior of the software. The developed tool consists of two subsystems: first is responsible for static analysis of the code and relevant software metrics, second performs analysis of the power consumption of the application. Analysis of the outputs of both components allows us to create a close-loop system for continuous analysis and optimization of the developing software product.;;;https://dl.acm.org/doi/10.1145/3501774.3501777;;;Software AND Engineering
White-Box Performance-Influence Models: A Profiling and Learning Approach;;;['Max Weber', 'Sven Apel', 'Norbert Siegmund'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Many modern software systems are highly configurable, allowing the user to tune them for performance and more. Current performance modeling approaches aim at finding performance-optimal configurations by building performance models in a black-box manner. While these models provide accurate estimates, they cannot pinpoint causes of observed performance behavior to specific code regions. This does not only hinder system understanding, but it also complicates tracing the influence of configuration options to individual methods. We propose a white-box approach that models configuration-dependent performance behavior at the method level. This allows us to predict the influence of configuration decisions on individual methods, supporting system understanding and performance debugging. The approach consists of two steps: First, we use a coarse-grained profiler and learn performance-influence models for all methods, potentially identifying some methods that are highly configuration- and performance-sensitive, causing inaccurate predictions. Second, we re-measure these methods with a fine-grained profiler and learn more accurate models, at higher cost, though. By means of 9 real-world Java software systems, we demonstrate that our approach can efficiently identify configuration-relevant methods and learn accurate performance-influence models.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00099;;;Software AND Engineering
When life gives you oranges: detecting and diagnosing intermittent job failures at Mozilla;;;['Johannes Lampel', 'Sascha Just', 'Sven Apel', 'Andreas Zeller'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Continuous delivery of cloud systems requires constant running of jobs (build processes, tests, etc.). One issue that plagues this continuous integration (CI) process are intermittent failures - non-deterministic, false alarms that do not result from a bug in the software or job specification, but rather from issues in the underlying infrastructure. At Mozilla, such intermittent failures are called oranges as a reference to the color of the build status indicator. As such intermittent failures disrupt CI and lead to failures, they erode the developers' trust in the jobs. We present a novel approach that automatically classifies failing jobs to determine whether job execution failures arise from an actual software bug or were caused by flakiness in the job (e.g., test) or the underlying infrastructure. For this purpose, we train classification models using job telemetry data to diagnose failure patterns involving features such as runtime, cpu load, operating system version, or specific platform with high precision. In an evaluation on a set of Mozilla CI jobs, our approach achieves precision scores of 73%, on average, across all data sets with some test suites achieving precision scores good enough for fully automated classification (i.e., precision scores of up to 100%), and recall scores of 82% on average (up to 94%).;;;https://dl.acm.org/doi/10.1145/3468264.3473931;;;Software AND Engineering
Connecting the dots: rethinking the relationship between code and prose writing with functional connectivity;;;['Zachary Karas', 'Andrew Jahn', 'Westley Weimer', 'Yu Huang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Medical imaging studies of software engineering have risen in popularity and may reveal the neural underpinnings of coding activities. To date, however, all studies in computer science venues have treated brain regions independently and in isolation. Since most complex neural activity involves coordination among multiple regions, previous analyses may overlook neural behavior.  We propose to apply functional connectivity analysis to medical imaging data from software engineering tasks. Informally, this analysis treats the brain as a graph, rather than a series of independent modules, and statistically infers relevant edges. We present a functional connectivity analysis of existing data, which elucidates the interconnections between code writing and prose writing, especially regarding higher mathematics and semantic processing. First, we found a significant link between Broca’s Area (language) and the Number Form Area (higher mathematics) for coding. This both refines previous interpretations that code writing and natural language are distinct from each other, and may also contribute to the understanding of the Number Form Area in the Psychology literature. Second, we identify an area with important functional connectivity for both prose writing and coding, unlike previous analyses that associated it with coding. This advances our neural understanding of coding and prose writing, and was only exposed by using functional connectivity analysis. Third, for coding, we find a strong functional connectivity result for a brain region involved in semantic processing for language, with implications for CS training. Finally, we find a neural relationship between coding and expertise, including a more grounded explanation than prior work.;;;https://dl.acm.org/doi/10.1145/3468264.3468579;;;Software AND Engineering
Development of RISC-V Based Soft-core Processor with Scalable Vector Extension for Embedded System;;;['Yoshiki Kimura', 'Kanemitsu Ootsu', 'Tatsuya Tsuchiya', 'Takashi Yokota'];;;June 2021;;;ACIT '21: Proceedings of the the 8th International Virtual Conference on Applied Computing &amp; Information Technology;;;Recently, the opportunity to use FPGA in the field of embedded computer system has increased. However, the development cost using FPGA is quite high. We can reduce the cost by limiting the development of the dedicated circuit to the essenially required part of the system and by using soft-core processor together. If the performance of the soft-core processor improves, the development cost can be suppressed, since the amount of the dedicated circuit can be reduced. Furthermore, even in the field of embedded system, the opportunity for data parallel processing such as image processing is increasing. We consider that it is important merit of soft-core processor with SIMD extension that the computation performance can be optimized to the system by changing the number of parallel computing units according to the application. However, it is an obstacle that the software for soft-core processor needs to be changed every time we change the number of computing units. Thus, vector processing facility should provide the scalability that means the number of computing units can be changed without changing the program code. In this paper, we develop a RISC-V based soft-core processor with the scalable vector extension.;;;https://dl.acm.org/doi/10.1145/3468081.3471061;;;Software AND Engineering
Pathfinder: The Behavioural and Motivational Effects of Collectibles in Gamified Software Training;;;['Tim Naglé', 'Scott Bateman', 'Max V. Birk'];;;None;;;Proceedings of the ACM on Human-Computer Interaction;;;Designers of instructional software use gamification to help motivate and engage learners. Typically focusing on gamifying a single task, designers aim to provide a straightforward path through learning. In contrast, video games frequently provide optional secondary tasks using collectibles. Collectibles-like coins-are secondary, non-essential goals that encourage players to selectively take on additional challenges and engage more with a game. While research supports the idea that by increasing engagement learning can be improved, exactly how collectibles-an extremely common element in games-might be employed in gamified learning and how it might affect the play experience is underexplored. We present the results of a study comparing a gamified photo-editing training game that uses collectibles to one without collectibles. Our results show that learners choose to engage more when collectibles are present, and that this has a positive effect on software skills applied to a representative out-of-game challenge. Our findings provide a nuanced view of the tradeoffs in motivation and experience when collectibles are used.;;;https://dl.acm.org/doi/10.1145/3474691;;;Software AND Engineering
Refactoring practices in the context of modern code review: an industrial case study at Xerox;;;['Eman Abdullah AlOmar', 'Hussein AlRubaye', 'Mohamed Wiem Mkaouer', 'Ali Ouni', 'Marouane Kessentini'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Modern code review is a common and essential practice employed in both industrial and open-source projects to improve software quality, share knowledge, and ensure conformance with coding standards. During code review, developers may inspect and discuss various changes including refactoring activities before merging code changes in the code base. To date, code review has been extensively studied to explore its general challenges, best practices and outcomes, and socio-technical aspects. However, little is known about how refactoring activities are being reviewed, perceived, and practiced. This study aims to reveal insights into how reviewers develop a decision about accepting or rejecting a submitted refactoring request, and what makes such review challenging. We present an industrial case study with 24 professional developers at Xerox. Particularly, we study the motivations, documentation practices, challenges, verification, and implications of refactoring activities during code review. Our study delivers several important findings. Our results report the lack of a proper procedure to follow by developers when documenting their refactorings for review. Our survey with reviewers has also revealed several difficulties related to understanding the refactoring intent and implications on the functional and non-functional aspects of the software. In light of our findings, we recommended a procedure to properly document refactoring activities, as part of our survey feedback.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00044;;;Software AND Engineering
Is secure coding education in the industry needed?: an investigation through a large scale survey;;;['Tiago Espinha Gasiba', 'Ulrike Lechner', 'Maria Pinto-Albuquerque', 'Daniel Mendez'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;The Department of Homeland Security in the United States estimates that 90% of software vulnerabilities can be traced back to defects in design and software coding. The financial impact of these vulnerabilities has been shown to exceed 380 million USD in industrial control systems alone. Since software developers write software, they also introduce these vulnerabilities into the source code. However, secure coding guidelines exist to prevent software developers from writing vulnerable code. This study focuses on the human factor, the software developer, and secure coding, in particular secure coding guidelines. We want to understand the software developers' awareness and compliance to secure coding guidelines and why, if at all, they aren't compliant or aware. We base our results on a large-scale survey on secure coding guidelines, with more than 190 industrial software developers. Our work's main contribution motivates the need to educate industrial software developers on secure coding guidelines, and it gives a list of fifteen actionable items to be used by practitioners in the industry. We also make our raw data openly available for further research.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00034;;;Software AND Engineering
QFL: data-driven feedback loop to manage quality in Agile development;;;['Lidia López', 'Alessandra Bagnato', 'Antonin Ahbervé', 'Xavier Franch'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;Background: Quality requirements (QRs) describe desired system qualities, playing an important role in the success of software projects. In the context of agile software development (ASD), where the main objective is the fast delivery of functionalities, QRs are often ill-defined and not well addressed during the development process. Software analytics tools help to control quality though the measurement of quality-related software aspects to support decision-makers in the process of QR management. Aim: The goal of this research is to explore the benefits of integrating a concrete software analytics tool, Q-Rapids Tool, to assess software quality and support QR management processes. Method: In the context of a technology transfer project, the Softeam company has integrated Q-Rapids Tool in their development process. We conducted a series of workshops involving Softeam members working in the Modelio product development. Results: We present the Quality Feedback Loop (QFL) process to be integrated in software development processes to control the complete QR life-cycle, from elicitation to validation. As a result of the implementation of QFL in Softeam, Modelio's team members highlight the benefits of integrating a data analytics tool with their project planning tool and the fact that project managers can control the whole process making the final decisions. Conclusions: Practitioners can benefit from the integration of software analytics tools as part of their software development toolchain to control software quality. The implementation of QFL promotes quality in the organization and the integration of software analytics and project planning tools also improves the communication between teams.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00015;;;Software AND Engineering
A longitudinal analysis of bloated Java dependencies;;;['César Soto-Valero', 'Thomas Durieux', 'Benoit Baudry'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;We study the evolution and impact of bloated dependencies in a single software ecosystem: Java/Maven. Bloated dependencies are third-party libraries that are packaged in the application binary but are not needed to run the application. We analyze the history of 435 Java projects. This historical data includes 48,469 distinct dependencies, which we study across a total of 31,515 versions of Maven dependency trees. Bloated dependencies steadily increase over time, and 89.2% of the direct dependencies that are bloated remain bloated in all subsequent versions of the studied projects. This empirical evidence suggests that developers can safely remove a bloated dependency. We further report novel insights regarding the unnecessary maintenance efforts induced by bloat. We find that 22% of dependency updates performed by developers are made on bloated dependencies, and that Dependabot suggests a similar ratio of updates on bloated dependencies.;;;https://dl.acm.org/doi/10.1145/3468264.3468589;;;Software AND Engineering
DeepPM: transformer-based power and performance prediction for energy-aware software;;;['Jun S. Shim', 'Bogyeong Han', 'Yeseong Kim', 'Jihong Kim'];;;March 2022;;;DATE '22: Proceedings of the 2022 Conference &amp; Exhibition on Design, Automation &amp; Test in Europe;;;Many system-level management and optimization techniques need accurate estimates of power consumption and performance. Earlier research has proposed many high-level/source-level estimation modeling works, particularly for basic blocks. However, most of them still need to execute the target software at least once on a fine-grained simulator or real hardware to extract required features. This paper proposes a performance/power prediction framework, called Deep Power Meter (DeepPM), which estimates them accurately only using the compiled binary. Inspired by the deep learning techniques in natural language processing, we convert the program instructions in the form of vectors and predict the average power and performance of basic blocks based on a transformer model. In addition, unlike existing works based on a Long Short-Term Memory (LSTM) model structure, which only works for basic blocks with a small number of instructions, DeepPM provides highly accurate results for long basic blocks, which takes the majority of the execution time for actual application runs. In our evaluation conducted with SPEC2006 benchmark suite, we show that DeepPM can provide accurate prediction for performance and power consumption with 10.2% and 12.3% error, respectively. DeepPM also outperforms the LSTM-based model by up to 67.2% and 34.9% error for performance and power, respectively.;;;https://dl.acm.org/doi/10.5555/3539845.3540190;;;Software AND Engineering
Fundamental contemplation on the adequacy of the analysis of brain waves: case of EEG;;;['Ananga Thapaliya', 'Rozaliya Amirova', 'Sara Busechian', 'Vladimir Ivanov', 'Sergey Masyagin', 'Ruslan Shakirov', 'Giancarlo Succi', 'Herman Tarasau', 'Alexander Tormasov', 'Oydinoy Zufarova'];;;April 2021;;;ICCAI '21: Proceedings of the 2021 7th International Conference on Computing and Artificial Intelligence;;;In recent years, the use of biological signals to understand the operations of software engineers has emerged, although with a limited understanding of its successful application. This paper provides primary evidence that biological signals obtained by electroencephalography (EEG) may provide valuable information from the perspective of software engineers, who then decode the adequacy, consistency, and efficiency of their work. The experimentation with 20 different professional male software engineers has been completed. Two natural situations have been investigated: pair programming and programming with (without) music. The early findings show the methodology’s effectiveness.;;;https://dl.acm.org/doi/10.1145/3467707.3467742;;;Software AND Engineering
Decoupling server and client code through cloud-native domain-specific functions;;;['Jose Miguel Perez-Alvarez', 'Adrian Mos', 'Benjamin V. Hanrahan', 'Iyadunni J. Adenuga'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Simple domain-specific graphical languages and libraries can empower a variety of users to create application behavior and logic. However, it remains challenging to produce and maintain a heterogeneous set of client applications based on these descriptions, as each client typically requires the developers to both understand and embed the domain-specific logic. This is because application logic must be encoded to some extent in both the server and client sides. In this paper, we propose an alternative approach, which allows the specification of application logic to reside solely on the cloud. In our system, reusable application components are assembled on the cloud in different logical chains and the client is solely concerned with how data is displayed and gathered from users. In this way, the chaining of requests and responses is done by the cloud and the client side has no knowledge of the application logic. This means that the experts in the domain build modular cloud components, arrange them in logical chains, generate a simple user interface, and later leave it to client-side developers to customize the presentation.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678747;;;Software AND Engineering
An evolutionary study of configuration design and implementation in cloud systems;;;['Yuanliang Zhang', 'Haochen He', 'Owolabi Legunsen', 'Shanshan Li', 'Wei Dong', 'Tianyin Xu'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Many techniques have been proposed for detecting software misconfigurations and diagnosing unintended behavior caused by misconfigurations in cloud systems. Detection and diagnosis are steps in the right direction: misconfigurations cause many costly failures and severe performance issues. But, we argue that continued focus on detection and diagnosis is symptomatic of a more serious problem: configuration design and implementation are not yet first-class software engineering endeavors in cloud systems. Little is known about how and why developers evolve configuration design and implementation, and the challenges that they face in doing so.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00075;;;Software AND Engineering
Improving concept learning through specialized digital fanzines;;;['Jose Manuel Redondo'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Specialized digital fanzines were successfully used to facilitate learning problematic concepts in an undergraduate programming course, dynamically adapting to student needs. The design of these fanzines favors creating and reading them quickly by establishing a common graphical layout, rules, and focusing in the most problematic parts of the concepts. This paper details the agile fanzine creation procedure, the way problematic concepts were identified and quickly handled, and how this approach was implemented in an actual course, so it could be applied to other courses with similar needs.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00023;;;Software AND Engineering
Promoting Privacy Considerations in Real-World Projects in Capstone Courses with Ideation Cards;;;['Ying Tang', 'Morgan L. Brockman', 'Sameer Patil'];;;None;;;ACM Transactions on Computing Education;;;Nearly all software built today impinges upon end-user privacy and needs to comply with relevant regulations. Therefore, there have been increasing calls for integrating considerations of compliance with privacy regulations throughout the software engineering lifecycle. However, software engineers are typically trained in the technical fields and lack sufficient knowledge and support for sociotechnical considerations of privacy. Privacy ideation cards attempt to address this issue by making privacy compliance understandable and actionable for software developers. However, the application of privacy ideation cards in real-world software projects has not yet been systemically investigated. The effectiveness of ideation cards as a pedagogical tool has not yet been examined either. We address these gaps by studying how teams of undergraduate students applied privacy ideation cards in capstone projects that involved building real-world software for industry sponsors. We found that privacy ideation cards fostered greater consideration and understanding of the extent to which the projects aligned with privacy regulations. We identified three main themes from student discussions of privacy compliance: (i) defining personal data; (ii) assigning responsibility for privacy compliance; and (iii) determining and exercising autonomy. The results suggest that application of the cards for real-world projects requires careful consideration of intersecting factors such as the stage at which the cards are used and the autonomy available to the developers. Pedagogically, ideation cards can facilitate low-level cognitive engagement (especially the cognitive processes of meaning construction and interpretation) for specific components within a project. Higher-level cognitive processes were comparatively rare in ideation sessions. These findings provide important insight to help enhance capstone instruction and to improve privacy ideation cards to increase their impact on the privacy properties of the developed software.;;;https://dl.acm.org/doi/10.1145/3458038;;;Software AND Engineering
An Intelligent System to Analyze Sketched Solutions to Open-Ended Truss Problems;;;['Matthew Runyon', 'Seth Polsley', 'Blake Williford', 'Sin-Ning Cindy Liu', 'Josh Hurt', 'Julie Linsey', 'Tracy Hammond'];;;April 2021;;;IUI '21: 26th International Conference on Intelligent User Interfaces;;;Engineering students need practical, open-ended problems to help them build their problem-solving skills and design abilities. However, large class sizes create a grading challenge for instructors as there is simply not enough time nor support to provide adequate feedback on many design problems. In this work, we describe an intelligent user interface to provide automated real-time feedback on hand-drawn free body diagrams that is capable of analyzing the internal forces of a sketched truss to evaluate open-ended design problems. The system is driven by sketch recognition algorithms developed for recognizing trusses and a robust linear algebra approach for analyzing trusses. Students in an introductory statics course were assigned a truss design problem as a homework assignment using either paper or our software. We used conventional content analysis on four focus groups totaling 16 students to identify key aspects of their experiences with the design problem and our software. We found that the software correctly analyzed all student submissions, students enjoyed the problem compared to typical homework assignments, and students found the problem to be good practice. Additionally, students using our software reported less difficulty understanding the problem, and the majority of all students said they would prefer the software approach over pencil and paper. We also evaluated the recognition performance on a set of 3000 sketches resulting in an f-score of 0.997. We manually reviewed the submitted student work which showed the handful of student complaints about recognition were largely due to user error.;;;https://dl.acm.org/doi/10.1145/3397481.3450651;;;Software AND Engineering
Learning autocompletion from real-world datasets;;;['Gareth Ari Aye', 'Seohyun Kim', 'Hongyu Li'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Code completion is a popular software development tool integrated into all major IDEs. Many neural language models have achieved promising results in completion suggestion prediction on synthetic benchmarks. However, a recent study When Code Completion Fails: a Case Study on Real-World Completions demonstrates that these results may not translate to improvements in real-world performance. To combat this effect, we train models on real-world code completion examples and find that these models outperform models trained on committed source code and working version snapshots by 12.8% and 13.8% accuracy respectively. We observe this improvement across modeling technologies and show through A/B testing that it corresponds to a 6.2% increase in programmers' actual autocompletion usage. Furthermore, our study characterizes a large corpus of logged autocompletion usages to investigate why training on real-world examples leads to stronger models.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00022;;;Software AND Engineering
The Impact on the Test Coverage Caused by the Introduction of Adaptive Behavior in a Legacy Web Application: A Case Study;;;['Rogerio Jeronimo Gentil', 'Daniel de Paula Porto', 'Fabiano Cutigi Ferrari'];;;September 2021;;;SAST '21: Proceedings of the 6th Brazilian Symposium on Systematic and Automated Software Testing;;;Self-Adaptive systems (ASs) are an alternative to get IT professionals free from details of operation and maintenance. Web applications can incorporate characteristics of an AS in order to make them autonomous. However, one of the challenges of software engineering is to transform a legacy system into an AS. Furthermore, transforming a legacy system into an AS can lead to the insertion of faults. This way, the code coverage information produced by software tests assist in activities related to the evolutionary maintenance of the system. In this work, we analyzed, through the comparison of coverage metrics, how the introduction of adaptive behaviors in a real world legacy web application impacted on code coverage. For each implemented scenario, a set of test cases was created in the legacy version of the web application. Then, evolutionary versions were developed with the introduction of adaptive behavior. The versions (legacy and adaptive) were organized into branches of the version control system so that adaptive implementations have evolved in two technological ways. The coverage metrics for each version of the web application were collected to allow data analysis. Beyond the legacy version, we analyzed the coverage of six versions of the web application with adaptive behavior. The results indicate that the impact on the total code coverage is relevant, where even relatively small changes can considerably affect, either positively or negatively, the percentage of coverage of the changed unit.;;;https://dl.acm.org/doi/10.1145/3482909.3482914;;;Software AND Engineering
Finding broken Linux configuration specifications by statically analyzing the Kconfig language;;;['Jeho Oh', 'Necip Fazıl Yıldıran', 'Julian Braha', 'Paul Gazzillo'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Highly-configurable software underpins much of our computing infrastructure. It enables extensive reuse, but opens the door to broken configuration specifications. The configuration specification language, Kconfig, is designed to prevent invalid configurations of the Linux kernel from being built. However, the astronomical size of the configuration space for Linux makes finding specification bugs difficult by hand or with random testing. In this paper, we introduce a software model checking framework for building Kconfig static analysis tools. We develop a formal semantics of the Kconfig language and implement the semantics in a symbolic evaluator called kclause that models Kconfig behavior as logical formulas. We then design and implement a bug finder, called kismet, that takes kclause models and leverages automated theorem proving to find unmet dependency bugs. kismet is evaluated for its precision, performance, and impact on kernel development for a recent version of Linux, which has over 140,000 lines of Kconfig across 28 architecture-specific specifications. Our evaluation finds 781 bugs (151 when considering sharing among Kconfig specifications) with 100% precision, spending between 37 and 90 minutes for each Kconfig specification, although it misses some bugs due to underapproximation. Compared to random testing, kismet finds substantially more true positive bugs in a fraction of the time.;;;https://dl.acm.org/doi/10.1145/3468264.3468578;;;Software AND Engineering
TimeCache: using time to eliminate cache side channels when sharing software;;;['Divya Ojha', 'Sandhya Dwarkadas'];;;June 2021;;;ISCA '21: Proceedings of the 48th Annual International Symposium on Computer Architecture;;;Timing side channels have been used to extract cryptographic keys and sensitive documents even from trusted enclaves. Specifically, cache side channels created by reuse of shared code or data in the memory hierarchy have been exploited by several known attacks, e.g., evict+reload for recovering an RSA key and Spectre variants for leaking speculatively loaded data. In this paper, we present TimeCache, a cache design that incorporates knowledge of prior cache line access to eliminate cache side channels due to reuse of shared software (code and data). Our goal is to retain the benefits of a shared cache of allowing each process access to the entire cache and of cache occupancy by a single copy of shared software. We achieve our goal by implementing per-process cache line visibility so that the processes do not benefit from cached data brought in by another process until they have incurred a corresponding miss penalty. Our design achieves low overhead by using a novel combination of timestamps and a hardware design to allow efficient parallel comparisons of the timestamps. The solution works at all the cache levels without the need to limit the number of security domains, and defends against an attacker process running on the same core, on a another hyperthread, or on another core. Our implementation in the gem5 simulator demonstrates that the system is able to defend against RSA key extraction. We evaluate performance using SPEC2006 and PARSEC and observe the overhead of TimeCache to be 1.13% on average. Delay due to first access misses adds the majority of the overhead, with the security context bookkeeping incurred at the time of a context switch contributing 0.02% of the 1.13%.;;;https://dl.acm.org/doi/10.1109/ISCA52012.2021.00037;;;Software AND Engineering
Leveraging code clones and natural language processing for log statement prediction;;;['Sina Gholamian'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Software developers embed logging statements inside the source code as an imperative duty in modern software development as log files are necessary for tracking down runtime system issues and troubleshooting system management tasks. Prior research has emphasized the importance of logging statements in the operation and debugging of software systems. However, the current logging process is mostly manual and ad hoc, and thus, proper placement and content of logging statements remain as challenges. To overcome these challenges, methods that aim to automate log placement and log content, i.e., 'where, what, and how to log', are of high interest. Thus, we propose to accomplish the goal of this research, that is "to predict the log statements by utilizing source code clones and natural language processing (NLP)", as these approaches provide additional context and advantage for log prediction. We pursue the following four research objectives: (RO1) investigate whether source code clones can be leveraged for log statement location prediction, (RO2) propose a clone-based approach for log statement prediction, (RO3) predict log statement's description with code-clone and NLP models, and (RO4) examine approaches to automatically predict additional details of the log statement, such as its verbosity level and variables. For this purpose, we perform an experimental analysis on seven open-source java projects, extract their method-level code clones, investigate their attributes, and utilize them for log location and description prediction. Our work demonstrates the effectiveness of log-aware clone detection for automated log location and description prediction and outperforms the prior work.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678596;;;Software AND Engineering
One-shot Learning of Fusion Model in Patient Identity Recognition in ICU Ward;;;['Yiming Wu', 'YuLian Gao', 'Gehao Lu', 'Fei Wang'];;;November 2021;;;ICISE '21: Proceedings of the 6th International Conference on Information Systems Engineering;;;The number of patients in the ICU ward is relatively small, if traditional deep learning is used for access control recognition. You need to use a large number of data sets, which will inevitably consume a lot of time. And One-Shot Learning can realize only one or several different facial expression images of each patient. Then the identity of the current patient can be correctly identified. This method has huge advantages over traditional deep learning methods that require hundreds or thousands of samples. This paper combines Resnet152 to complete the extraction of facial features, and then uses the twin network composed of Resnet152 to generate the facial similarity calculation function. Use the face data set to train the formed twin network, and then collect a facial image of each patient in the ward to make a support set. Support Set does not need to participate in network training. It can directly compare the similarity with the currently queried picture. Support Set can be added and deleted according to the latest patients in the ward, which will not affect the accuracy of the system. The generated similarity calculation function is used to calculate which face in the current support set is most similar to it, thereby determining the identity of the current person.;;;https://dl.acm.org/doi/10.1145/3503928.3503935;;;Software AND Engineering
Towards First-Class Architectural Connectors: The Case for Self-Adaptive Service Meshes;;;['Nabor Mendonca', 'Carlos Aderaldo'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The development of architectural connectors as first-class software entities is a long-standing software engineering promise that has not been fully realized thus far. This observation is especially true in self-adaptive software systems, where most advances within academia and industry have targeted software components as the primary locus for run-time adaptation. In this paper, we revisit the evolutionary history of architectural connectors and discuss the challenges of implementing architectural connectors as first-class self-adaptation entities in the domain of modern microservice applications. We then make a case for our ongoing work on a cloud-native self-adaptive service mesh framework that builds on recent container orchestration, self-adaptation, and service mesh technologies.;;;https://dl.acm.org/doi/10.1145/3474624.3477072;;;Software AND Engineering
SSD Target Detection Algorithm Based on Multi-Scale Fusion and Attention;;;['Chenyang Jin', 'Lei Li', 'Mengting Li', 'Yijian Pei'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;Aiming at the problems of weak effective information in feature maps and high miss-detection rate of difficult targets when traditional SSD target detection algorithms perform target detection, we propose an improved SSD target detection algorithm. First, add a CBAM module after each feature layer of the SSD. CBAM is a hybrid module that combines spatial attention and channel attention. This module strengthens the network's ability to discriminate targets and backgrounds, improves the expression of effective feature weights, and suppresses interference from irrelevant information; then, adopt the idea of FPN to construct a feature fusion module, which effectively integrates feature layers of different scales, thereby improving the network's ability to detect difficult targets. Verifying the method proposed in this paper on the PASCAL VOC data set fully proves that the improved network performance has been greatly improved.;;;https://dl.acm.org/doi/10.1145/3487075.3487087;;;Software AND Engineering
Towards a More Structured Peer Review Process with Empirical Standards;;;['Arham Arshad', 'Taher Ghaleb', 'Paul Ralph'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Context. Empirical research consistently demonstrates that that scholarly peer review is ineffective, unreliable, and prejudiced. In principle, the solution is to move from contemporary, unstructured, essay-like reviewing to more structured, checklist-like reviewing. The Task Force created models—called “empirical standards”—of the software engineering community’s expectations for different popular methodologies. Objective. This paper presents a tool for facilitating more structured reviewing by generating review checklists from the empirical standards. Design. A tool that generates pre-submission and review forms using the empirical standards for software engineering research was designed and implemented. The pre-submission and review forms can be used by authors and reviewers, respectively, to determine whether a manuscript meets the software engineering community’s expectations for the particular kind of research conducted. Evaluation. The proposed tool can be empirically evaluated using lab or field randomized experiments as well as qualitative research. Huge, impractical studies involving splitting a conference program committee are not necessary to establish the effectiveness of the standards, checklists and structured review. Conclusions. The checklist generator enables more structured peer reviews, which in turn should improve review quality, reliability, thoroughness, and readability. Empirical research is needed to assess the effectiveness of the tool and the standards.;;;https://dl.acm.org/doi/10.1145/3463274.3463359;;;Software AND Engineering
Design and Implementation of Enterprise Marketing System Based on Rule Engine Drools;;;['Zhaoxi Chen', 'Shengnan Zhou'];;;September 2021;;;ICISCAE 2021: 2021 4th International Conference on Information Systems and Computer Aided Education;;;None;;;https://dl.acm.org/doi/10.1145/3482632.3484122;;;Software AND Engineering
A TCP Congestion Control Algorithm Based on Deep Reinforcement Learning Combined with Probe Bandwidth Mechanism;;;['Mengting Li', 'Xiang Huang', 'Chengyang Jin', 'Yijian Pei'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;The rapid development of emerging Internet services such as live video, 5G, VR, and the Internet of Things puts forward higher requirements for network throughput, Latency, jitter, and loss. However, the inefficient bandwidth utilization rate of the existing TCP protocol cannot meet these requirements. Based on this problem, this paper proposes an algorithm RL-explore that uses RL (Reinforcement learning) combined with bandwidth detection mechanism. The model trained with this algorithm can effectively use the network bandwidth, and compared to other RL algorithms, it is easier to converge during training.;;;https://dl.acm.org/doi/10.1145/3487075.3487119;;;Software AND Engineering
Web Application Testing: Using Tree Kernels to Detect Near-duplicate States in Automated Model Inference;;;['Anna Corazza', 'Sergio Di Martino', 'Adriano Peron', 'Luigi Libero Lucio Starace'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: In the context of End-to-End testing of web applications, automated exploration techniques (a.k.a. crawling) are widely used to infer state-based models of the site under test. These models, in which states represent features of the web application and transitions represent reachability relationships, can be used for several model-based testing tasks, such as test case generation. However, current exploration techniques often lead to models containing many near-duplicate states, i.e., states representing slightly different pages that are in fact instances of the same feature. This has a negative impact on the subsequent model-based testing tasks, adversely affecting, for example, size, running time, and achieved coverage of generated test suites. Aims: As a web page can be naturally represented by its tree-structured DOM representation, we propose a novel near-duplicate detection technique to improve the model inference of web applications, based on Tree Kernel (TK) functions. TKs are a class of functions that compute similarity between tree-structured objects, largely investigated and successfully applied in the Natural Language Processing domain. Method: To evaluate the capability of the proposed approach in detecting near-duplicate web pages, we conducted preliminary classification experiments on a freely-available massive dataset of about 100k manually annotated web page pairs. We compared the classification performance of the proposed approach with other state-of-the-art near-duplicate detection techniques. Results: Preliminary results show that our approach performs better than state-of-the-art techniques in the near-duplicate detection classification task. Conclusions: These promising results show that TKs can be applied to near-duplicate detection in the context of web application model inference, and motivate further research in this direction to assess the impact of the technique on the quality of the inferred models and on the subsequent application of model-based testing techniques.;;;https://dl.acm.org/doi/10.1145/3475716.3484187;;;Software AND Engineering
Towards Automated Drafting in CAD Systems;;;['Mladen Buric', 'Mario Brcic', 'Stanko Skec'];;;December 2021;;;EEET 2021: 2021 4th International Conference on Electronics and Electrical Engineering Technology;;;The drafting or technical drawing of mechanical parts is a common activity during the phase of detailed design. Traditionally, engineering drawings are created manually by draftspersons with the support of CAD software, which is a time-consuming and error-prone task, requiring significant experience and a high level of technical expertise. To automate and accelerate this task, the present work introduces a new automatic drafting tool named iDrafter which enables the creation of 2D engineering drawings out of the 3D model's boundary representation (B-Rep). The iDrafter algorithm has been developed using a state-of-the-art CAD system Application Programming Interface (API) and incorporated into this system. The tool covers not only the dimensioning, but also other aspects of automatic drafting such as the creation of the drawing document, drawing sheet, and the corresponding views. To verify the algorithm, different CAD models have been subjected to testing.;;;https://dl.acm.org/doi/10.1145/3508297.3508335;;;Software AND Engineering
Towards evidence-based testability measurements;;;['Luca Guglielmo', 'Andrea Riboni', 'Giovanni Denaro'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Evaluating Software testability can assist software managers in optimizing testing budgets and identifying opportunities for refactoring. In this paper, we abandon the traditional approach of pursuing testability measurements based on the correlation between software metrics and test characteristics observed on past projects, e.g., the size, the organization or the code coverage of the test cases. We propose a radically new approach that exploits automatic test generation and mutation analysis to quantify the amount of evidence about the relative hardness of identifying effective test cases. We introduce two novel evidence-based testability metrics, describe a prototype to compute them, and discuss initial findings on whether our measurements can reflect actual testability issues.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00024;;;Software AND Engineering
A Study on Variability for Multi-Device Rendering in Digital Music Publishing;;;['Paul Grünbacher'];;;February 2022;;;VaMoS '22: Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;;;Domain-specific languages (DSLs) offer expressive support for particular problem domains and promise substantial gains compared to general-purpose languages (GPLs). Variability management techniques have been successfully and widely applied in software development for GPLs. This paper describes an exploratory study on using variability management in the context of DSLs for digital publishing. Specifically, the paper presents a digital publishing workflow complementing a music engraving DSL to automatically create musical scores for diverse mobile devices. The paper illustrates variability challenges and shows how the approach links different variability mechanisms in a fully-automated workflow. The evaluation based on an archive of 141 digital music artifacts shows that 98,3% of all pages were correctly rendered. Further, the performance results show a strong correlation of the input size with the engraving time regardless of the kind of device. The paper discusses lessons learned and outlines opportunities for further research.;;;https://dl.acm.org/doi/10.1145/3510466.3510482;;;Software AND Engineering
Automatically Matching Bug Reports With Related App Reviews;;;['Marlo Haering', 'Christoph Stanik', 'Walid Maalej'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;App stores allow users to give valuable feedback on apps, and developers to find this feedback and use it for the software evolution. However, finding user feedback that matches existing bug reports in issue trackers is challenging as users and developers often use a different language. In this work, we introduce DeepMatcher, an automatic approach using state-of-the-art deep learning methods to match problem reports in app reviews to bug reports in issue trackers. We evaluated DeepMatcher with four open-source apps quantitatively and qualitatively. On average, DeepMatcher achieved a hit ratio of 0.71 and a Mean Average Precision of 0.55. For 91 problem reports, DeepMatcher did not find any matching bug report. When manually analyzing these 91 problem reports and the issue trackers of the studied apps, we found that in 47 cases, users actually described a problem before developers discovered and documented it in the issue tracker. We discuss our findings and different use cases for DeepMatcher.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00092;;;Software AND Engineering
MOLEGA: modeling language for educational card games;;;['Kaylynn Borror', 'Eric J. Rapos'];;;October 2021;;;DSM 2021: Proceedings of the 18th ACM SIGPLAN International Workshop on Domain-Specific Modeling;;;Domain-specific modeling languages abstractly represent domain knowledge in a way that users can more easily understand the model content without technical expertise. These languages can be created for any domain, provided the necessary knowledge is available. This research uses educational game design as a demonstration of the power of domain-specific modeling. Games are useful tools in supplementing the traditional education of students, however, many educators often do not possess the design or technical skills to develop a custom game for their own use. MOLEGA (the Modeling Language for Educational Card Games) is a domain-specific modeling language that provides a guided model design environment for these users. Using MOLEGA, users can create visual models, inspired by UML class diagrams, to represent their desired card game, based on two selected variants. User models are then used to generate executable source code for a mobile-compatible, browser-based game that can be deployed on a server by following the provided instructions. MOLEGA is evaluated for validity and correctness using a suite of example models.;;;https://dl.acm.org/doi/10.1145/3486603.3486777;;;Software AND Engineering
Dicos: Discovering Insecure Code Snippets from Stack Overflow Posts by Leveraging User Discussions;;;['Hyunji Hong', 'Seunghoon Woo', 'Heejo Lee'];;;December 2021;;;ACSAC '21: Proceedings of the 37th Annual Computer Security Applications Conference;;;Online Q&A fora such as Stack Overflow assist developers to solve their faced coding problems. Despite the advantages, Stack Overflow has the potential to provide insecure code snippets that, if reused, can compromise the security of the entire software.  We present Dicos, an accurate approach by examining the change history of Stack Overflow posts for discovering insecure code snippets. When a security issue was detected in a post, the insecure code is fixed to be safe through user discussions, leaving a change history. Inspired by this process, Dicos first extracts the change history from the Stack Overflow post, and then analyzes the history whether it contains security patches, by utilizing pre-selected features that can effectively identify security patches. Finally, when such changes are detected, Dicos determines that the code snippet before applying the security patch is insecure.  To evaluate Dicos, we collected 1,958,283 Stack Overflow posts tagged with C, C++, and Android. When we applied Dicos on the collected posts, Dicos discovered 12,458 insecure posts (i.e., 14,719 insecure code snippets) from the collected posts with 91% precision and 93% recall. We further confirmed that the latest versions of 151 out of 2,000 popular C/C++ open-source software contain at least one insecure code snippet taken from Stack Overflow, being discovered by Dicos. Our proposed approach, Dicos, can contribute to preventing further propagation of insecure codes and thus creating a safe code reuse environment.;;;https://dl.acm.org/doi/10.1145/3485832.3488026;;;Software AND Engineering
Handling Test Smells in Python: Results from a Mixed-Method Study;;;['Daniel Fernandes', 'Ivan Machado', 'Rita Maciel'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software testing is an activity in the software development process that looks for defects. Automated testing is composed of code that allows run software testing scenarios more quickly, avoiding manual rework. However, testers are likely to employ practices that might negatively impact test quality regarding maintainability, understandability, and effectiveness when writing test code. Such bad practices are also known as test smells. Although test smells are a language-independent concept, different programming languages could present different occurrence standards. Therefore, studies in one programming language may not be generalizable. This study aims to investigate how test smells occurrence in Python test files. Python became the most widely used programming language globally in 2020. However, most research on test code quality only considers the Java language. To accomplish our goals, we built a dataset with 5,303 test files from 90 Python projects collected from GitHub repositories to understand and analyze strategies for handling test smells in Python. This analysis allowed us to propose four new test smells, discussing their potential problems. We carried out a preliminary evaluation with 40 Python developers to validate their thoughts on the proposed test smells. These results are part of an ongoing research project aiming to propose a foundation to better support automation tests in Python.;;;https://dl.acm.org/doi/10.1145/3474624.3477066;;;Software AND Engineering
TransRegex: Multi-modal Regular Expression Synthesis by Generate-and-Repair;;;['Yeting Li', 'Shuaimin Li', 'Zhiwu Xu', 'Jialun Cao', 'Zixuan Chen', 'Yun Hu', 'Haiming Chen', 'Shing-Chi Cheung'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Since regular expressions (abbrev. regexes) are difficult to understand and compose, automatically generating regexes has been an important research problem. This paper introduces TRANSREGEX, for automatically constructing regexes from both natural language descriptions and examples. To the best of our knowledge, TransRegex is the first to treat the NLP-and-example-based regex synthesis problem as the problem of NLP-based synthesis with regex repair. For this purpose, we present novel algorithms for both NLP-based synthesis and regex repair. We evaluate TransRegex with ten relevant state-of-the-art tools on three publicly available datasets. The evaluation results demonstrate that the accuracy of our TransRegex is 17.4%, 35.8% and 38.9% higher than that of NLP-based approaches on the three datasets, respectively. Furthermore, TransRegex can achieve higher accuracy than the state-of-the-art multi-modal techniques with 10% to 30% higher accuracy on all three datasets. The evaluation results also indicate TransRegex utilizing natural language and examples in a more effective way.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00111;;;Software AND Engineering
Graph-based seed object synthesis for search-based unit testing;;;['Yun Lin', 'You Sheng Ong', 'Jun Sun', 'Gordon Fraser', 'Jin Song Dong'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Search-based software testing (SBST) generates tests using search algorithms guided by measurements gauging how far a test case is away from exercising a coverage goal. The effectiveness of SBST largely depends on the continuity and monotonicity of the fitness landscape decided by these measurements and the search operators. Unfortunately, the fitness landscape is challenging when the function under test takes object inputs, as classical measurement hardly provide guidance for constructing legitimate object inputs. To overcome this problem, we propose test seeds, i.e., test code skeletons of legitimate objects which enable the use of classical measurements. Given a target branch in a function under test, we first statically analyze the function to build an object construction graph that captures the relation between the operands of the target method and the states of their relevant object inputs. Based on the graph, we synthesize test template code where each "slot" is a mutation point for the search algorithm. This approach can be seamlessly integrated with existing SBST algorithms, and we implemented EvoObj on top of EvoSuite. Our experiments show that EvoObj outperforms EvoSuite with statistical significance on 2750 methods over 103 open source Java projects using state-of-the-art SBST algorithms.;;;https://dl.acm.org/doi/10.1145/3468264.3468619;;;Software AND Engineering
Towards a model-integrated runtime monitoring infrastructure for cyber-physical systems;;;['Michael Vierhauser', 'Hussein Marah', 'Antonio Garmendia', 'Jane Cleland-Huang', 'Manuel Wimmer'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Runtime monitoring is essential for ensuring the safe operation and enabling self-adaptive behavior of Cyber-Physical Systems (CPS). It requires the creation of system monitors, instrumentation for data collection, and the definition of constraints. All of these aspects need to evolve to accommodate changes in the system. However, most existing approaches lack support for the automated generation and setup of monitors and constraints for diverse technologies and do not provide adequate support for evolving the monitoring infrastructure. Without this support, constraints and monitors can become stale and become less effective in long-running, rapidly changing CPS. In this "new and emerging results" paper we propose a novel framework for model-integrated runtime monitoring. We combine model-driven techniques and runtime monitoring to automatically generate large parts of the monitoring framework and to reduce the maintenance effort necessary when parts of the monitored system change. We build a prototype and evaluate our approach against a system for controlling the flights of unmanned aerial vehicles.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00028;;;Software AND Engineering
Who does what?: work division and allocation strategies of computer science student teams;;;['Anna van der Meulen', 'Efthimia Aivaloglou'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Collaboration skills are important for future software engineers. In computer science education, these skills are often practiced through group assignments, where students develop software collaboratively. The approach that students take in these assignments varies widely, but often involves a division of labour. It can then be argued whether collaboration still takes place. The discipline of computing education is especially interesting in this context, because some of its specific features (such as the variation in entry skill level and the use of source code repositories as collaboration platforms) are likely to influence the approach taken within groupwork. The aim of this research is to gain insight into the work division and allocation strategies applied by computer science students during group assignments. To this end, we interviewed twenty students of four universities. The thematic analysis shows that students tend to divide up the workload to enable working independently, with pair programming and code reviews being often employed. Motivated primarily by grade and efficiency factors, students choose and allocate tasks primarily based on their prior expertise and preferences. Based on our findings, we argue that the setup of group assignments can limit students' motivation for practicing new software engineering skills, and that interventions are needed towards encouraging experimentation and learning.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00037;;;Software AND Engineering
On the Faults Found in REST APIs by Automated Test Generation;;;['Bogdan Marculescu', 'Man Zhang', 'Andrea Arcuri'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;RESTful web services are often used for building a wide variety of enterprise applications. The diversity and increased number of applications using RESTful APIs means that increasing amounts of resources are spent developing and testing these systems. Automation in test data generation provides a useful way of generating test data in a fast and efficient manner. However, automated test generation often results in large test suites that are hard to evaluate and investigate manually.This article proposes a taxonomy of the faults we have found using search-based software testing techniques applied on RESTful APIs. The taxonomy is a first step in understanding, analyzing, and ultimately fixing software faults in web services and enterprise applications. We propose to apply a density-based clustering algorithm to the test cases evolved during the search to allow a better separation between different groups of faults. This is needed to enable engineers to highlight and focus on the most serious faults.Tests were automatically generated for a set of eight case studies, seven open-source and one industrial. The test cases generated during the search are clustered based on the reported last executed line and based on the error messages returned, when such error messages were available. The tests were manually evaluated to determine their root causes and to obtain additional information.The article presents a taxonomy of the faults found based on the manual analysis of 415 faults in the eight case studies and proposes a method to support the classification using clustering of the resulting test cases.;;;https://dl.acm.org/doi/10.1145/3491038;;;Software AND Engineering
CuART - a CUDA-based, scalable Radix-Tree lookup and update engine;;;['Martin Koppehel', 'Tobias Groth', 'Sven Groppe', 'Thilo Pionteck'];;;August 2021;;;ICPP '21: Proceedings of the 50th International Conference on Parallel Processing;;;In this work we present an optimized version of the Adaptive Radix Tree (ART) index structure for GPUs. We analyze an existing GPU implementation of ART (GRT), identify bottlenecks and present an optimized data structure and layout to improve the lookup and update performance. We show that our implementation outperforms the existing approach by a factor up to 2 times for lookups and up to 10 times for updates using the same GPU. We also show that the sequential memory layout presented here is beneficial for lookup-intensive workloads on the CPU, outperforming the ART by up to 10 times. We analyze the impact of the memory architecture of the GPU, where it becomes visible that traditional GDDR6(X) is beneficial for the index lookups due to the faster clock rates compared to High Bandwidth Memory (HBM).;;;https://dl.acm.org/doi/10.1145/3472456.3472511;;;Software AND Engineering
FuzzBench: an open fuzzer benchmarking platform and service;;;['Jonathan Metzman', 'László Szekeres', 'Laurent Simon', 'Read Sprabery', 'Abhishek Arya'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Fuzzing is a key tool used to reduce bugs in production software. At Google, fuzzing has uncovered tens of thousands of bugs. Fuzzing is also a popular subject of academic research. In 2020 alone, over 120 papers were published on the topic of improving, developing, and evaluating fuzzers and fuzzing techniques. Yet, proper evaluation of fuzzing techniques remains elusive. The community has struggled to converge on methodology and standard tools for fuzzer evaluation.  To address this problem, we introduce FuzzBench as an open-source turnkey platform and free service for evaluating fuzzers. It aims to be easy to use, fast, reliable, and provides reproducible experiments. Since its release in March 2020, FuzzBench has been widely used both in industry and academia, carrying out more than 150 experiments for external users. It has been used by several published and in-the-work papers from academic groups, and has had real impact on the most widely used fuzzing tools in industry. The presented case studies suggest that FuzzBench is on its way to becoming a standard fuzzer benchmarking platform.;;;https://dl.acm.org/doi/10.1145/3468264.3473932;;;Software AND Engineering
Finding a needle in a haystack: automated mining of silent vulnerability fixes;;;['Jiayuan Zhou', 'Michael Pacheco', 'Zhiyuan Wan', 'Xin Xia', 'David Lo', 'Yuan Wang', 'Ahmed E. Hassan'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Following the coordinated vulnerability disclosure model, a vulnerability in open source software (OSS) is suggested to be fixed "silently", without disclosing the fix until the vulnerability is disclosed. Yet, it is crucial for OSS users to be aware of vulnerability fixes as early as possible, as once a vulnerability fix is pushed to the source code repository, a malicious party could probe for the corresponding vulnerability to exploit it. In practice, OSS users often rely on the vulnerability disclosure information from security advisories (e.g., National Vulnerability Database) to sense vulnerability fixes. However, the time between the availability of a vulnerability fix and its disclosure can vary from days to months, and in some cases, even years. Due to manpower constraints and the lack of expert knowledge, it is infeasible for OSS users to manually analyze all code changes for vulnerability fix detection. Therefore, it is essential to identify vulnerability fixes automatically and promptly. In a first-of-its-kind study, we propose VulFixMiner, a Transformer-based approach, capable of automatically extracting semantic meaning from commit-level code changes to identify silent vulnerability fixes. We construct our model using sampled commits from 204 projects, and evaluate using the full set of commits from 52 additional projects. The evaluation results show that VulFixMiner outperforms various state-of-the-art baselines in terms of AUC (i.e., 0.81 and 0.73 on Java and Python dataset, respectively) and two effort-aware performance metrics (i.e., EffortCost, Popt). Especially, with an effort of inspecting 5% of total LOC, VulFixMiner can identify 49% of total vulnerability fixes. Additionally, with manual verification of sampled commits that were identified as vulnerability fixes, but not marked as such in our dataset, we observe that 35% (29 out of 82) of the commits are for fixing vulnerabilities, indicating VulFixMiner is also capable of identifying unreported vulnerability fixes.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678720;;;Software AND Engineering
You don't need a Microservices Architecture (yet): Monoliths may do the trick;;;['Dimitrios Gravanis', 'George Kakarontzas', 'Vassilis Gerogiannis'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;Within the past decade, the advent of cloud computing in terms of infrastructure, technology stacks, availability of services and tooling, along with the gradual improvement of its market environment, has driven many organizations to either consider or migrate many existing software systems to the cloud, either fully or partially. A common predicament in most cases, is the existence of a complex, monolithic application, potentially considered legacy at the time, that was not designed to be cloud-native and therefore requires a degree of redesign/reimplementation in order to benefit from cloud deployment. In such cases, the decomposition of the monolith to a set of loosely coupled, highly cohesive and self-contained microservices is a valid recommendation, provided that the organization is prepared to withstand the additional cost, in terms of human and financial resources, along with the unavoidable development overhead, which is inevitable during the early stages. However, the tendency of the tech world to embrace new trends and jump on hype trains for fear of obsoletion, has led to an excessive adoption of the microservices architecture (MSA), even in cases where such an architecture is not viable for the organization, or does not derive from any business requirements. This research focuses on establishing the position of a traditional monolith in the modern software architecture landscape and determine use cases that can still benefit from this paradigm, as well as use cases that could benefit from a partial or full transition to microservices architectures instead.;;;https://dl.acm.org/doi/10.1145/3501774.3501780;;;Software AND Engineering
Talaria: in-engine synchronisation for seamless migration of mobile edge gaming instances;;;['Tristan Braud', 'Ahmad Alhilal', 'Pan Hui'];;;December 2021;;;CoNEXT '21: Proceedings of the 17th International Conference on emerging Networking EXperiments and Technologies;;;Mobile cloud gaming requires a very low end-to-end latency. Edge computing significantly reduces network latency. However, in mobility scenarios, the user will frequently move out of the edge server's coverage area, requiring frequent migration of the game instance. This paper presents Talaria, an in-engine content synchronisation solution for unnoticeable game instance migration between edge servers. Talaria creates a minimal instance with content immediately relevant to the game experience, allowing the client to switch servers in a minimal amount of time. The remaining content is then synchronised according to priority until the game's state is coherent between both instances. Our implementation of Talaria as a Unity engine plugin reduces the game's downtime by 61% compared to one-off server migration, with an average latency below 25 ms for the server migration, and 87 ms for the entire game synchronisation.;;;https://dl.acm.org/doi/10.1145/3485983.3494848;;;Software AND Engineering
An empirical study of the landscape of open source projects in Baidu, Alibaba, and Tencent;;;['Junxiao Han', 'Shuiguang Deng', 'David Lo', 'Chen Zhi', 'Jianwei Yin', 'Xin Xia'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Open source software has drawn more and more attention from researchers, developers and companies nowadays. Meanwhile, many Chinese technology companies are embracing open source and choosing to open source their projects. Nevertheless, most previous studies are concentrated on international companies such as Microsoft or Google, while the practical values of open source projects of Chinese technology companies remain unclear. To address this issue, we conduct a mixed-method study to investigate the landscape of projects open sourced by three large Chinese technology companies, namely Baidu, Alibaba, and Tencent (BAT). We study the categories and characteristics of open source projects, the developer's perceptions towards open sourcing effort for these companies, and the internationalization effort of their open source projects. We collected 1,000 open source projects that were open sourced by BAT in GitHub and performed an online survey that received 101 responses from developers of these projects. Some key findings include: 1) BAT prefer to open source frontend development projects, 2) 88% of the respondents are positive towards open sourcing software projects in their respective companies, 3) 64% of the respondents reveal that the most common motivations for BAT to open source their projects are the desire to gain fame, expand their influence and gain recruitment advantage, 4) respondents believe that the most common internationalization effort is "providing an English version of readme files", 5) projects with more internationalization effort (i.e., include an English readme file) are more popular. Our findings provide directions for software engineering researchers and provide practical suggestions to software developers and Chinese technology companies.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00039;;;Software AND Engineering
FinFuzzer: one step further in fuzzing fintech systems;;;['Qingshun Wang', 'Lihua Xu', 'Jun Xiao', 'Qi Guo', 'Haotian Zhang', 'Liang Dou', 'Liang He', 'Tao Xie'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Comprehensive testing is of high importance to ensure the reliability of software systems, especially for systems with high stakes such as FinTech systems. In this paper, we share our observations of the Ant Group's status quo in testing their financial services, specifically on the importance of properly transforming relevant external environment settings and prioritizing input object fields for mutation during automated fuzzing. Based on these observations, we propose FinFuzzer, an automated fuzz testing framework that detects and transforms relevant environmental settings into system inputs, prioritizes input object fields, and mutates system inputs on both environment settings and high-priority object fields. Our evaluation of FinFuzzer against four FinTech systems developed by the Ant Group shows that FinFuzzer can outperform a state-of-the-art approach in terms of line coverage in much shorter time.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678675;;;Software AND Engineering
Quantifying no-fault-found test failures to prioritize inspection of flaky tests at Ericsson;;;['Maaz Hafeez Ur Rehman', 'Peter C. Rigby'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;A test fails and despite an investigation by a developer there is no fault found (NFF). Large software systems are often released with known failing and flaky tests. In this work, we quantify how often a test fails and does not find a fault. We conduct a case study on 9.9 million test runs of 10k tests across four releases of a large project at Ericsson.   For each test, we mine the rate of NFF test failures over total runs for each release, i.e. NFFRate. We compare the current level of test failure with the number of NFF failures during the stabilization period of the prior release, i.e. StableNFFRate. Using the binomial distribution, we are able to determine which tests exhibit a statistically larger number of failures relative to their expected StableNFFRate. These unstable tests need to be prioritized for re-run and potentially investigated to determine if there is a fault or if the test needs to be fixed or modified.   Our work has had an impact on Ericsson’s testing practices with testers using the NFFRate to determine which tests are the “flakiest" and need to be fixed or moved into an earlier, virtualized unit test stage. Testers also use our tool and technique to prioritize the statistically unstable tests failures for investigation and to examine longterm trends of test failures that may indicate a fault.;;;https://dl.acm.org/doi/10.1145/3468264.3473930;;;Software AND Engineering
A Lightweight Architecture for Hardware-Based Security in the Emerging Era of Systems of Systems;;;['Nico Mexis', 'Nikolaos Athanasios Anagnostopoulos', 'Shuai Chen', 'Jan Bambach', 'Tolga Arul', 'Stefan Katzenbeisser'];;;None;;;ACM Journal on Emerging Technologies in Computing Systems;;;In recent years, a new generation of the Internet of Things (IoT 2.0) is emerging, based on artificial intelligence, the blockchain technology, machine learning, and the constant consolidation of pre-existing systems and subsystems into larger systems. In this work, we construct and examine a proof-of-concept prototype of such a system of systems, which consists of heterogeneous commercial off-the-shelf components, and utilises diverse communication protocols. We recognise the inherent need for lightweight security in this context, and address it by employing a low-cost state-of-the-art security solution. Our solution is based on a novel hardware and software co-engineering paradigm, utilising well-known software-based cryptographic algorithms, in order to maximise the security potential of the hardware security primitive (a Physical Unclonable Function) that is used as a security anchor. The performance of the proposed security solution is evaluated, proving its suitability even for real-time applications. Additionally, the Dolev-Yao attacker model is considered in order to assess the resilience of our solution towards attacks against the confidentiality, integrity, and availability of the examined system of systems. In this way, it is confirmed that the proposed solution is able to address the emerging security challenges of the oncoming era of systems of systems.;;;https://dl.acm.org/doi/10.1145/3458824;;;Software AND Engineering
Speech-To-Story: Gerando Histórias de Usuário;;;['Gabriel Ferreira Barros de Sousa', 'Simone da Silva Amorim'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;In agile environments, requirement engineers conduct interviews with clients to create user stories manually. However, a manual approach is subject to human failures such as ambiguity, communication problems, and incomplete requirements. These failures are detected during the validation process of the stories that can be performed days after the interview, causing on wasted time and rework. This paper presents Speech-To-Story: a mobile solution for requirements gathering, generating automatically user stories for their immediate validation. Questions are offered for the engineer to conduct the structured interview, capturing the responses of the clients. The user stories can be validated and corrected during interview time. RESUMO Em ambientes ágeis, os engenheiros de requisitos conduzem entrevistas com clientes para criar histórias de usuário manualmente. No entanto, uma abordagem manual está sujeita a falhas humanas como ambigüidade, problemas de comunicação e requisitos incompletos. Essas falhas são detectadas durante o processo de validação das histórias que podem ser realizadas dias após a entrevista, ocasionando perda de tempo e retrabalho. Este artigo apresenta o Speech-To-Story: uma solução para levantamento de requisitos, gerando automaticamente histórias de usuário. São oferecidas perguntas para que o engenheiro conduza uma entrevista estruturada, captando as respostas dos clientes. As histórias de usuários podem ser validadas e corrigidas em tempo de entrevista. Video: https://youtu.be/8rYpD3YPuEU;;;https://dl.acm.org/doi/10.1145/3474624.3476015;;;Software AND Engineering
First Step Towards μNet: Open-Access Aquatic Testbeds and Robotic Ecosystem;;;['Scott Mayberry', 'Junkai Wang', 'Qiuyang Tao', 'Fumin Zhang', 'Aijun Song', 'Xiaoyan Hong', 'Shuai Dong', 'Connor Webb', 'Dmitrii Dugaev', 'Zheng Peng'];;;November 2021;;;WUWNet '21: Proceedings of the 15th International Conference on Underwater Networks &amp; Systems;;;Aquatic-based research requires a special set of facilities, expertise, and supporting personnel, all of which are costly and often not accessible to small research groups. A shared research infrastructure, particularly testbeds and open-access software, would lower the barrier to entry, decrease implementation time, and mitigate the risk of failure in harsh underwater environments. We have made the first step towards developing μNet, an open-access aquatic testbed and robotic ecosystem addressing the need for shared infrastructure. Our contributions include the initial steps towards an indoor testbed, an outdoor testbed, and an open-access software suite.;;;https://dl.acm.org/doi/10.1145/3491315.3491322;;;Software AND Engineering
Quito: a coverage-guided test generator for quantum programs;;;['Xinyi Wang', 'Paolo Arcaini', 'Tao Yue', 'Shaukat Ali'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Automation in quantum software testing is essential to support systematic and cost-effective testing. Towards this direction, we present a quantum software testing tool called Quito that can automatically generate test suites covering three coverage criteria defined on inputs and outputs of a quantum program coded in Qiskit, i.e., input coverage, output coverage, and input-output coverage. Quito also implements two types of test oracles based on program specifications, i.e., checking whether a quantum program produced a wrong output or checking a probabilistic test oracle with statistical test. We describe the architecture and methodology of the tool. We also validated the tool with one quantum program and one faulty version of it. Results indicate that Quito can generate test suites and perform test assessments that detect faults, and produce test results with a good time performance. Quito's code: https://github.com/Simula-COMPLEX/quito Quito's video: https://youtu.be/kuI9QaCo8A8 Artifact Available: https://doi.org/10.5281/zenodo.5288665;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678798;;;Software AND Engineering
Learning Queuing Networks via Linear Optimization;;;['Emilio Incerto', 'Annalisa Napolitano', 'Mirco Tribastone'];;;April 2021;;;ICPE '21: Proceedings of the ACM/SPEC International Conference on Performance Engineering;;;The automatic derivation of analytical performance models is an essential tool to promote a wider adoption of performance engineering techniques in practice. Unfortunately, despite the importance of such techniques, the attempts pursuing that goal in the literature either focus on the estimation of service demand parameters only or suffer from scalability issues and sub-optimality due to the intrinsic complexity of the underlying optimization methods. In this paper, we propose an efficient linear programming approach that allows to derive queuing network (QN) models from sampled execution traces. For doing so, we rely on a deterministic approximation of the average dynamic of QNs in terms of a compact system of ordinary differential equations. We encode these equations into a linear optimization problem whose decision variables can be directly related to the unknown QN parameters, i.e., service demands and routing probabilities. Using models of increasing complexity, we show the efficiency and the effectiveness of our technique in yielding models with high prediction power.;;;https://dl.acm.org/doi/10.1145/3427921.3450245;;;Software AND Engineering
Criminal Investigations: An Interactive Experience to Improve Student Engagement and Achievement in Cybersecurity Courses;;;['John Grady Hall', 'Abhinav Mohanty', 'Pooja Murarisetty', 'Ngoc Diep Nguyen', 'Julio César Bahamón', 'Harini Ramaprasad', 'Meera Sridhar'];;;February 2022;;;SIGCSE 2022: Proceedings of the 53rd ACM Technical Symposium on Computer Science Education - Volume 1;;;This paper presents Criminal Investigations, a gamified, scalable web-based framework for teaching and assessing Internet-of-Things (IoT) security skills. Criminal Investigations is packaged as a series of stackable IoT security activities; the current version uses React for the front-end development and Python for the back-end, and is deployed as a web application on a university server. Criminal Investigations promotes student engagement and learning by incorporating gamification concepts such as storytelling, experience points, just-in-time learning content delivery and checkpoints into activity design. This paper presents a pilot deployment of Criminal Investigations' first, fully-deployed, prototype activity "Reverse Engineering and Analyzing IoT Firmware''. The results of the pilot deployment indicate that Criminal Investigations provides an engaging, user-friendly, accessible environment, and helps students achieve the learning objectives of the prototype activity.;;;https://dl.acm.org/doi/10.1145/3478431.3499417;;;Software AND Engineering
SoftBLE: An SDN Framework for BLE-based IoT Networks;;;['Mehdi Jafarizadeh', 'Xingzhi Liu', 'Rong Zheng'];;;May 2021;;;IoTDI '21: Proceedings of the International Conference on Internet-of-Things Design and Implementation;;;Today's Industrial IoT (IIoT) applications often employ large-scale and dense sensor deployments for environmental monitoring. A hierarchical Bluetooth Low Energy (BLE) based architecture can facilitate power efficiency and reliability for data collection in dense networks. But if the network is static with fixed parameter settings, it can not be adaptable to dynamic application requirements. Although BLE is a parametric protocol, it does not provide any built-in feature for parameter tuning. To achieve network adaptability, we introduce and design SoftBLE, a Software Defined Networking (SDN) framework that provides controllability for BLE based 2-tier networks. It takes advantages of advanced control knobs recently available in BLE protocol stacks. SoftBLE is complemented by two orchestration algorithms to optimize gateway and sensor parameters. Evaluation results from both an experimental testbed and a large-scale simulation study show that almost all the SoftBLE sensors can save around 70% of transmission power while keeping Packet Reception Rate (PRR) above 99.9%.;;;https://dl.acm.org/doi/10.1145/3450268.3453527;;;Software AND Engineering
Chukonu: a fully-featured high-performance big data framework that integrates a native compute engine into Spark;;;['Bowen Yu', 'Guanyu Feng', 'Huanqi Cao', 'Xiaohan Li', 'Zhenbo Sun', 'Haojie Wang', 'Xiaowei Zhu', 'Weimin Zheng', 'Wenguang Chen'];;;None;;;Proceedings of the VLDB Endowment;;;Apache Spark is a widely deployed big data analytics framework that offers such attractive features as resiliency, load-balancing, and a rich ecosystem. However, there is still plenty of room for improvement in its performance. Although a data-parallel system in a native programming language significantly improves performance, it may require re-implementing many functionalities of Spark to become a full-featured system. It is desirable for native big data systems to just write a compute engine in native languages to ensure high efficiency, and reuse other mature features provided by Spark rather than re-implement everything. But the interaction between the JVM and the native world risks becoming a bottleneck.This paper proposes Chukonu, a native big data framework that re-uses critical big data features provided by Spark. Owing to our novel DAG-splitting approach, the potential Spark integration overhead is alleviated, and its even outperforms existing pure native big data frameworks. Chukonu splits DAG programs into run-time parts and compile-time parts: The run-time parts are delegated to Spark to offload the complexities due to feature implementations. The compile-time parts are natively compiled. We propose a series of optimization techniques to be applied to the compile-time parts, such as operator fusion, vectorization, and compaction, to significantly reduce the Spark integration overhead. The results of evaluation show that Chukonu has a speedup of up to 71.58X (geometric mean 6.09X) over Apache Spark, and up to 7.20X (geometric mean 2.30X) over pure-native frameworks on six commonly-used big data applications. By translating the physical plan produced by SparkSQL into Chukonu programs, Chukonu accelerates Spark-SQL's TPC-DS performance by 2.29X.;;;https://dl.acm.org/doi/10.14778/3503585.3503596;;;Software AND Engineering
Can neural clone detection generalize to unseen functionalities?;;;['Chenyao Liu', 'Zeqi Lin', 'Jian-Guang Lou', 'Lijie Wen', 'Dongmei Zhang'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Many recently proposed code clone detectors exploit neural networks to capture latent semantics of source code, thus achieving impressive results for detecting semantic clones. These neural clone detectors rely on the availability of large amounts of labeled training data. We identify a key oversight in the current evaluation methodology for neural clone detection: cross-functionality generalization (i.e., detecting semantic clones of which the functionalities are unseen in training). Specifically, we focus on this question: do neural clone detectors truly learn the ability to detect semantic clones, or they just learn how to model specific functionalities in training data while cannot generalize to realistic unseen functionalities? This paper investigates how the generalizability can be evaluated and improved. Our contributions are 3-folds: (1) We propose an evaluation methodology that can systematically measure the cross-functionality generalizability of neural clone detection. Based on this evaluation methodology, an empirical study is conducted and the results indicate that current neural clone detectors cannot generalize well as expected. (2) We conduct empirical analysis to understand key factors that can impact the generalizability. We investigate 3 factors: training data diversity, vocabulary, and locality. Results show that the performance loss on unseen functionalities can be reduced through addressing the out-of-vocabulary problem and increasing training data diversity. (3) We propose a human-in-the-loop mechanism that help adapt neural clone detectors to new code repositories containing lots of unseen functionalities. It improves annotation efficiency with the combination of transfer learning and active learning. Experimental results show that it reduces the amount of annotations by about 88%. Our code and data are publicly available1.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678907;;;Software AND Engineering
IncBL: incremental bug localization;;;['Zhou Yang', 'Jieke Shi', 'Shaowei Wang', 'David Lo'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Numerous efforts have been invested in improving the effectiveness of bug localization techniques, whereas little attention is paid to making these tools run more efficiently in continuously evolving software repositories. This paper first analyzes the information retrieval model behind a classic bug localization tool, BugLocator, and builds a mathematical foundation illustrating that the model can be updated incrementally when codebase or bug reports evolve. Then, we present IncBL, a tool for Incremental Bug Localization in evolving software repositories. IncBL is evaluated on the Bugzbook dataset, and the results show that IncBL can significantly reduce the running time by 77.79% on average compared with the re-computing the model, while maintaining the same level of accuracy. We also implement IncBL as a Github App that can be easily integrated into open-source projects on GitHub. Users can deploy and use IncBL locally as well. The demo video for IncBL can be viewed at https://youtu.be/G4gMuvlJSb0, and the source code can be found at https://github.com/soarsmu/IncBL.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678546;;;Software AND Engineering
Reducing cost in continuous integration with a collection of build selection approaches;;;['Xianhao Jin'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Continuous integration (CI) is a widely used practice in modern software engineering. Unfortunately, it is also an expensive practice — Google and Mozilla estimate their CI systems in millions of dollars. To reduce CI computation cost, I propose the strategy of build selection to selectively execute those builds whose outcomes are failing and skip those passing builds for cost-saving. In my research, I firstly designed SmartBuildSkip as my first build selection approach that can skip unfruitful builds in CI automatically. Next, I evaluated SmartBuildSkip with all CI-improving approaches for understanding the strength and weakness of existing approaches to recommend future technique design. Then I proposed PreciseBuildSkip as a build selection approach to maximize the safety of skipping builds in CI. I also combined existing approaches both within and across granularity to be applied as a new build selection approach — HybridBuildSkip to save builds in a hybrid way. Finally, I plan to propose a human study to understand how to increase developers' trust on build selection approaches.;;;https://dl.acm.org/doi/10.1145/3468264.3473103;;;Software AND Engineering
Towards a Technique to Detect Weaknesses in C Programs;;;['Raphael Muniz', 'Wilkerson Andrade', 'Patricia Machado'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Several critical systems, such as Linux, are implemented using the C language, and a security flaw in these systems may impact a vast number of users. Despite the effort to providing security support, these systems still have weaknesses, leading to vulnerable code. In fact, the number of reported vulnerabilities has increased in the last years, where more than 18 thousand vulnerabilities were reported to the National Vulnerability Database (NVD) in 2020. Static analysis tools, such as Flawfinder and Cppcheck, may help in this problem, reporting some kinds of weaknesses. However, they present a high rate of false alarms, an issue reported in a program when no problem actually exists. We present a technique that combines static analysis with software testing to detect weaknesses introduced in the code during earlier development stages of C programs. The technique is implemented in a framework named WTT. To verify our technique’s relevance, we evaluated 103 warnings of 6 different projects, and we detected 22 weaknesses of three different kinds: Buffer Overflow, Format String, and Integer Overflow. Results show evidence that our technique may help developers anticipate weakness detection in C programs, reducing vulnerability occurrence in operational versions.;;;https://dl.acm.org/doi/10.1145/3474624.3474633;;;Software AND Engineering
Tackling Consistency-related Design Challenges of Distributed Data-Intensive Systems: An Action Research Study;;;['Susanne Braun', 'Stefan Deßloch', 'Eberhard Wolff', 'Frank Elberzhager', 'Andreas Jedlitschka'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: Distributed data-intensive systems are increasingly designed to be only eventually consistent. Persistent data is no longer processed with serialized and transactional access, exposing applications to a range of potential concurrency anomalies that need to be handled by the application itself. Controlling concurrent data access in monolithic systems is already challenging, but the problem is exacerbated in distributed systems. To make it worse, only little systematic engineering guidance is provided by the software architecture community regarding this issue. Aims: In this paper, we report on our study of the effectiveness and applicability of the novel design guidelines we are proposing in this regard. Method: We used action research and conducted it in the context of the software architecture design process of a multi-site platform development project. Results: Our hypotheses regarding effectiveness and applicability have been accepted in the context of the study. The initial design guidelines were refined throughout the study. Thus, we also contribute concrete guidelines for architecting distributed data-intensive systems with eventually consistent data. The guidelines are an advancement of Domain-Driven Design and provide additional patterns for the tactical design part. Conclusions: Based on our results, we recommend using the guidelines to architect safe eventually consistent systems. Because of the relevance of distributed data-intensive systems, we will drive this research forward and evaluate it in further domains.;;;https://dl.acm.org/doi/10.1145/3475716.3475771;;;Software AND Engineering
DyMMer 2.0: A Tool for Dynamic Modeling and Evaluation of Feature Model;;;['Carla Bezerra', 'Rafael Lima', 'Publio Silva'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Managing dynamic variability has motivated several researchers to combine Dynamic Software Product Lines (DSPLs) practices with runtime variability mechanisms. By combining these approaches, a DSPL acquires important features, ranging from the ability to reconfigure by changing the context, adding or removing features, crash recovery, and re-adaptation based on changes in the model’s features. Feature model (FM) is an important artifact of a DPSL and there is a lack of tools that support the modeling of this artifact. We have extended the DyMMer tool for modeling FM of DSPLs from an adaptation mechanism based on MAPE-K to solve this problem. We migrated the DyMMer tool to a web version and incorporated new features: (i) modeling of FMs from SPLs and DSPLs, (ii) development of an adaptation mechanism for FM of DSPLs, (iii) repository of FMs, (iv) inclusion of thresholds for measures, and (v) user authentication. We believe that this tool is useful for research in the area of DSPLs, and also for dynamic domain modeling and evaluation.  Video: https://youtu.be/WVHW6bI8ois;;;https://dl.acm.org/doi/10.1145/3474624.3476016;;;Software AND Engineering
Developer Tracker App: Uma Ferramenta para Visualizar o Trabalho dos Desenvolvedores;;;['Matheus Silva Ferreira', 'Paulo Afonso Júnior', 'Heitor Costa'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Os benefícios de compreender o trabalho realizado pelos desenvolvedores incluem ajudar o Gerente de Projetos a reconhecer a contribuição de cada membro da equipe e a alocar profissionais de acordo com a demanda do projeto. As ferramentas para mineração de registros armazenados nos Sistemas de Controle de Versão e apresentação visual dos resultados auxiliam na tarefa de compreender o trabalho dos desenvolvedores. Neste trabalho, o software Developer Tracker App é apresentado, o qual permite a mineração de repositórios Git, aplicando medidas quantitativas e apresentando visualmente os resultados ao Gerente de Projetos. Os recursos visuais incluem um painel contendo informações sobre o projeto de software e uma estrutura interativa, definida por uma técnica de visualização que segue o paradigma iconográfico, para representar informações sobre o trabalho dos desenvolvedores nos artefatos do projeto. ABSTRACT The benefits of understanding the work performed by developers include helping the Project Manager to recognize the contribution of each team member and allocate staff according to project demand. Tools for mining the records stored in the Version Control Systems and visually presenting the results assist in the task of understanding the developers’ work. In this paper, the Developer Tracker App software is presented, which allows mining of Git repositories, applying quantitative measures and visually presenting the results to the Project Manager. The visual features include a dashboard containing information about the software project and an interactive structure, defined by a visualization technique that follows the iconographic paradigm, to represent information about the developers’ work in the project artifacts. Link para o Vídeo: https://youtu.be/S4GrMzrVdaA Tipo de Licença: GPL (General Public License);;;https://dl.acm.org/doi/10.1145/3474624.3476009;;;Software AND Engineering
Cognitive Load Analyzer: A Support Tool for Cognitive-Driven Development;;;['Jherson Haryson A. Pereira', 'Alberto Luiz Oliveira Tavares de Souza', 'Victor Hugo Santiago C. Pinto'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Software modularity refers to the decomposition of complex software to be manageable for the purpose of implementation and maintenance. Most methodologies and practices adopted in the industry follow this principle, often with the benefit of flexibility and variety in use. This is also a recognition that human work can be improved by focus on a limited set of data. However, code more complex than needed continues being produced resulting in cognitive overload for developers. Cognitive-Driven Development (CDD) is an inspiration from the Cognitive Load Theory for software development with the goal of reducing the split-attention effect and the problem space through a feasible cognitive complexity constraint. Implementation units can be kept under this limit even with the continuous expansion of software scale. Experimental studies were carried out and their results suggested that CDD is a promising method when guiding the development focusing on understanding and achieving high-quality code with respect to the quality metrics. In this paper, we present a tool called “Cognitive Load Analyzer” to support the CDD, a plugin for IntelliJ IDEA and Java language. This tool can be useful to support the adoption of the CDD aiming to overcome the to slice the code and help developers to reduce code complexity.;;;https://dl.acm.org/doi/10.1145/3474624.3476011;;;Software AND Engineering
How Developers Optimize Virtual Reality Applications: A Study of Optimization Commits in Open Source Unity Projects;;;['Fariha Nusrat', 'Foyzul Hassan', 'Hao Zhong', 'Xiaoyin Wang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Virtual Reality (VR) is an emerging technique that provides immersive experience for users. Due to the high computation cost of rendering real-time animation twice (for both eyes) and the resource limitation of wearable devices, VR applications often face performance bottlenecks and performance optimization plays an important role in VR software development. Performance optimizations of VR applications can be very different from those in traditional software as VR involves more elements such as graphics rendering and real-time animation. In this paper, we present the first empirical study on 183 real-world performance optimizations from 45 VR software projects. In particular, we manually categorized the optimizations into 11 categories, and applied static analysis to identify how they affect different life-cycle phases of VR applications. Furthermore, we studied the complexity and design / behavior effects of performance optimizations, and how optimizations are different between large organizational software projects and smaller personal software projects. Our major findings include: (1) graphics simplification (24.0%), rendering optimization (16.9%), language / API optimization (15.3%), heap avoidance (14.8%), and value caching (12.0%) are the most common categories of performance optimization in VR applications; (2) game logic updates (30.4%) and before-scene initialization (20.0%) are the most common life-cycle phases affected by performance issues; (3) 45.9% of the optimizations have behavior and design effects and 39.3% of the optimizations are systematic changes; (4) the distributions of optimization classes are very different between organizational VR projects and personal VR projects.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00052;;;Software AND Engineering
Research artifact: the potential of meta-maintenance on GitHub;;;['Hideaki Hata', 'Raula Gaikovina Kula', 'Takashi Ishio', 'Christoph Treude'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This is a research artifact for the paper "Same File, Different Changes: The Potential of Meta-Maintenance on GitHub". This artifact is a data repository including a list of studied 32,007 repositories on GitHub, a list of targeted 401,610,677 files, the results of the qualitative analysis for RQ2, RQ3, and RQ4, the results of the quantitative analysis for RQ5, and survey material for RQ6. The purpose of this artifact is enabling researchers to replicate our mixed-methods results of the paper, and to reuse the results of our exploratory study for further software engineering research. This research artifact is available at https://github.com/NAIST-SE/MetaMaintenancePotential and https://doi.org/10.5281/zenodo.4456668.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00084;;;Software AND Engineering
Elicitation of Personal Data Categories for Implementing Data Protection: An Exploratory Study in an Educational Institution;;;['Deepti Balaji Raykar', 'V Sridhar'];;;February 2022;;;ISEC 2022: 15th Innovations in Software Engineering Conference;;;Protecting the privacy of natural persons has become very important in today's data economy. Countries around the world are in the process of legislating data protection regulations to prevent breaches of personal data. However, the implementation of data protection is very much domain and context-specific. The data categories that are to be protected in the domain of implementation need to be discovered. We propose a human-centric approach for eliciting such data categories that cause privacy concerns to stakeholders in an educational institution. A study was conducted to understand the privacy concerns of the stakeholders, related to different data categories to be protected. A combination of surveys and in-depth interviews of the different stakeholders were used to gain insights into the privacy and data protection requirements that need to be incorporated into the associated information system design.;;;https://dl.acm.org/doi/10.1145/3511430.3511443;;;Software AND Engineering
Microwave devices models creation for using within digital educational platform;;;['Yevgeniya Daineko', 'Madina Ipalakova', 'Altay Aitmagambetov', 'Dmitry Gubsky', 'Dariya Lonkina', 'Aigul Kulakayeva', 'Bagdat Kozhakhmetova', 'Dana Tsoy'];;;October 2021;;;ICEMIS'21: The 7th International Conference on Engineering &amp; MIS 2021;;;The digital transformation of education is one of the trends in the world's leading educational systems and an important resource for the development of education. Digitalization in the field of domestic education has received special advancement because of the COVID-19 pandemic. Therefore, the development of the digital economy and education is currently one of the main priorities of the state policy of our country. The development of digital technologies stimulates the formation of a digital educational environment and, as a result, increases the potential of distance learning, where a special role is assigned to the development of educational platforms. So, at present, many higher educational institutions, to rethink and transform the educational process, are in search of effective educational digital technologies and educational platforms that will provide a high level of training for graduates within the framework of distance education, which has been actively introduced as a result of the current pandemic. The authors are the developers of such a digital educational platform for students of the RET specialty to study the basic parameters of a satellite earth station, the features of the propagation of microwave and EHF radio waves, and an assessment of the energy budget of satellite radio channels. This article is devoted to computer modeling of an element of radio engineering systems - microwave reflector antenna. The developed computer model of the reflector antenna will be included in the developed digital educational platform as one of its elements.;;;https://dl.acm.org/doi/10.1145/3492547.3492700;;;Software AND Engineering
Adversarial attacks to API recommender systems: time to wake up and smell the coffee?;;;['Phuong T. Nguyen', 'Claudio Di Sipio', 'Juri Di Rocco', 'Massimiliano Di Penta', 'Davide Di Ruscio'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Recommender systems in software engineering provide developers with a wide range of valuable items to help them complete their tasks. Among others, API recommender systems have gained momentum in recent years as they became more successful at suggesting API calls or code snippets. While these systems have proven to be effective in terms of prediction accuracy, there has been less attention for what concerns such recommenders' resilience against adversarial attempts. In fact, by crafting the recommenders' learning material, e.g., data from large open-source software (OSS) repositories, hostile users may succeed in injecting malicious data, putting at risk the software clients adopting API recommender systems. In this paper, we present an empirical investigation of adversarial machine learning techniques and their possible influence on recommender systems. The evaluation performed on three state-of-the-art API recommender systems reveals a worrying outcome: all of them are not immune to malicious data. The obtained result triggers the need for effective countermeasures to protect recommender systems against hostile attacks disguised in training data.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678946;;;Software AND Engineering
CogTool+: Modeling Human Performance at Large Scale;;;['Haiyue Yuan', 'Shujun Li', 'Patrice Rusconi'];;;None;;;ACM Transactions on Computer-Human Interaction;;;Cognitive modeling tools have been widely used by researchers and practitioners to help design, evaluate, and study computer user interfaces (UIs). Despite their usefulness, large-scale modeling tasks can still be very challenging due to the amount of manual work needed. To address this scalability challenge, we propose CogTool+, a new cognitive modeling software framework developed on top of the well-known software tool CogTool. CogTool+ addresses the scalability problem by supporting the following key features: (1) a higher level of parameterization and automation; (2) algorithmic components; (3) interfaces for using external data; and (4) a clear separation of tasks, which allows programmers and psychologists to define reusable components (e.g., algorithmic modules and behavioral templates) that can be used by UI/UX researchers and designers without the need to understand the low-level implementation details of such components. CogTool+ also supports mixed cognitive models required for many large-scale modeling tasks and provides an offline analyzer of simulation results. In order to show how CogTool+ can reduce the human effort required for large-scale modeling, we illustrate how it works using a pedagogical example, and demonstrate its actual performance by applying it to large-scale modeling tasks of two real-world user-authentication systems.;;;https://dl.acm.org/doi/10.1145/3447534;;;Software AND Engineering
DepOwl: Detecting Dependency Bugs to Prevent Compatibility Failures;;;['Zhouyang Jia', 'Shanshan Li', 'Tingting Yu', 'Chen Zeng', 'Erci Xu', 'Xiaodong Liu', 'Ji Wang', 'Xiangke Liao'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Applications depend on libraries to avoid reinventing the wheel. Libraries may have incompatible changes during evolving. As a result, applications will suffer from compatibility failures. There has been much research on addressing detecting incompatible changes in libraries, or helping applications co-evolve with the libraries. The existing solution helps the latest application version work well against the latest library version as an afterthought. However, end users have already been suffering from the failures and have to wait for new versions. In this paper, we propose DepOwl, a practical tool helping users prevent compatibility failures. The key idea is to avoid using incompatible versions from the very beginning. We evaluated DepOwl on 38 known compatibility failures from StackOverflow, and DepOwl can prevent 35 of them. We also evaluated DepOwl using the software repository shipped with Ubuntu-19.10. DepOwl detected 77 unknown dependency bugs, which may lead to compatibility failures.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00021;;;Software AND Engineering
Delegated attestation: scalable remote attestation of commodity CPS by blending proofs of execution with software attestation;;;['Mahmoud Ammar', 'Bruno Crispo', 'Ivan De Oliveira Nunes', 'Gene Tsudik'];;;June 2021;;;WiSec '21: Proceedings of the 14th ACM Conference on Security and Privacy in Wireless and Mobile Networks;;;Remote Attestation (RA) is an interaction between a trusted verifier (Vrf) and one or more remote and potentially compromised devices (provers or Prv-s) that allow the former to measure the software state of the latter. RA is particularly relevant to safety-critical cyber-physical systems (CPS) where a set of low-end micro-controllers (MCUs), operate under the control of a remote and more powerful controller. In such cases, RA is an effective and relatively efficient means to detect software compromise, e.g., malware infections, on these low-end MCUs that cannot support expensive security mechanisms. Unfortunately, current RA techniques have a major practical limitation by requiring one or more of: (i) customized hardware support on every Prv; or (ii) physical presence of Vrf, which must be directly connected to all Prv-s, or (iii) secure pre-loading of trusted software. To overcome this limitation, we construct, implement and evaluate a Delegated Attestation (DA) scheme. In it, all Prv-s remain unmodified, meaning that it applies even to already deployed CPS devices. However, there is no requirement for Vrf's physical proximity, hardware support or secure initial software pre-loading. Instead, DA uses a recently proposed primitive (called Proofs-of-Execution or PoX) which entails a single customized low-end embedded device (called Attestation Proxy or Prox) on the same local-area network (e.g., a CAN-bus) as Prv-s. In doing so, DA enables RA of all Prv-s. Importantly, this guarantee holds even if Prox is itself compromised, enabling secure RA of completely unmodified Prv-s in an efficient manner.;;;https://dl.acm.org/doi/10.1145/3448300.3467818;;;Software AND Engineering
BDS&#x002B;: An Inter-Datacenter Data Replication System With Dynamic Bandwidth Separation;;;['Yuchao Zhang', 'Xiaohui Nie', 'Junchen Jiang', 'Wendong Wang', 'Ke Xu', 'Youjian Zhao', 'Martin J. Reed', 'Kai Chen', 'Haiyang Wang', 'Guang Yao'];;;None;;;IEEE/ACM Transactions on Networking;;;Many important cloud services require replicating massive data from one datacenter (DC) to multiple DCs. While the performance of pair-wise inter-DC data transfers has been much improved, prior solutions are insufficient to optimize bulk-data multicast, as they fail to explore the rich inter-DC overlay paths that exist in geo-distributed DCs, as well as the remaining bandwidth reserved for online traffic under fixed bandwidth separation scheme. To take advantage of these opportunities, we present <italic>BDS&#x002B;</italic>, a near-optimal network system for large-scale inter-DC data replication. BDS&#x002B; is an application-level multicast overlay network with a <italic>fully centralized</italic> architecture, allowing a central controller to maintain an up-to-date global view of data delivery status of intermediate servers, in order to fully utilize the available overlay paths. Furthermore, in each overlay path, it leverages dynamic bandwidth separation to make use of the remaining available bandwidth reserved for online traffic. By constantly estimating online traffic demand and rescheduling bulk-data transfers accordingly, BDS&#x002B; can further speed up the massive data multicast. Through a pilot deployment in one of the largest online service providers and large-scale real-trace simulations, we show that BDS&#x002B; can achieve 3-<inline-formula> <tex-math notation="LaTeX">$5\times $ </tex-math></inline-formula> speedup over the provider&#x2019;s existing system and several well-known overlay routing baselines of static bandwidth separation. Moreover, dynamic bandwidth separation can further reduce the completion time of bulk data transfers by 1.2 to 1.3 times.;;;https://dl.acm.org/doi/10.1109/TNET.2021.3054924;;;Software AND Engineering
Quingo: A Programming Framework for Heterogeneous Quantum-Classical Computing with NISQ Features;;;['X. Fu', 'Jintao Yu', 'Xing Su', 'Hanru Jiang', 'Hua Wu', 'Fucheng Cheng', 'Xi Deng', 'Jinrong Zhang', 'Lei Jin', 'Yihang Yang', 'Le Xu', 'Chunchao Hu', 'Anqi Huang', 'Guangyao Huang', 'Xiaogang Qiang', 'Mingtang Deng', 'Ping Xu', 'Weixia Xu', 'Wanwei Liu', 'Yu Zhang', 'Yuxin Deng', 'Junjie Wu', 'Yuan Feng'];;;None;;;ACM Transactions on Quantum Computing;;;The increasing control complexity of Noisy Intermediate-Scale Quantum (NISQ) systems underlines the necessity of integrating quantum hardware with quantum software. While mapping heterogeneous quantum-classical computing (HQCC) algorithms to NISQ hardware for execution, we observed a few dissatisfactions in quantum programming languages (QPLs), including difficult mapping to hardware, limited expressiveness, and counter-intuitive code. In addition, noisy qubits require repeatedly performed quantum experiments, which explicitly operate low-level configurations, such as pulses and timing of operations. This requirement is beyond the scope or capability of most existing QPLs.We summarize three execution models to depict the quantum-classical interaction of existing QPLs. Based on the refined HQCC model, we propose the Quingo framework to integrate and manage quantum-classical software and hardware to provide the programmability over HQCC applications and map them to NISQ hardware. We propose a six-phase quantum program life-cycle model matching the refined HQCC model, which is implemented by a runtime system. We also propose the Quingo programming language, an external domain-specific language highlighting timer-based timing control and opaque operation definition, which can be used to describe quantum experiments. We believe the Quingo framework could contribute to the clarification of key techniques in the design of future HQCC systems.;;;https://dl.acm.org/doi/10.1145/3483528;;;Software AND Engineering
Analyzing DevOps Teaching Strategies: An Initial Study;;;['Samuel Ferino', 'Marcelo Fernandes', 'Anny Fernandes', 'Uirá Kulesza', 'Eduardo Aranha', 'Christoph Treude'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;DevOps refers to a set of practices that integrate software development and operations with the primary aim to enable the continuous delivery of high-quality software. DevOps has also promoted several challenges to software engineering teaching. In this paper, we present a preliminary study that analyzes existing teaching strategies reported in the literature. Our findings indicate a set of approaches highlighting the use of environments to support teaching. Our work also investigates how these environments can contribute to address existing challenges and recommendations of DevOps teaching.;;;https://dl.acm.org/doi/10.1145/3474624.3477071;;;Software AND Engineering
DSInfoSearch: supporting experimentation process of data scientists;;;['Shangeetha Sivasothy'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Experimentation plays an important role in the work of data scientists to explore unfamiliar problem domains, to answer questions from data, and to develop diverse machine learning applications. Good experimentation requires creativity, is based on prior results and informed from the literature. However, finding relevant information from online sources to guide experimentation causes inefficiencies for data scientists. The objective of this research is to help data scientists through the presentation of context aware ranked data science experiments, considering problem domain, development task and learning task. Data science experiments for this study were extracted from publicly available interactive notebooks and were manually annotated based on a taxonomy of data science techniques and a meta model of a data science experiment. Further, the ranking algorithm was developed for data science experiments for given problem domain and development task. As a result, a tool was developed to demonstrate context aware ranked data science experiments for given problem domains such as natural language processing, computer vision and time series and for development stages such as feature engineering and model selection. This study shows that tools and techniques can be designed to be aware of the data science context, in fact, much more so than for software engineering tools. This study supports these efforts by providing knowledge that can improve experimentation process of data scientists.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678873;;;Software AND Engineering
A classification of code changes and test types dependencies for improving machine learning based test selection;;;['Khaled Al-Sabbagh', 'Miroslaw Staron', 'Regina Hebig', 'Francisco Gomes'];;;August 2021;;;PROMISE 2021: Proceedings of the 17th International Conference on Predictive Models and Data Analytics in Software Engineering;;;Machine learning has been increasingly used to solve various software engineering tasks. One example of their usage is in regression testing, where a classifier is built using historical code commits to predict which test cases require execution. In this paper, we address the problem of how to link specific code commits to test types to improve the predictive performance of learning models in improving regression testing. We design a dependency taxonomy of the content of committed code and the type of a test case. The taxonomy focuses on two types of code commits: changing memory management and algorithm complexity. We reviewed the literature, surveyed experienced testers from three Swedish-based software companies, and conducted a workshop to develop the taxonomy. The derived taxonomy shows that memory management code should be tested with tests related to performance, load, soak, stress, volume, and capacity; the complexity changes should be tested with the same dedicated tests and maintainability tests. We conclude that this taxonomy can improve the effectiveness of building learning models for regression testing.;;;https://dl.acm.org/doi/10.1145/3475960.3475987;;;Software AND Engineering
RPT: effective and efficient retrieval of program translations from big code;;;['Binger Chen', 'Ziawasch Abedjan'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;Program translation is a growing demand in software engineering. Manual program translation requires programming expertise in source and target language. One way to automate this process is to make use of the big data of programs, i.e., Big Code. In particular, one can search for program translations in Big Code. However, existing code retrieval techniques are not designed for cross-language code retrieval. Other data-driven approaches require human efforts in constructing cross-language parallel datasets to train translation models. In this paper, we present Rpt, a novel code translation retrieval system. We propose a lightweight but informative program representation, which can be generalized to all imperative PLs. Furthermore, we present our index structure and hierarchical filtering mechanism for efficient code retrieval from a Big Code database.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00117;;;Software AND Engineering
A machine learning model to classify the feature model maintainability;;;['Publio Silva', 'Carla I. M. Bezerra', 'Ivan Machado'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;Software Product Lines (SPL) are generally specified using a Feature Model (FM), an artifact designed in the early stages of the SPL development life cycle. This artifact can quickly become too complex, which makes it challenging to maintain an SPL. Therefore, it is essential to evaluate the artifact's maintainability continuously. The literature brings some approaches that evaluate FM maintainability through the aggregation of maintainability measures. Machine Learning (ML) models can be used to create these approaches. They can aggregate the values of independent variables into a single target data, also called a dependent variable. Besides, when using white-box ML models, it is possible to interpret and explain the ML model results. This work proposes white-box ML models intending to classify the FM maintainability based on 15 measures. To build the models, we performed the following steps: (i) we compared two approaches to evaluate the FM maintainability through a human-based oracle of FM maintainability classifications; (ii) we used the best approach to pre-classify the ML training dataset; (iii) we generated three ML models and compared them against classification accuracy, precision, recall, F1 and AUC-ROC; and, (iv) we used the best model to create a mechanism capable of providing improvement indicators to domain engineers. The best model used the decision tree algorithm that obtained accuracy, precision, and recall of 0.81, F1-Score of 0.79, and AUC-ROC of 0.91. Using this model, we could reduce the number of measures needed to evaluate the FM maintainability from 15 to 9 measures.;;;https://dl.acm.org/doi/10.1145/3461001.3471152;;;Software AND Engineering
Analysis and Visualisation of Time Series Data on Networks with Pathpy;;;['Jürgen Hackl', 'Ingo Scholtes', 'Luka V. Petrović', 'Vincenzo Perri', 'Luca Verginer', 'Christoph Gote'];;;April 2021;;;WWW '21: Companion Proceedings of the Web Conference 2021;;;The Open Source software package pathpy, available at https://www.pathpy.net, implements statistical techniques to learn optimal graphical models for the causal topology generated by paths in time-series data. Operationalizing Occam’s razor, these models balance model complexity with explanatory power for empirically observed paths in relational time series. Standard network analysis is justified if the inferred optimal model is a first-order network model. Optimal models with orders larger than one indicate higher-order dependencies and can be used to improve the analysis of dynamical processes, node centralities and clusters.;;;https://dl.acm.org/doi/10.1145/3442442.3452052;;;Software AND Engineering
A Systematic Approach for Mining Quality of Services: A methodology and a case study;;;['Sara Alsiari', 'Amany Alnahdi'];;;February 2022;;;ASSE' 22: 2022 3rd Asia Service Sciences and Software Engineering Conference;;;Web services are used to provide different software functionalities to Web service users. Web services can be further classified according to their quality. Mining and visualizing quality attributes could help Web service selectors to find the appropriate Web service based on visual figures representing the quality instead of looking at different values and numbers. Moreover, it provides stakeholders in the service computing domain a comprehensive view of the Quality of Service (QoS) performance of a group of Web services. This research proposes a systematic methodology for mining Web services' qualities. It studies the aspects of using clustering regarding Web service quality. A case study was conducted using K-mean clustering to divide a Web services pool based on quality criteria into subgroups.;;;https://dl.acm.org/doi/10.1145/3523181.3523202;;;Software AND Engineering
APIzation: generating reusable APIs from StackOverflow code snippets;;;['Valerio Terragni', 'Pasquale Salza'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Developer forums like StackOverflow have become essential resources to modern software development practices. However, many code snippets lack a well-defined method declaration, and thus they are often incomplete for immediate reuse. Developers must adapt the retrieved code snippets by parameterizing the variables involved and identifying the return value. This activity, which we call APIzation of a code snippet, can be tedious and time-consuming. In this paper, we present APIzator to perform APIzations of Java code snippets automatically. APIzator is grounded by four common patterns that we extracted by studying real APIzations in GitHub. APIzator presents a static analysis algorithm that automatically extracts the method parameters and return statements. We evaluated APIzator with a ground-truth of 200 APIzations collected from 20 developers. For 113 (56.50 %) and 115 (57.50 %) APIzations, APIzator and the developers extracted identical parameters and return statements, respectively. For 163 (81.50 %) APIzations, either the parameters or the return statements were identical.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678576;;;Software AND Engineering
NeuroSPF: a tool for the symbolic analysis of neural networks;;;['Muhammad Usman', 'Yannic Noller', 'Corina S. Păsăreanu', 'Youcheng Sun', 'Divya Gopinath'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;This paper presents NeuroSPF, a tool for the symbolic analysis of neural networks. Given a trained neural network model, the tool extracts the architecture and model parameters and translates them into a Java representation that is amenable for analysis using the Symbolic PathFinder symbolic execution tool. Notably, NeuroSPF encodes specialized peer classes for parsing the model's parameters, thereby enabling efficient analysis. With NeuroSPF the user has the flexibility to specify either the inputs or the network internal parameters as symbolic, promoting the application of program analysis and testing approaches from software engineering to the field of machine learning. For instance, NeuroSPF can be used for coverage-based testing and test generation, finding adversarial examples and also constraint-based repair of neural networks, thus improving the reliability of neural networks and of the applications that use them. Video URL: https://youtu.be/seal8fG78LI;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00027;;;Software AND Engineering
Research on the Current Development of Computer Technology in diaital media art;;;['Chunfang Wan'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;This paper focuses on the development of computer technology in digital media art. With the leapfrog progress of science and technology, the computer and digital media technology industry has developed rapidly, The digital industry formed by the combination of human wisdom and high and new technology has developed rapidly. With the rapid development of digital media, many learning resources and videos began to appear in a digital way. promoting the sharing and communication of resources. By breaking through tradition and bold application of new materials and new technologies, digital media art has developed rapidly and digital media is becoming increasingly modern.;;;https://dl.acm.org/doi/10.1145/3501409.3501688;;;Software AND Engineering
An Empirical Study of Refactorings and Technical Debt in Machine Learning Systems;;;['Yiming Tang', 'Raffi Khatchadourian', 'Mehdi Bagherzadeh', 'Rhia Singh', 'Ajani Stewart', 'Anita Raja'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Machine Learning (ML), including Deep Learning (DL), systems, i.e., those with ML capabilities, are pervasive in today's data-driven society. Such systems are complex; they are comprised of ML models and many subsystems that support learning processes. As with other complex systems, ML systems are prone to classic technical debt issues, especially when such systems are long-lived, but they also exhibit debt specific to these systems. Unfortunately, there is a gap of knowledge in how ML systems actually evolve and are maintained. In this paper, we fill this gap by studying refactorings, i.e., source-to-source semantics-preserving program transformations, performed in real-world, open-source software, and the technical debt issues they alleviate. We analyzed 26 projects, consisting of 4.2 MLOC, along with 327 manually examined code patches. The results indicate that developers refactor these systems for a variety of reasons, both specific and tangential to ML, some refactorings correspond to established technical debt categories, while others do not, and code duplication is a major crosscutting theme that particularly involved ML configuration and model code, which was also the most refactored. We also introduce 14 and 7 new ML-specific refactorings and technical debt categories, respectively, and put forth several recommendations, best practices, and anti-patterns. The results can potentially assist practitioners, tool developers, and educators in facilitating long-term ML system usefulness.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00033;;;Software AND Engineering
A Heterogeneous MPI+PPL Task Scheduling Approach for Asynchronous Many-Task Runtime Systems;;;['John Holmen', 'Damodar Sahasrabudhe', 'Martin Berzins'];;;July 2021;;;PEARC '21: Practice and Experience in Advanced Research Computing;;;Asynchronous many-task runtime systems and MPI+X hybrid parallelism approaches have shown promise for helping manage the increasing complexity of nodes in current and emerging high performance computing (HPC) systems, including those for exascale. The increasing architectural diversity of these systems, however, poses challenges for runtimes supporting more homogeneous HPC systems. Performance portability layers (PPL) have shown promise for helping manage this diversity. This paper describes a heterogeneous MPI+PPL task scheduling approach for combining these promising solutions with additional consideration for parallel third party libraries facing similar challenges to help prepare such a runtime for the diverse heterogeneous systems accompanying exascale computing. This approach is demonstrated using a heterogeneous MPI+Kokkos task scheduler and the accompanying portable abstractions [16] implemented in the Uintah Computational Framework, an asynchronous many-task runtime system, with additional consideration for hypre, a parallel third party library. Results are shown for two challenging problems executing workloads representative of typical Uintah applications. These results show performance improvements up to 4.4x when using this scheduler and the accompanying portable abstractions [16] to port a previously MPI-Only problem to Kokkos::OpenMP and Kokkos::CUDA to improve complex heterogeneous node use. Good strong-scaling to 1,024 NVIDIA V100 GPUs and 512 IBM POWER9 processor are also shown using MPI+Kokkos::OpenMP+Kokkos::CUDA at scale.;;;https://dl.acm.org/doi/10.1145/3437359.3465581;;;Software AND Engineering
NNStreamer: efficient and Agile† development of on-device AI systems;;;['MyungJoo Ham', 'Jijoong Moon', 'Geunsik Lim', 'Jaeyun Jung', 'Hyoungjoo Ahn', 'Wook Song', 'Sangjung Woo', 'Parichay Kapoor', 'Dongju Chae', 'Gichan Jang', 'Yongjoo Ahn', 'Jihoon Lee'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;We propose NNStreamer, a software system that handles neural networks as filters of stream pipelines, applying the stream processing paradigm to deep neural network applications. A new trend with the wide-spread of deep neural network applications is on-device AI. It is to process neural networks on mobile devices or edge/IoT devices instead of cloud servers. Emerging privacy issues, data transmission costs, and operational costs signify the need for on-device AI, especially if we deploy a massive number of devices. NNStreamer efficiently handles neural networks with complex data stream pipelines on devices, significantly improving the overall performance with minimal effort. Besides, NNStreamer simplifies implementations and allows reusing off-the-shelf media filters directly, which reduces developmental costs significantly. We are already deploying NNStreamer for a wide range of products and platforms, including the Galaxy series and various consumer electronic devices. The experimental results suggest a reduction in developmental costs and enhanced performance of pipeline architectures and NNStreamer. It is an open-source project incubated by Linux Foundation AI & Data, available to the public and applicable to various hardware and software platforms.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00029;;;Software AND Engineering
Health Evaluation System of National Higher Education Based on Improved Entropy Weight Method Combined with GE Matrix;;;['Bo Liu', 'Zheng Li'];;;October 2021;;;CSAE '21: Proceedings of the 5th International Conference on Computer Science and Application Engineering;;;In order to measure whether a country's higher education system is healthy and sustainable, the higher education system (hereinafter referred to as HES) is divided into three aspects: input, environment, and output. These three aspects are analyzed and refined respectively, which are used as indicators to quantify the HES and establish the evaluation framework of HES. Based on the entropy weight method improved by normalizing data collected from various countries of the world, the weight of three aspects and the scores of the health degree and sustainability of HES can be determined. Finally, after integrating results into GE matrix, a system is established to measure the health status of any country's HES. Based on the National Higher Education Evaluation System (hereinafter referred to as NHEES) established in this paper, further discussion is made to analyze and verify the effectiveness of the system. The application of the system can evaluate the health status of higher education in any country of the world, make relevant decisions and innovations to specific countries.;;;https://dl.acm.org/doi/10.1145/3487075.3487096;;;Software AND Engineering
Does culture matter?: impact of individualism and uncertainty avoidance on app reviews;;;['Ricarda Anna-Lena Fischer', 'Rita Walczuch', 'Emitza Guzman'];;;May 2021;;;ICSE-SEIS '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Society;;;Mobile applications are often used by an international audience and therefore receive a high daily amount of user reviews from various countries. Previous work found evidence that app store reviews contain helpful information for software evolution processes. However, the cultural diversity of the reviews and its consequences on specific user feedback characteristics has only been researched to a limited extent so far. In this paper, we examine the influence of two cultural dimensions, Individualism and Uncertainty Avoidance on user feedback in Apple app store reviews written in different languages. For this purpose, we collected 647,141 reviews from eight countries and written in five languages over a period of six months. We then used manual content analysis and automated processing to examine a sample of 3,120 reviews. The results show that there is a statistically significant influence of Individualism and Uncertainty Avoidance on user feedback characteristics. The results of this study will help researchers and practitioners to reduce algorithm bias caused by less diversified training and test data and to raise awareness of the importance of analyzing diversified user feedback.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIS52602.2021.00016;;;Software AND Engineering
How Should I Improve the UI of My App?: A Study of User Reviews of Popular Apps in the Google Play;;;['Qiuyuan Chen', 'Chunyang Chen', 'Safwat Hassan', 'Zhengchang Xing', 'Xin Xia', 'Ahmed E. Hassan'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;UI (User Interface) is an essential factor influencing users’ perception of an app. However, it is hard for even professional designers to determine if the UI is good or not for end-users. Users’ feedback (e.g., user reviews in the Google Play) provides a way for app owners to understand how the users perceive the UI. In this article, we conduct an in-depth empirical study to analyze the UI issues of mobile apps. In particular, we analyze more than 3M UI-related reviews from 22,199 top free-to-download apps and 9,380 top non-free apps in the Google Play Store. By comparing the rating of UI-related reviews and other reviews of an app, we observe that UI-related reviews have lower ratings than other reviews. By manually analyzing a random sample of 1,447 UI-related reviews with a 95% confidence level and a 5% interval, we identify 17 UI-related issues types that belong to four categories (i.e., “Appearance,” “Interaction,” “Experience,” and “Others”). In these issue types, we find “Generic Review” is the most occurring one. “Comparative Review” and “Advertisement” are the most negative two UI issue types. Faced with these UI issues, we explore the patterns of interaction between app owners and users. We identify eight patterns of how app owners dialogue with users about UI issues by the review-response mechanism. We find “Apology or Appreciation” and “Information Request” are the most two frequent patterns. We find updating UI timely according to feedback is essential to satisfy users. Besides, app owners could also fix UI issues without updating UI, especially for issue types belonging to “Interaction” category. Our findings show that there exists a positive impact if app owners could actively interact with users to improve UI quality and boost users’ satisfactoriness about the UIs.;;;https://dl.acm.org/doi/10.1145/3447808;;;Software AND Engineering
Proof repair across type equivalences;;;['Talia Ringer', 'RanDair Porter', 'Nathaniel Yazdani', 'John Leo', 'Dan Grossman'];;;June 2021;;;PLDI 2021: Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation;;;We describe a new approach to automatically repairing broken proofs in the Coq proof assistant in response to changes in types. Our approach combines a configurable proof term transformation with a decompiler from proof terms to suggested tactic scripts. The proof term transformation implements transport across equivalences in a way that removes references to the old version of the changed type and does not rely on axioms beyond those Coq assumes.  We have implemented this approach in Pumpkin Pi, an extension to the Pumpkin Patch Coq plugin suite for proof repair. We demonstrate Pumpkin Pi’s flexibility on eight case studies, including supporting a benchmark from a user study,easing development with dependent types, porting functions and proofs between unary and binary numbers, and supporting an industrial proof engineer to interoperate between Coq and other verification tools more easily.;;;https://dl.acm.org/doi/10.1145/3453483.3454033;;;Software AND Engineering
Toward static test flakiness prediction: a feasibility study;;;['Valeria Pontillo', 'Fabio Palomba', 'Filomena Ferrucci'];;;August 2021;;;MaLTESQuE 2021: Proceedings of the 5th International Workshop on Machine Learning Techniques for Software Quality Evolution;;;Flaky tests are tests that exhibit both a passing and failing behavior when run against the same code. While the research community has attempted to define automated approaches for detecting and addressing test flakiness, most of them suffer from scalability issues and uncertainty as they require test cases to be run multiple times. This limitation has been recently targeted by means of machine learning solutions that could predict the flakiness of tests using a set of both static and dynamic metrics that would avoid the re-execution of tests. Recognizing the effort spent so far, this paper poses the first steps toward an orthogonal view of the problem, namely the classification of flaky tests using only statically computable software metrics. We propose a feasibility study on 72 projects of the iDFlakies dataset, and investigate the differences between flaky and non-flaky tests in terms of 25 test and production code metrics and smells. First, we statistically assess those differences. Second, we build a logistic regression model to verify the extent to which the differences observed are still significant when the metrics are considered together. The results show a relation between test flakiness and a number of test and production code factors, indicating the possibility to build classification approaches that exploit those factors to predict test flakiness.;;;https://dl.acm.org/doi/10.1145/3472674.3473981;;;Software AND Engineering
A Context-based Automated Approach for Method Name Consistency Checking and Suggestion;;;['Yi Li', 'Shaohua Wang', 'Tien N. Nguyen'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Misleading method names in software projects can confuse developers, which may lead to software defects and affect code understandability. In this paper, we present DeepName, a context-based, deep learning approach to detect method name inconsistencies and suggest a proper name for a method. The key departure point is the philosophy of "Show Me Your Friends, I'll Tell You Who You Are". Unlike the state-of-the-art approaches, in addition to the method's body, we also consider the interactions of the current method under study with the other ones including the caller and callee methods, and the sibling methods in the same enclosing class. The sequences of sub-tokens in the program entities' names in the contexts are extracted and used as the input for an RNN-based encoder-decoder to produce the representations for the current method. We modify that RNN model to integrate the copy mechanism and our newly developed component, called the non-copy mechanism, to emphasize on the possibility of a certain sub-token not to be copied to follow the current sub-token in the currently generated method name. We conducted several experiments to evaluate DEEPNAME on large datasets with +14M methods. For consistency checking, DeepName improves the state-of-the-art approach by 2.1%, 19.6%, and 11.9% relatively in recall, precision, and F-score, respectively. For name suggestion, DeepName improves relatively over the state-of-the-art approaches in precision (1.8%-30.5%), recall (8.8%-46.1%), and F-score (5.2%-38.2%). To assess DEEPNAME's usefulness, we detected inconsistent methods and suggested new method names in active projects. Among 50 pull requests, 12 were merged into the main branch. In total, in 30/50 cases, the team members agree that our suggested method names are more meaningful than the current names.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00060;;;Software AND Engineering
Deepbug: Bug Injection in Depth;;;['Wanli Shi', 'Guomiao Zhou', 'Zehui Wu', 'Huiyong Zhang'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;There has been a lot of research devoted to finding real-world software bugs, but these studies have lacked some standard test sets as test subjects, especially in the area of synthetic bugs. Although studies such as LAVA and Apocalypse have now suggested ways to inject bugs into real software, these injected bugs are either a single type or the injection points are easily accessed by bug exploiters. In this paper, we propose a bug injection system Deepbug that combines path extraction and taint analysis, through which more hidden bugs can be injected into real software. In our experiments, using Deepbug to inject bugs into four existing open-source software, through fuzz testing of defective software, we found that only a small number of these injected bugs were found by fuzzing tools.;;;https://dl.acm.org/doi/10.1145/3501409.3501538;;;Software AND Engineering
Transductive Instance Transfer Learning for Cross-Language Defect Prediction;;;['Rahul Chopra', 'Shreoshi Roy', 'Ruchika Malhotra'];;;January 2022;;;APIT '22: Proceedings of the 2022 4th Asia Pacific Information Technology Conference;;;Predicting defects (bugs) is critical to increasing software quality. Many software defect prediction algorithms have been presented, and many of them have shown to be effective in practice. However, because existing works are largely limited to a single project, their effectiveness in predicting cross-project defects is usually poor. This is primarily due to the issue of class imbalance and discrepancies in feature distribution between the source and destination projects. However, because of the disparities in distribution amongst datasets from different studies, developing high-quality Cross Project Defect Prediction (CPDP) models remains a difficulty. In our study, instead of collecting data from a single project, we have collected source code from multiple code submissions on a programming contest website and employed Natural Language Processing (NLP) models to detect software defects in them.;;;https://dl.acm.org/doi/10.1145/3512353.3512379;;;Software AND Engineering
Comparison of Land Cover Classification of Ir Sutami Dam Using Machine Learning and Multisource Satellite Imagery;;;['Ainia Walidaroyani', 'Fatwa Ramdani', 'Tri Astoto Kurniawan'];;;September 2021;;;SIET '21: Proceedings of the 6th International Conference on Sustainable Information Engineering and Technology;;;The latest land cover information in the form of maps resulting from image classification can be obtained through remote sensing techniques that utilize satellite imagery, such as Landsat 8 and Sentinel-2. However, no study compares the two satellite images with high classification algorithm accuracy. The previous literature describes several techniques that can be used to classify land cover, but there has been no specific use of similar techniques in the Ir. Sutami. In this study, the author uses a classification technique using the CART (Classification and Regression Tree) algorithm which can present the classification results as a simple tree structure to make the classification process easier and closer. The results of processing Landsat 8 and Sentinel-2 satellite imagery in 2020 show accuracy test results at 91% and 97% for vegetation classes, water bodies, built land, open land, and rice fields. We hope this research can help in providing information to cover the land in the area around Ir. Sutami to avoid the negative impacts of future land-use changes.;;;https://dl.acm.org/doi/10.1145/3479645.3479681;;;Software AND Engineering
Automatic event categorizer for SIEM;;;['S M Mozammal Hossain', 'Russell Couturier', 'Jeff Rusk', 'Kenneth B. Kent'];;;November 2021;;;CASCON '21: Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;;;Security Information and Event Management (SIEM) is a software solution that is the latest technological achievement for fighting cybersecurity. SIEM's strength is its ability to understand device, software, and hardware generated logs or events and monitor, analyze, and correlate them to detect and prevent Cyber-attacks. SIEM collects events from various sources e.g.., network devices, servers, domain controllers, and more. After collection SIEM stores, normalizes, aggregates, and applies analytics to collected events. The intention for analyzing an event is to discover trends, discover threats, and enable organizations to investigate security incidents. Due to the nature of the work SIEM performs, categorizing collected events is one of its most important tasks. Categorization provides useful insights into an event and accurate categorization enables a security analyst to take appropriate actions for blocking or eliminating cybersecurity threats. Traditionally categorization is done manually. It requires a substantial amount of domain knowledge, vulnerability information, and most importantly experience. It is a known fact that there exists a resource shortage in the cybersecurity space. As more and more devices are being integrated with SIEM and the number of new events increases, it is becoming a daunting task for any SIEM provider to perform this essential work manually. In this paper, we present an automatic event categorization tool for overcoming the event categorization challenges mentioned. The categorization system uses IBM's QRadar SIEM event categorization standard and machine learning techniques for analyzing an event and recommending an event category.;;;https://dl.acm.org/doi/10.5555/3507788.3507803;;;Software AND Engineering
Quartermaster: a tool for modeling and simulating system degradation;;;['Matt Pope', 'Jonathan Sillito'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;It is essential that software systems be tolerant to degradations in components they rely on. There are patterns and techniques which software engineers use to ensure their systems gracefully degrade. Despite these techniques being available in practice, tuning and configuration is hard to get right and it is expensive to explore possible changes to components and techniques in complex systems. To fill these gaps, we propose Quartermaster to model and simulate systems and fault-tolerant techniques. We anticipate that Quartermaster will be useful to further research on graceful degradation and help inform software engineers about techniques that are most appropriate for their use cases.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00035;;;Software AND Engineering
Automatic Extraction of Opinion-based Q&A from Online Developer Chats;;;['Preetha Chatterjee', 'Kostadin Damevski', 'Lori Pollock'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Virtual conversational assistants designed specifically for software engineers could have a huge impact on the time it takes for software engineers to get help. Research efforts are focusing on virtual assistants that support specific software development tasks such as bug repair and pair programming. In this paper, we study the use of online chat platforms as a resource towards collecting developer opinions that could potentially help in building opinion Q&A systems, as a specialized instance of virtual assistants and chatbots for software engineers. Opinion Q&A has a stronger presence in chats than in other developer communications, thus mining them can provide a valuable resource for developers in quickly getting insight about a specific development topic (e.g., What is the best Java library for parsing JSON?). We address the problem of opinion Q&A extraction by developing automatic identification of opinion-asking questions and extraction of participants' answers from public online developer chats. We evaluate our automatic approaches on chats spanning six programming communities and two platforms. Our results show that a heuristic approach to opinion-asking questions works well (.87 precision), and a deep learning approach customized to the software domain outperforms heuristics-based, machine-learning-based and deep learning for answer extraction in community question answering.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00115;;;Software AND Engineering
Cross-lingual transfer learning framework for program analysis;;;['Zhiming Li'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Deep learning-based techniques have been widely applied to program analysis tasks, in fields such as type inference, fault localization, and code summarization. Hitherto deep learning-based software engineering systems rely thoroughly on supervised learning approaches, which require laborious manual effort to collect and label a prohibitively large amount of data. However, most Turing-complete imperative languages share similar control- and data-flow structures, which make it possible to transfer knowledge learned from one language to another. In this paper, we propose a general cross-lingual transfer learning framework PLATO for program analysis by using a series of techniques that are general to different downstream tasks. PLATO allows Bert-based models to leverage prior knowledge learned from the labeled dataset of one language and transfer it to the others. We evaluate our approaches on several downstream tasks such as type inference and code summarization to demonstrate its feasibility.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678848;;;Software AND Engineering
Quartermaster: a tool for modeling and simulating system degradation;;;['Matt Pope', 'Jonathan Sillito'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;;;It is essential that software systems be tolerant to degradations in components they rely on. There are patterns and techniques which software engineers use to ensure their systems gracefully degrade. Despite these techniques being available in practice, tuning and configuration is hard to get right and it is expensive to explore possible changes to components and techniques in complex systems. To fill these gaps, we propose Quartermaster to model and simulate systems and fault-tolerant techniques. We anticipate that Quartermaster will be useful to further research on graceful degradation and help inform software engineers about techniques that are most appropriate for their use cases.;;;https://dl.acm.org/doi/10.1109/ICSE-Companion52605.2021.00035;;;Software AND Engineering
A Machine Learning Approach for Suggesting Feedback in Textual Exercises in Large Courses;;;['Jan Philip Bernius', 'Stephan Krusche', 'Bernd Bruegge'];;;June 2021;;;L@S '21: Proceedings of the Eighth ACM Conference on Learning @ Scale;;;Open-ended textual exercises facilitate the comprehension of problem-solving skills. Students can learn from their mistakes when teachers provide individual feedback. However, courses with hundreds of students cause a heavy workload for teachers: providing individual feedback is mostly a manual, repetitive, and time-consuming activity. This paper presents CoFee, a machine learning approach designed to suggest computer-aided feedback in open-ended textual exercises. The approach uses topic modeling to split student answers into text segments and language embeddings to transform these segments. It then applies clustering to group the text segments by similarity so that the same feedback can be applied to all segments within the same cluster. We implemented this approach in a reference implementation called Athene and integrated it into Artemis. We used Athene to review 17 textual exercises in two large courses at the Technical University of Munich with 2,300 registered students and 53 teachers. On average, Athene suggested feedback for 26% of the submissions. Accordingly, 85% of these suggestions were accepted by the teachers, 5% were extended with a comment and then accepted, and 10% were changed.;;;https://dl.acm.org/doi/10.1145/3430895.3460135;;;Software AND Engineering
Enhancing the learning of database access programming using continuous integration and aspect oriented programming;;;['Beatriz Pérez'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Database access programming is a noteworthy component of Software Engineering (SE) education on databases that students are expected to acquire during training for their careers. In our university, we cover such an education in a course that emphasizes the use of the JDBC API to access databases. This paper presents our experiences in developing and running a framework to enhance the learning experience of database access programming, which is motivated by several factors. First, our students face great demands on acquiring JDBC acknowledge, and providing them with constructive feedback serves a critical role. Second, the increasing number of students leads to high efforts in managing and grading their assignments. Finally, we consider of strategic importance to bring modern industrial SE techniques into the classroom, so that students obtain a better experience with industry practices. Our framework draws upon constructive alignment and automated formative assessment, combining Continuous Integration (CI) and Aspect Oriented Programming (AOP). We include an innovative application of AOP, a programming technique that aims to modularize inherently scattered functionality into single functional units, to help students adopt well-established JDBC best practices. We also use well-known industrial software tools (Travis CI and GitHub) to manage and grade students' assignments and support automated integration testing with databases. The findings of this study, applied to a class of 53 students, suggest positive effects, such as motivate students to implement JDBC best practices, streamline the management and grading of their assignments, help them get familiar with industrial tools, or improve their grades.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00032;;;Software AND Engineering
Product-lining the elinvar wealthtech microservice platform;;;['Marcus Pinnecke'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume B;;;Software product lining is the act of providing different but related software products under the same brand, known as a software product line (SPL). As engineering, management and validation of SPLs is far from trivial, special solutions for software product line engineering (SPLE) have a continuous momentum in both academic and industry. In general, it is hard to judge when to reasonably favor SPLE over alternative solutions that are more common in the industry. In this paper, we illustrate how we as Elinvar manage variability within our WealthTech Platform as a Service (PaaS) at different granularity levels, and discuss methods for SPLE in this context. More in detail, we share our techniques and concepts to address configuration management, and show how we manage a single microservice SPL including inter-service communication. Finally, we provide insights into platform solutions by means of packages for our clients. We end with a discussion on SPLE techniques in context of service SPLs and our packaging strategy. We conclude that while we are good to go with industry-standard approaches for microservice SPLs, the variability modeling and analysis advantages within SPLE is promising for our packaging strategy.;;;https://dl.acm.org/doi/10.1145/3461002.3473947;;;Software AND Engineering
JFD: Automatic Java Fuzz Driver Generation;;;['Zhuo Chen', 'Yongjun Wang'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;Java is widely used in many areas. There have been a lot of works on improving the security of Java. In the industry, fuzzing is the most efficient software testing technique to discover real-world vulnerabilities and improve software security. Recent efforts are seen to make library fuzzing more automatically and have performed well in general library fuzzing. However, these tools cannot solve problems in Java library fuzzing appropriately. In this paper, we present JFD, an automatic Java fuzz driver generation system, which can generate fuzz drivers based on consumer programs, that utilize target library programs. Our approach consists of three parts: a static-analysis-based method to analyze call dependencies graphs of target Java library, a value-set-based method to analyze argument dependencies graphs of target Java library, and a method to synthesize fuzz drivers in the style of JQF. We then evaluate JFD on JVM native libraries. JFD can generate appropriate fuzz drivers.;;;https://dl.acm.org/doi/10.1145/3501409.3501564;;;Software AND Engineering
A Scoring System for Information Security Governance Framework Using Deep Learning Algorithms: A Case Study on the Banking Sector;;;['Abeer A. Al Batayneh', 'Malik Qasaimeh', 'Raad S. Al-Qassas'];;;None;;;Journal of Data and Information Quality;;;Cybercrime reports showed an increase in the number of attacks targeting financial institutions. Indeed, banks were the target of 30% of the total number of cyber-attacks. One of the recommended methods for driving the security challenges is to implement an Information Security Governance Framework (ISGF), a comprehensive practice that starts from the top management and ends with the smallest function in a bank. Although such initiatives are effective, they typically take years to achieve and require loads of resources, especially for larger banks or if there are multiple ISGFs available for the bank to choose. These implementation challenges showed the necessity of having a method for evaluating the adequacy of an ISGF for a bank. The research performed during the preparation of this article did not reveal any available structured evaluation method for an ISGF before its implementation. This chapter introduces a novel method for scoring an ISGF to assess its adequacy for a bank without implementing it. The suggested approach is based on ISGF decomposition and transformation into a survey that will be answered by security experts. The survey results were loaded into a Deep Learning Algorithm that produced a scoring model that could predict the adequacy of an ISGF for a bank with an accuracy of 75%.;;;https://dl.acm.org/doi/10.1145/3418172;;;Software AND Engineering
Model Provenance Management in MLOps Pipeline;;;['Songzhu Mei', 'Cong Liu', 'Qinglin Wang', 'Huayou Su'];;;January 2022;;;ICCDE '22: Proceedings of the 2022 8th International Conference on Computing and Data Engineering;;;None;;;https://dl.acm.org/doi/10.1145/3512850.3512861;;;Software AND Engineering
Leveraging Control Flow Knowledge in SMT Solving of Program Verification;;;['Jianhui Chen', 'Fei He'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Satisfiability modulo theories (SMT) solvers have been widely applied as the reasoning engine for diverse software analysis and verification technologies. The efficiency of the SMT solver has significant effects on the performance of these technologies. However, current SMT solvers are designed for the general purpose of constraint solving. Lots of useful knowledge of programs cannot be utilized during SMT solving. As a result, the SMT solver may spend much effort to explore redundant search space. In this article, we propose a novel approach to utilizing control-flow knowledge in SMT solving. With this technique, the search space can be considerably reduced, and the efficiency of SMT solving is observably improved. We conducted extensive experiments on credible benchmarks. The results show significant improvements of our approach.;;;https://dl.acm.org/doi/10.1145/3446211;;;Software AND Engineering
A Machine Learning Based Ensemble Method for Automatic Multiclass Classification of Decisions;;;['Liming Fu', 'Peng Liang', 'Xueying Li', 'Chen Yang'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Stakeholders make various types of decisions with respect to requirements, design, management, and so on during the software development life cycle. Nevertheless, these decisions are typically not well documented and classified due to limited human resources, time, and budget. To this end, automatic approaches provide a promising way. In this paper, we aimed at automatically classifying decisions into five types to help stakeholders better document and understand decisions. First, we collected a dataset from the Hibernate developer mailing list. We then experimented and evaluated 270 configurations regarding feature selection, feature extraction techniques, and machine learning classifiers to seek the best configuration for classifying decisions. Especially, we applied an ensemble learning method and constructed ensemble classifiers to compare the performance between ensemble classifiers and base classifiers. Our experiment results show that (1) feature selection can decently improve the classification results; (2) ensemble classifiers can outperform base classifiers provided that ensemble classifiers are well constructed; (3) BoW + 50% features selected by feature selection with an ensemble classifier that combines Naïve Bayes (NB), Logistic Regression (LR), and Support Vector Machine (SVM) achieves the best classification result (with a weighted precision of 0.750, a weighted recall of 0.739, and a weighted F1-score of 0.727) among all the configurations. Our work can benefit various types of stakeholders in software development through providing an automatic approach for effectively classifying decisions into specific types that are relevant to their interests.;;;https://dl.acm.org/doi/10.1145/3463274.3463325;;;Software AND Engineering
Reforming assessment: challenges beyond design;;;['Laura Tubino', 'Jean-Guy Schneider', 'Andrew Cain', 'Dhananjay Thiruvady', 'Chathu Ranaweera'];;;May 2021;;;ICSE-JSEET '21: Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;;;Promoting evidence-based assessment practices at scale across different disciplines is a challenge. Feedback, although powerful for affecting change in students, is not always adequately implemented. An assessment framework based on strong formative feedback and other evidence-based educational practices was designed to give capstone project students an authentic learning experience, and was deployed across all our Software Engineering capstone project units involving more than 700 students and app. 30 academic staff members per teaching period. The scale of our setting raised the question about consistent and faithful implementation of the framework and its guiding principles, essential for achieving the assessment framework outcomes and equitability for students. In this study, we explore the challenges of implementing assessment practice at scale and report on our findings and support strategies in order to facilitate consistent engagement of teaching staff. The findings of our study form the building blocks of a decision-making framework to guide the implementation of ongoing pedagogical innovations at scale.;;;https://dl.acm.org/doi/10.1109/ICSE-SEET52601.2021.00017;;;Software AND Engineering
Security Notifications in Static Analysis Tools: Developers’ Attitudes, Comprehension, and Ability to Act on Them;;;['Mohammad Tahaei', 'Kami Vaniea', 'Konstantin (Kosta) Beznosov', 'Maria K Wolters'];;;May 2021;;;CHI '21: Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems;;;Static analysis tools (SATs) have the potential to assist developers in finding and fixing vulnerabilities in the early stages of software development, requiring them to be able to understand and act on tools’ notifications. To understand how helpful such SAT guidance is to developers, we ran an online experiment (N=132) where participants were shown four vulnerable code samples (SQL injection, hard-coded credentials, encryption, and logging sensitive data) along with SAT guidance, and asked to indicate the appropriate fix. Participants had a positive attitude towards both SAT notifications and particularly liked the example solutions and vulnerable code. Seeing SAT notifications also led to more detailed open-ended answers and slightly improved code correction answers. Still, most SAT (SpotBugs 67%, SonarQube 86%) and Control (96%) participants answered at least one code-correction question incorrectly. Prior software development experience, perceived vulnerability severity, and answer confidence all positively impacted answer accuracy.;;;https://dl.acm.org/doi/10.1145/3411764.3445616;;;Software AND Engineering
On the relation between technical debt indicators and quality criteria in Stack Overflow discussions;;;['Diego Costa', 'Mariela Cortés', 'Eliakim Gama'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Context: Technical debt (TD) can compromise the quality of software systems in the long term. However, depending on the needs and properties of the specific product, different quality characteristics may be considered in the assessment with different levels of relevance. In this way, quality characteristics can guide teams in managing the TD, from identifying to paying for the TD items relevant to each situation. Although a set of TD item indicators has been identified in the literature, there is no clear guidance on how these indicators can be efficiently used to identify TD items. Aims: To investigate, from the point of view of software professionals using the SO platform, the relationship between the TD item indicators and the quality characteristics of the system, in order to guide the use of indicators for greater efficiency and effectiveness in identifying and managing DT items from a quality perspective. Method: We extracted empirical evidence using data mining from discussions related to TD on the SO. From the execution of an analysis process, the quality characteristics related to the occurrence of DT items identified in the discussions, the respective indicators and types of debt were identified. Results: The main results reveal that maintainability is the characteristic most related to TD through its sub-characteristics: modifiability, testability and modularity. Code debt items can be related to all quality characteristics, while Infrastructure debt can resonate up to 6 characteristics. All quality characteristics have at least one associated indicator, with an emphasis on Maintainability with 13 high-level and 28 low-level indicators. The indicator related to version problems is the one with the highest number of quality features. Conclusion: The relationship between indicators, TD types and quality characteristics was organized in a conceptual diagram in order to assist software teams in identifying which TD items are related to the quality characteristics that are critical to the project context, contributing to decision making regarding the best strategy for debt management.;;;https://dl.acm.org/doi/10.1145/3474624.3474648;;;Software AND Engineering
RobOT: Robustness-Oriented Testing for Deep Learning Systems;;;['Jingyi Wang', 'Jialuo Chen', 'Youcheng Sun', 'Xingjun Ma', 'Dongxia Wang', 'Jun Sun', 'Peng Cheng'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Recently, there has been a significant growth of interest in applying software engineering techniques for the quality assurance of deep learning (DL) systems. One popular direction is deep learning testing, where adversarial examples (a.k.a. bugs) of DL systems are found either by fuzzing or guided search with the help of certain testing metrics. However, recent studies have revealed that the commonly used neuron coverage metrics by existing DL testing approaches are not correlated to model robustness. It is also not an effective measurement on the confidence of the model robustness after testing. In this work, we address this gap by proposing a novel testing framework called Robustness-Oriented Testing (RobOT). A key part of RobOT is a quantitative measurement on 1) the value of each test case in improving model robustness (often via retraining), and 2) the convergence quality of the model robustness improvement. RobOT utilizes the proposed metric to automatically generate test cases valuable for improving model robustness. The proposed metric is also a strong indicator on how well robustness improvement has converged through testing. Experiments on multiple benchmark datasets confirm the effectiveness and efficiency of RobOT in improving DL model robustness, with 67.02% increase on the adversarial robustness that is 50.65% higher than the state-of-the-art work DeepGini.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00038;;;Software AND Engineering
Towards the generation of machine learning defect reports;;;['Tuan Dung Lai'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Effective locating and fixing defects requires detailed defect reports. Unlike traditional software systems, machine learning applications are subject defects caused from changes in the input data streams (concept drift) and assumptions encoded into models. Without appropriate training, developers face difficulties understanding and interpreting faults in machine learning (ML). However, little research is done on how to prepare developers to detect and investigate machine learning system defects. Software engineers often do not have sufficient knowledge to fix the issues themselves without the help of data scientists or domain experts. To investigate this issue, we analyse issue templates and check how developers report machine learning related issues in open-source applied AI projects. The overall goal is to develop a tool for automatically repairing ML defects or generating defect reports if a fix cannot be made. Previous research has identified classes of faults specific to machine learning systems, such as performance degradation arising from concept drift where the machine learning model is no longer aligned with the real-world environment. However, the current issue templates that developers use do not seem to capture the information needed. This research seeks to systematically develop a two-way human-machine information exchange protocol to support domain experts, software engineers, and data scientists to collaboratively detect, report, and respond to these new classes of faults.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678592;;;Software AND Engineering
Monte Carlo tree search for feature model analyses: a general framework for decision-making;;;['Jose-Miguel Horcas', 'José A. Galindo', 'Ruben Heradio', 'David Fernandez-Amoros', 'David Benavides'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;The colossal solution spaces of most configurable systems make intractable their exhaustive exploration. Accordingly, relevant analyses remain open research problems. There exist analyses alternatives such as SAT solving or constraint programming. However, none of them have explored simulation-based methods. Monte Carlo-based decision making is a simulation-based method for dealing with colossal solution spaces using randomness. This paper proposes a conceptual framework that tackles various of those analyses using Monte Carlo methods, which have proven to succeed in vast search spaces (e.g., game theory). Our general framework is described formally, and its flexibility to cope with a diversity of analysis problems is discussed (e.g., finding defective configurations, feature model reverse engineering or getting optimal performance configurations). Additionally, we present a Python implementation of the framework that shows the feasibility of our proposal. With this contribution, we envision that different problems can be addressed using Monte Carlo simulations and that our framework can be used to advance the state of the art a step forward.;;;https://dl.acm.org/doi/10.1145/3461001.3471146;;;Software AND Engineering
Fast Parametric Model Checking through Model Fragmentation;;;['Xinwei Fang', 'Radu Calinescu', 'Simos Gerasimou', 'Faisal Alhwikem'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Parametric model checking (PMC) computes algebraic formulae that express key non-functional properties of a system (reliability, performance, etc.) as rational functions of the system and environment parameters. In software engineering, PMC formulae can be used during design, e.g., to analyse the sensitivity of different system architectures to parametric variability, or to find optimal system configurations. They can also be used at runtime, e.g., to check if non-functional requirements are still satisfied after environmental changes, or to select new configurations after such changes. However, current PMC techniques do not scale well to systems with complex behaviour and more than a few parameters. Our paper introduces a fast PMC (fPMC) approach that overcomes this limitation, extending the applicability of PMC to a broader class of systems than previously possible. To this end, fPMC partitions the Markov models that PMC operates with into fragments whose reachability properties are analysed independently, and obtains PMC reachability formulae by combining the results of these fragment analyses. To demonstrate the effectiveness of fPMC, we show how our fPMC tool can analyse three systems (taken from the research literature, and belonging to different application domains) with which current PMC techniques and tools struggle.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00081;;;Software AND Engineering
ELSA: hardware-software co-design for efficient, lightweight self-attention mechanism in neural networks;;;['Tae Jun Ham', 'Yejin Lee', 'Seong Hoon Seo', 'Soosung Kim', 'Hyunji Choi', 'Sung Jun Jung', 'Jae W. Lee'];;;June 2021;;;ISCA '21: Proceedings of the 48th Annual International Symposium on Computer Architecture;;;The self-attention mechanism is rapidly emerging as one of the most important key primitives in neural networks (NNs) for its ability to identify the relations within input entities. The self-attention-oriented NN models such as Google Transformer and its variants have established the state-of-the-art on a very wide range of natural language processing tasks, and many other self-attention-oriented models are achieving competitive results in computer vision and recommender systems as well. Unfortunately, despite its great benefits, the self-attention mechanism is an expensive operation whose cost increases quadratically with the number of input entities that it processes, and thus accounts for a significant portion of the inference runtime. Thus, this paper presents ELSA (Efficient, Lightweight Self-Attention), a hardware-software co-designed solution to substantially reduce the runtime as well as energy spent on the self-attention mechanism. Specifically, based on the intuition that not all relations are equal, we devise a novel approximation scheme that significantly reduces the amount of computation by efficiently filtering out relations that are unlikely to affect the final output. With the specialized hardware for this approximate self-attention mechanism, ELSA achieves a geomean speedup of 58.1X as well as over three orders of magnitude improvements in energy efficiency compared to GPU on self-attention computation in modern NN models while maintaining less than 1% loss in the accuracy metric.;;;https://dl.acm.org/doi/10.1109/ISCA52012.2021.00060;;;Software AND Engineering
Onboarding vs. Diversity, Productivity, and Quality: Empirical Study of the OpenStack Ecosystem;;;['Armstrong Foundjem', 'Ellis E. Eghan', 'Bram Adams'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Despite the growing success of open-source software ecosystems (SECOs), their sustainability depends on the recruitment and involvement of ever-larger contributors. As such, onboarding, i.e., the socio-technical adaptation of new contributors to a SECO, forms a significant aspect of a SECO's growth that requires substantial resources. Unfortunately, despite theoretical models and initial user studies to examine the potential benefits of onboarding, little is known about the process of SECO onboarding, nor about the socio-technical benefits and drawbacks of contributors' onboarding experience in a SECO. To address these, we first carry out an observational study of 72 new contributors during an OpenStack onboarding event to provide a catalog of teaching content, teaching strategies, onboarding challenges, and expected benefits. Next, we empirically validate the extent to which diversity, productivity, and quality benefits are achieved by mining code changes, reviews, and contributors' issues with(out) OpenStack onboarding experience. Among other findings, our study shows a significant correlation with increasing gender diversity (65% for both females and non-binary contributors) and patch acceptance rates (13.5%). Onboarding also has a significant negative correlation with the time until a contributor's first commit and bug-proneness of contributions.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00097;;;Software AND Engineering
Scalable statistical root cause analysis on app telemetry;;;['Vijayaraghavan Murali', 'Edward Yao', 'Umang Mathur', 'Satish Chandra'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;Despite engineering workflows that aim to prevent buggy code from being deployed, bugs still make their way into the Facebook app. When symptoms of these bugs, such as user submitted reports and automatically captured crashes, are reported, finding their root causes is an important step in resolving them. However, at Facebook's scale of billions of users, a single bug can manifest as several different symptoms according to the various user and execution environments in which the software is deployed. Root cause analysis (RCA) therefore requires tedious manual investigation and domain expertise to extract out common patterns that are observed in groups of reports and use them for debugging. We propose Minesweeper, a technique for RCA that moves towards automatically identifying the root cause of bugs from their symptoms. The method is based on two key aspects: (i) a scalable algorithm to efficiently mine patterns from telemetric information that is collected along with the reports, and (ii) statistical notions of precision and recall of patterns that help point towards root causes. We evaluate Minesweeper's scalability and effectiveness in finding root causes from symptoms on real world bug and crash reports from Facebook's apps. Our evaluation demonstrates that Minesweeper can perform RCA for tens of thousands of reports in less than 3 minutes, and is more than 85% accurate in identifying the root cause of regressions.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00038;;;Software AND Engineering
Human-level Ordinal Maintainability Prediction Based on Static Code Metrics;;;['Markus Schnappinger', 'Arnaud Fietzke', 'Alexander Pretschner'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;One of the greatest challenges in software quality control is the efficient and effective measurement of maintainability. Thorough expert assessments are precise yet slow and expensive, whereas automated static analysis yields imprecise yet rapid feedback. Several machine learning approaches aim to integrate the advantages of both concepts.  However, most prior studies did not adhere to expert judgment and predicted the number of changed lines as a proxy for maintainability, or were biased towards a small group of experts. In contrast, the present study builds on a manually labeled and validated dataset. Prediction is done using static code metrics where we found simple structural metrics such as the size of a class and its methods to yield the highest predictive power towards maintainability. Using just a small set of these metrics, our models can distinguish easy from hard to maintain code with an F-score of 91.3% and AUC of 82.3%.  In addition, we perform a more detailed ordinal classification and compare the quality of the classification with the performance of experts. Here, we use the deviations between the individual expert’s ratings and the eventually determined consensus of all experts.  In sum, our models achieve the same level of performance as an average human expert. In fact, the obtained accuracy and mean squared error outperform human performance. We hence argue that our models provide an automated and trustworthy prediction of software maintainability.;;;https://dl.acm.org/doi/10.1145/3463274.3463315;;;Software AND Engineering
Industry-scale IR-based bug localization: a perspective from Facebook;;;['Vijayaraghavan Murali', 'Lee Gross', 'Rebecca Qian', 'Satish Chandra'];;;May 2021;;;ICSE-SEIP '21: Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;;;We explore the application of Information Retrieval (IR) based bug localization methods at a large industrial setting, Facebook. Facebook's code base evolves rapidly, with thousands of code changes being committed to a monolithic repository every day. When a bug is detected, it is often time-sensitive and imperative to identify the commit causing the bug in order to either revert it or fix it. This is complicated by the fact that bugs often manifest with complex and unwieldy features, such as stack traces and other metadata. Code commits also have various features associated with them, ranging from developer comments to test results. This poses unique challenges to bug localization methods, making it a highly non-trivial operation. In this paper we lay out several practical concerns for industry-level IR-based bug localization, and propose Bug2Commit, a tool that is designed to address these concerns. We also assess the effectiveness of existing IR-based localization techniques from the software engineering community, and find that in the presence of complex queries or documents, which are common at Facebook, existing approaches do not perform as well as Bug2Commit. We evaluate Bug2Commit on three applications at Facebook: client-side crashes from the mobile app, server-side performance regressions, and mobile simulation tests for performance. We find that Bug2Commit outperforms the accuracy of existing approaches by up to 17%, leading to reduced time for triaging regressions and attributing bugs found in simulations.;;;https://dl.acm.org/doi/10.1109/ICSE-SEIP52600.2021.00028;;;Software AND Engineering
OMLT: optimization & machine learning toolkit;;;['Francesco Ceccon', 'Jordan Jalving', 'Joshua Haddad', 'Alexander Thebelt', 'Calvin Tsay', 'Carl D Laird', 'Ruth Misener'];;;None;;;The Journal of Machine Learning Research;;;The optimization and machine learning toolkit (OMLT) is an open-source software package incorporating neural network and gradient-boosted tree surrogate models, which have been trained using machine learning, into larger optimization problems. We discuss the advances in optimization technology that made OMLT possible and show how OMLT seamlessly integrates with the algebraic modeling language Pyomo. We demonstrate how to use OMLT for solving decision-making problems in both computer science and engineering.;;;https://dl.acm.org/doi/10.5555/3586589.3586938;;;Software AND Engineering
GraphScope: a unified engine for big graph processing;;;['Wenfei Fan', 'Tao He', 'Longbin Lai', 'Xue Li', 'Yong Li', 'Zhao Li', 'Zhengping Qian', 'Chao Tian', 'Lei Wang', 'Jingbo Xu', 'Youyang Yao', 'Qiang Yin', 'Wenyuan Yu', 'Jingren Zhou', 'Diwen Zhu', 'Rong Zhu'];;;None;;;Proceedings of the VLDB Endowment;;;GraphScope is a system and a set of language extensions that enable a new programming interface for large-scale distributed graph computing. It generalizes previous graph processing frameworks (e.g., Pregel, GraphX) and distributed graph databases (e.g., Janus-Graph, Neptune) in two important ways: by exposing a unified programming interface to a wide variety of graph computations such as graph traversal, pattern matching, iterative algorithms and graph neural networks within a high-level programming language; and by supporting the seamless integration of a highly optimized graph engine in a general purpose data-parallel computing system.A GraphScope program is a sequential program composed of declarative data-parallel operators, and can be written using standard Python development tools. The system automatically handles the parallelization and distributed execution of programs on a cluster of machines. It outperforms current state-of-the-art systems by enabling a separate optimization (or family of optimizations) for each graph operation in one carefully designed coherent framework. We describe the design and implementation of GraphScope and evaluate system performance using several real-world applications.;;;https://dl.acm.org/doi/10.14778/3476311.3476369;;;Software AND Engineering
Checking LTL[F,G,X] on compressed traces in polynomial time;;;['Minjian Zhang', 'Umang Mathur', 'Mahesh Viswanathan'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;The problem of checking if a program execution meets a formal specification arises in many software engineering tasks including runtime verification and designing test oracles. When online analysis is not possible, execution trace logs are stored for offline postmortem analysis, often in a compressed format to reduce disk space and warehousing requirements. A straightforward method for checking if a compressed execution satisfies a property is to first decompress it and then analyze the resulting uncompressed execution.  In this paper, we consider the problem of checking if an execution trace, compressed using a grammar-based lossless compression scheme, satisfies a specification expressed in linear temporal logic, without explicitly decompressing it. In general, this problem is known to be intractable (PSPACE-hard in the size of the compressed trace and the LTL formula). We show that the problem can be solved in polynomial time for the fragment LTL[F,G,X], which comprises of all Boolean and modal operators of LTL except the until operator. Our algorithm for analyzing SLPs (a grammar-based compression scheme) is effective in practice — for a suite of large execution traces obtained from open source projects, our algorithm shows significant speed ups when compared with the performance of checking LTL properties over corresponding uncompressed traces.;;;https://dl.acm.org/doi/10.1145/3468264.3468557;;;Software AND Engineering
Distribution-Aware Testing of Neural Networks Using Generative Models;;;['Swaroopa Dola', 'Matthew B. Dwyer', 'Mary Lou Soffa'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;The reliability of software that has a Deep Neural Network (DNN) as a component is urgently important today given the increasing number of critical applications being deployed with DNNs. The need for reliability raises a need for rigorous testing of the safety and trustworthiness of these systems. In the last few years, there have been a number of research efforts focused on testing DNNs. However the test generation techniques proposed so far lack a check to determine whether the test inputs they are generating are valid, and thus invalid inputs are produced. To illustrate this situation, we explored three recent DNN testing techniques. Using deep generative model based input validation, we show that all the three techniques generate significant number of invalid test inputs. We further analyzed the test coverage achieved by the test inputs generated by the DNN testing techniques and showed how invalid test inputs can falsely inflate test coverage metrics. To overcome the inclusion of invalid inputs in testing, we propose a technique to incorporate the valid input space of the DNN model under test in the test generation process. Our technique uses a deep generative model-based algorithm to generate only valid inputs. Results of our empirical studies show that our technique is effective in eliminating invalid tests and boosting the number of valid test inputs generated.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00032;;;Software AND Engineering
FOSSIL: a software tool for the formal synthesis of lyapunov functions and barrier certificates using neural networks;;;['Alessandro Abate', 'Daniele Ahmed', 'Alec Edwards', 'Mirco Giacobbe', 'Andrea Peruffo'];;;May 2021;;;HSCC '21: Proceedings of the 24th International Conference on Hybrid Systems: Computation and Control;;;This paper accompanies FOSSIL: a software tool for the synthesis of Lyapunov functions and of barrier certificates (or functions) for dynamical systems modelled as differential equations. Lyapunov functions are formal certificates for stability analysis, whereas barrier functions are formal certificates for the safety of dynamical models. FOSSIL is sound and automatic thanks to a counterexample-guided inductive synthesis loop. This method exploits the flexibility of candidate functions generated by training neural network templates, the formal assertions provided by a verifier (namely, an SMT solver), and finally new procedures to ease the exchange of information between the two mentioned components. We endow the tool with features of usability, scalability, and robustness---all of which are showcased on benchmarks.;;;https://dl.acm.org/doi/10.1145/3447928.3456646;;;Software AND Engineering
A proposal for organizing source code variability in the git version control system;;;['Junior Cupe Casquina', 'Leonardo Montecchi'];;;September 2021;;;SPLC '21: Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;;;Often, either to expand the target market or to satisfy specific new requirements, software systems inside a company are cloned, refactored, and customized, generating new derived software systems. Although this is a practical solution, it is not effective in the long-term because of the high maintenance costs when maintaining each of these derived software systems. Software product lines (SPLs) were proposed to reduce these costs; however, the lack of integration between variability realization mechanisms and version control systems reduces its attractiveness in the software development industry, especially in small and medium software companies. In this paper we propose an approach to integrate the conditional compilation mechanism used to implement the SPL variabilities and the Git version control system used to manage software versions in order to increase the attractiveness of the SPLs in the industry. The proposed solution also could be seen as a method to manage software system families' evolution in space and time.;;;https://dl.acm.org/doi/10.1145/3461001.3471141;;;Software AND Engineering
DirectDebug: automated testing and debugging of feature models;;;['Viet-Man Le', 'Alexander Felfernig', 'Mathias Uta', 'David Benavides', 'Jose Galindo', 'Thi Ngoc Trang Tran'];;;May 2021;;;ICSE-NIER '21: Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;;;Variability models (e.g., feature models) are a common way for the representation of variabilities and commonalities of software artifacts. Such models can be translated to a logical representation and thus allow different operations for quality assurance and other types of model property analysis. Specifically, complex and often large-scale feature models can become faulty, i.e., do not represent the expected variability properties of the underlying software artifact. In this paper, we introduce DirectDebug which is a direct diagnosis approach to the automated testing and debugging of variability models. The algorithm helps software engineers by supporting an automated identification of faulty constraints responsible for an unintended behavior of a variability model. This approach can significantly decrease development and maintenance efforts for such models.;;;https://dl.acm.org/doi/10.1109/ICSE-NIER52604.2021.00025;;;Software AND Engineering
SmartCommit: a graph-based interactive assistant for activity-oriented commits;;;['Bo Shen', 'Wei Zhang', 'Christian Kästner', 'Haiyan Zhao', 'Zhao Wei', 'Guangtai Liang', 'Zhi Jin'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;In collaborative software development, it is considered to be a best practice to submit code changes as a sequence of cohesive commits, each of which records the work result of a specific development activity, such as adding a new feature, bug fixing, and refactoring. However, rather than following this best practice, developers often submit a set of loosely-related changes serving for different development activities as a composite commit, due to the tedious manual work and lack of effective tool support to decompose such a tangled changeset. Composite commits often obfuscate the change history of software artifacts and bring challenges to efficient collaboration among developers. To encourage activity-oriented commits, we propose SmartCommit, a graph-partitioning-based interactive approach to tangled changeset decomposition that leverages not only the efficiency of algorithms but also the knowledge of developers. To evaluate the effectiveness of our approach, we (1) deployed SmartCommit in an international IT company, and analyzed usage data collected from a field study with 83 engineers over 9 months; and (2) conducted a controlled experiment on 3,000 synthetic composite commits from 10 diverse open-source projects. Results show that SmartCommit achieves a median accuracy between 71–84% when decomposing composite commits without developer involvement, and significantly helps developers follow the best practice of submitting activity-oriented commits with acceptable interaction effort and time cost in real collaborative software development.;;;https://dl.acm.org/doi/10.1145/3468264.3468551;;;Software AND Engineering
Teaching Exploratory Tests through PBL and JiTT: an experience report in a context of distributed teams;;;['Jarbele Coutinho', 'Wilkerson Andrade', 'Patricia Machado'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;There is no specific professional responsible for quality assurance in agile teams, such as the Test Engineer. Thus, the skills, competencies, and attributions inherent to this professional are the responsibility of all team members. Due to Exploratory Testing (ET) benefits in agile development, there is a need to train agile professionals. In this sense, this paper aims to investigate the contributions and limitations of adopting Problem-Based Learning (PBL) and Just-in-Time Teaching (JiTT) in ET teaching-learning. For this, we conducted a course in remote learning format with agile developers, distributed geographically. Data were collected through an online questionnaire and examined with quantitative and qualitative analysis at the end of the course. Our main findings are that (1) the collaboration between the participants and the adoption of a real problem, along with (2) activities and resources made available before the class, and (3) the existence of specific tool support for ET sessions optimized learning in the context of remote learning.;;;https://dl.acm.org/doi/10.1145/3474624.3476977;;;Software AND Engineering
Towards Sustainability of Systematic Literature Reviews;;;['Vinicius dos Santos', 'Anderson Yoshiaki Iwazaki', 'Katia Romero Felizardo', 'Érica Ferreira de Souza', 'Elisa Yumi Nakagawa'];;;October 2021;;;ESEM '21: Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);;;Background: The software engineering community has increasingly conducted systematic literature reviews (SLR) as a means to summarize evidence from different studies and bring to light the state of the art of a given research topic. While SLR provide many benefits, they also present several problems with punctual solutions for some of them. However, two main problems still remain: the high time-/effort-consumption nature of SLR and the lack of an effective impact of SLR results in the industry, as initially expected for SLR. Aims: The main goal of this paper is to introduce a new view --- which we name Sustainability of SLR --- on how to deal with SLR aiming at reducing those problems. Method: We analyzed six reference studies published in the last decade to identify, group, and analyze the SLR problems and their interconnections. Based on such analysis, we proposed the view of Sustainability of SLR that intends to address these problems. Results: The proposed view encompasses three dimensions (social, economic, and technical) that could become SLR more sustainable in the sense that the four major problems and 31 barriers (i.e., possible causes for those problems) that we identified could be mitigated. Conclusions: The view of Sustainability of SLR intends to change the researchers' mindset to mitigate the inherent SLR problems and, as a consequence, achieve sustainable SLR, i.e., those that consume less time/effort to be conducted and updated with useful results for the industry.;;;https://dl.acm.org/doi/10.1145/3475716.3484192;;;Software AND Engineering
Towards a Reliability Prediction Model based on Internal Structure and Post-Release Defects Using Neural Networks;;;['Andreea Vescan', 'Serban Camelia', 'Alisa-Daniela Budur'];;;June 2021;;;EASE '21: Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;;;Reliability is one of the most important quality attributes of a software system, addressing the system’s ability to perform the required functionalities under stated conditions, for a stated period of time. Nowadays, a system failure could threaten the safety of human life. Thus, assessing reliability became one of the software engineering‘s holy grails. Our approach wants to establish based on what project’s characteristics we obtain the best bug-oriented reliability prediction model. The pillars on which we base our approach are the metric introduced to estimate one aspect of reliability using bugs, and the Chidamber and Kemerer (CK) metrics to assess reliability in the early stages of development. The methodology used for prediction is a feed-forward neural network with back-propagation learning. Five different projects are used to validate the proposed approach for reliability prediction. The results indicate that CK metrics are promising in predicting reliability using a neural network model. The experiments also analyze if the type of project used in the development of the prediction model influences the quality of the prediction. As a result of the operated experiments using both within-project and cross-project validation, the best prediction model was obtained using PDE (PlugIn characteristic) for MY project (Task characteristic).;;;https://dl.acm.org/doi/10.1145/3463274.3463363;;;Software AND Engineering
Parallel Test Prioritization;;;['Jianyi Zhou', 'Junjie Chen', 'Dan Hao'];;;None;;;ACM Transactions on Software Engineering and Methodology;;;Although regression testing is important to guarantee the software quality in software evolution, it suffers from the widely known cost problem. To address this problem, existing researchers made dedicated efforts on test prioritization, which optimizes the execution order of tests to detect faults earlier; while practitioners in industry leveraged more computing resources to save the time cost of regression testing. By combining these two orthogonal solutions, in this article, we define the problem of parallel test prioritization, which is to conduct test prioritization in the scenario of parallel test execution to reduce the cost of regression testing.Different from traditional sequential test prioritization, parallel test prioritization aims at generating a set of test sequences, each of which is allocated in an individual computing resource and executed in parallel. In particular, we propose eight parallel test prioritization techniques by adapting the existing four sequential test prioritization techniques, by including and excluding testing time in prioritization.To investigate the performance of the eight parallel test prioritization techniques, we conducted an extensive study on 54 open-source projects and a case study on 16 commercial projects from Baidu, a famous search service provider with 600M monthly active users. According to the two studies, parallel test prioritization does improve the efficiency of regression testing, and cost-aware additional parallel test prioritization technique significantly outperforms the other techniques, indicating that this technique is a good choice for practical parallel testing. Besides, we also investigated the influence of two external factors, the number of computing resources and time allowed for parallel testing, and find that more computing resources indeed improve the performance of parallel test prioritization. In addition, we investigated the influence of two more factors, test granularity and coverage criterion, and find that parallel test prioritization can still accelerate regression testing in parallel scenario. Moreover, we investigated the benefit of parallel test prioritization on the regression testing process of continuous integration, considering both the cumulative acceleration performance and the overhead of prioritization techniques, and the results demonstrate the superiority of parallel test prioritization.;;;https://dl.acm.org/doi/10.1145/3471906;;;Software AND Engineering
Data-driven design and evaluation of SMT meta-solving strategies: balancing performance, accuracy, and cost;;;['Malte Mues', 'Falk Howar'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Many modern software engineering tools integrate SMT decision procedures and rely on the accuracy and performance of SMT solvers. We describe four basic patterns for integrating constraint solvers (earliest verdict, majority vote, feature-based solver selection, and verdict-based second attempt) that can be used for combining individual solvers into meta-decision procedures that balance accuracy, performance, and cost - or optimize for one of these metrics. In order to evaluate the effectiveness of meta-solving, we analyze and minimize 16 existing benchmark suites and benchmark seven state-of-the-art SMT solvers on 17k unique instances. From the obtained performance data, we can estimate the performance of different meta-solving strategies. We validate our results by implementing and analyzing two strategies. As additional results, we obtain (a) the first benchmark suite of unique SMT string problems with validated expected verdicts, (b) an extensive dataset containing data on benchmark instances as well as on the performance of individual decision procedures and several meta-solving strategies on these instances, and (c) a framework for generating data that can easily be used for similar analyses on different benchmark instances or for different decision procedures.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678881;;;Software AND Engineering
Detecting adversarial samples with graph-guided testing;;;['Zuohui Chen', 'Renxuan Wang', 'Jingyang Xiang', 'Yue Yu', 'Xin Xia', 'Shouling Ji', 'Qi Xuan', 'Xiaoniu Yang'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Deep Neural Networks (DNN) are known to be vulnerable to adversarial samples, the detection of which is crucial for the wide application of these DNN models. Recently, a number of deep testing methods in software engineering were proposed to find the vulnerability of DNN systems, and one of them, i.e., Model Mutation Testing (MMT), was used to successfully detect various adversarial samples generated by different kinds of adversarial attacks. However, the mutated models in MMT are always huge in number (e.g., over 100 models) and lack diversity (e.g., can be easily circumvented by high-confidence adversarial samples), which makes it less efficient in real applications and less effective in detecting high-confidence adversarial samples. In this study, we propose Graph-Guided Testing (GGT) for adversarial sample detection to overcome these aforementioned challenges. GGT generates pruned models with the guide of graph characteristics, each of them has only about 5% parameters of the mutated model in MMT, and graph guided models have higher diversity. The initial experiments on CIFAR10 validate that GGT performs much better than MMT with respect to both effectiveness and efficiency.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678732;;;Software AND Engineering
Race detection for event-driven Node.js applications;;;['Xiaoning Chang', 'Wensheng Dou', 'Jun Wei', 'Tao Huang', 'Jinhui Xie', 'Yuetang Deng', 'Jianbo Yang', 'Jiaheng Yang'];;;November 2021;;;ASE '21: Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering;;;Node.js has become a widely-used event-driven architecture for server-side and desktop applications. Node.js provides an effective asynchronous event-driven programming model, and supports asynchronous tasks and multi-priority event queues. Unexpected races among events and asynchronous tasks can cause severe consequences. Existing race detection approaches in Node.js applications mainly adopt random fuzzing technique, and can miss races due to large schedule space. In this paper, we propose a dynamic race detection approach NRace for Node.js applications. In NRace, we build precise happens-before relations among events and asynchronous tasks in Node.js applications, which also take multi-priority event queues into consideration. We further develop a predictive race detection technique based on these relations. We evaluate NRace on 10 real-world Node.js applications. The experimental result shows that NRace can precisely detect 6 races, and 5 of them have been confirmed by developers.;;;https://dl.acm.org/doi/10.1109/ASE51524.2021.9678814;;;Software AND Engineering
Vision: the next 700 language workbenches;;;['Mikhail Barash'];;;October 2021;;;SLE 2021: Proceedings of the 14th ACM SIGPLAN International Conference on Software Language Engineering;;;Language workbenches (LWBs) are tools to define software languages together with tailored Integrated Development Environments for them. A comprehensive review of language workbenches by Erdweg et al. (Comput. Lang. Syst. Struct. 44, 2015) presented a feature model of functionality of LWBs from the point of view of "languages that can be defined with a LWB, and not the definition mechanism of the LWB itself". This vision paper discusses possible functionality of LWBs with regard to language definition mechanisms. We have identified five groups of such functionality, related to: metadefinitions, metamodifications, metaprocess, LWB itself, and programs written in languages defined in a LWB. We design one of the features ("ability to define dependencies between language concerns") based on our vision.;;;https://dl.acm.org/doi/10.1145/3486608.3486907;;;Software AND Engineering
An Interview with Nachiappan Nagappan - ACM Fellow 2020;;;['Dietmar Pfahl'];;;October 2021;;;ACM SIGSOFT Software Engineering Notes;;;Nachiappan (Nachi) Nagappan is one of the five ACM Fellows of the 2020 cohort who are also active SIGSOFT members. To celebrate his award, we invited him to a question/answer session.Nachi earned his PhD from North Carolina State University (NCSU), USA, in 2005. Afterwards he was with Microsoft Research for more than 15 years, rising through the ranks from Software Engineer to Partner Researcher. In January 2021, he started in a new position with Facebook.Nachi's research interests are in the field of Software Engineering focusing on Software Reliability, Developer Productivity, Software Data Analytics and Empirical Software engineering. More broadly, he works on software analytics for improving software engineering practices. His work is strongly interdisciplinary and his research projects span the spectrum of software analytics ranging from developer productivity, large scale mining for GitHub, empirical software engineering analytics for the development process, intelligent software design for games, to predicting software service outages for cloud services. Nachi has been the recipient of many honors and best paper awards. For example, in 2019 and 2021, he and his co-authors won the ESEC/FSE test-of-time award, and in 2020 Nachi received the prestigious Harlan D. Mills Award.;;;https://dl.acm.org/doi/10.1145/3485952.3485955;;;Software AND Engineering
An Exploratory Teaching Proposal of Greek History Independence Events based on STEAM Epistemology, Educational Robotics and Smart Learning Technologies;;;['Spyridon Kourtis', 'Apostolos Xenakis', 'Konstantinos Kalovrektis', 'Antonios Plageras', 'Ioanna Chalvantzi'];;;November 2021;;;ESSE '21: Proceedings of the 2021 European Symposium on Software Engineering;;;Digital technologies help students to delve into the process of scientific discovery. Curriculum integration of STEM contents based on constructivism theories of learning as a context to implement the Science, Technology, Engineering, Mathematics (STEM) epistemology. In this work, we proposed an Inquiry based STEM constructivist teaching and learning methodology for Historical events of the Greek Revolution, enriched with smart learning technologies and engineering practices, while combining Educational Robotics approach. In particular, students design and built a history – line and program their robot to move towards each station, which represent an important timestamp event for Greek Revolution. The robot reads the station's QR code, via a smartphone attached to it, and then returns back to its base. Students retrieve information regarding historical events and according to an APP on their smartphone, they play a knowledge game, concerning these events. This work also highlights, via qualitative results, the additional value that smart learning technologiesand educational robotics give to theoretical subjects, such as History, which should need to be taught in an exploratory way. In that way, students are actively involved in hands – on activities and engineering design process, gaining knowledge from subjects as technology, computer science and engineering.;;;https://dl.acm.org/doi/10.1145/3501774.3501792;;;Software AND Engineering
A Low-Latency Control Path Design for Cloud Based Micro-Drones;;;['Yendo Hu', 'Yiliang Wu', 'Xue Bai', 'Minghong Chen', 'Zhuo Guanglei', 'Zhipeng Shi'];;;October 2021;;;EITCE '21: Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;;;Dynamic real-time control through a remote network is becoming a reality, given the drive of the latest generation of wireless networks. As cloud computing takes on an even stronger role in the industry, the desire to offload time critical processes into the network becomes a possibility. With the combination of cloud edge processing centers, and the UUL standardization for sub-millisecond delay over 5G networks, applications requiring dynamic time critical closed loop control is now an option. With the support of cloud edge processors, advanced complex analysis and processing algorithms, such deep learning engines or video-based approaches, miniature drones can achieve higher levels of capability without the weight or cost requirements. In this paper, we present wireless closed loop control system. The proposed framework is composed of a controller, drone flight receiver and motor control. The delay time from the issuance of the control command to the start of the execution of the control command is only about 4 ms. The proposed solution has been implemented and verified on the research UAV data link system.;;;https://dl.acm.org/doi/10.1145/3501409.3501663;;;Software AND Engineering
InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees;;;['Nghi D. Q. Bui', 'Yijun Yu', 'Lingxiao Jiang'];;;May 2021;;;ICSE '21: Proceedings of the 43rd International Conference on Software Engineering;;;Learning code representations has found many uses in software engineering, such as code classification, code search, comment generation, and bug prediction, etc. Although representations of code in tokens, syntax trees, dependency graphs, paths in trees, or the combinations of their variants have been proposed, existing learning techniques have a major limitation that these models are often trained on datasets labeled for specific downstream tasks, and as such the code representations may not be suitable for other tasks. Even though some techniques generate representations from unlabeled code, they are far from being satisfactory when applied to the downstream tasks. To overcome the limitation, this paper proposes InferCode, which adapts the self-supervised learning idea from natural language processing to the abstract syntax trees (ASTs) of code. The novelty lies in the training of code representations by predicting subtrees automatically identified from the contexts of ASTs. With InferCode, subtrees in ASTs are treated as the labels for training the code representations without any human labelling effort or the overhead of expensive graph construction, and the trained representations are no longer tied to any specific downstream tasks or code units. We have trained an instance of InferCode model using Tree-Based Convolutional Neural Network (TBCNN) as the encoder of a large set of Java code. This pre-trained model can then be applied to downstream unsupervised tasks such as code clustering, code clone detection, cross-language code search, or be reused under a transfer learning scheme to continue training the model weights for supervised tasks such as code classification and method name prediction. Compared to prior techniques applied to the same downstream tasks, such as code2vec, code2seq, ASTNN, using our pre-trained InferCode model higher performance is achieved with a significant margin for most of the tasks, including those involving different programming languages. The implementation of InferCode and the trained embeddings are available at the link: https://github.com/bdqnghi/infercode.;;;https://dl.acm.org/doi/10.1109/ICSE43902.2021.00109;;;Software AND Engineering
AlloyMax: bringing maximum satisfaction to relational specifications;;;['Changjian Zhang', 'Ryan Wagner', 'Pedro Orvalho', 'David Garlan', 'Vasco Manquinho', 'Ruben Martins', 'Eunsuk Kang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Alloy is a declarative modeling language based on a first-order relational logic. Its constraint-based analysis has enabled a wide range of applications in software engineering, including configuration synthesis, bug finding, test-case generation, and security analysis. Certain types of analysis tasks in these domains involve finding an optimal solution. For example, in a network configuration problem, instead of finding any valid configuration, it may be desirable to find one that is most permissive (i.e., it permits a maximum number of packets). Due to its dependence on SAT, however, Alloy cannot be used to specify and analyze these types of problems.  We propose AlloyMax, an extension of Alloy with a capability to express and analyze problems with optimal solutions. AlloyMax introduces (1) a small addition of language constructs that can be used to specify a wide range of problems that involve optimality and (2) a new analysis engine that leverages a Maximum Satisfiability (MaxSAT) solver to generate optimal solutions. To enable this new type of analysis, we show how a specification in a first-order relational logic can be translated into an input format of MaxSAT solvers—namely, a Boolean formula in weighted conjunctive normal form (WCNF). We demonstrate the applicability and scalability of AlloyMax on a benchmark of problems. To our knowledge, AlloyMax is the first approach to enable analysis with optimality in a relational modeling language, and we believe that AlloyMax has the potential to bring a wide range of new applications to Alloy.;;;https://dl.acm.org/doi/10.1145/3468264.3468587;;;Software AND Engineering
Towards Multidisciplinary Delta-Oriented Variability Management in Cyber-Physical Production Systems;;;['Hafiyyan Sayyid Fadhlillah', 'Kevin Feichtinger', 'Kristof Meixner', 'Lisa Sonnleithner', 'Rick Rabiser', 'Alois Zoitl'];;;February 2022;;;VaMoS '22: Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;;;Cyber-Physical Production Systems (CPPSs) are complex systems comprised of software and hardware interacting with each other and the environment. In industry, over time, a plethora of CPPSs are developed to satisfy varying customer requirements and changing technologies. Managing variability is challenging, especially in multidisciplinary environments like in CPPS engineering. For instance, when supporting the automatic derivation and configuration of control software, one needs to understand variability from not only a software perspective, but also a mechatronic, electrical, process, and business perspective. It is unrealistic to use a single model or even one type of model across these perspectives. In this paper, we describe a Multidisciplinary Delta-Oriented Variability Management approach for CPPSs that we are currently developing. Our approach aims to express CPPS variability in different disciplines using heterogeneous variability models, relating models via cross-discipline constraints, and automatically generating control software based on variability models. We implemented a prototype of our approach by realizing delta-oriented variability modeling for IEC 61499-based distributed control software and a configuration tool to enact the configuration options from multiple variability models. We performed a feasibility study of our approach using two systems of different size and complexity. We conclude that, despite current limitations, our approach can successfully and automatically generate control software based on related multidisciplinary variability models. We think that our approach is a good starting point to manage CPPS variability in practice.;;;https://dl.acm.org/doi/10.1145/3510466.3511273;;;Software AND Engineering
SIKE in 32-bit ARM Processors Based on Redundant Number System for NIST Level-II;;;['Hwajeong Seo', 'Pakize Sanal', 'Reza Azarderakhsh'];;;None;;;ACM Transactions on Embedded Computing Systems;;;We present an optimized implementation of the post-quantum Supersingular Isogeny Key Encapsulation (SIKE) for 32-bit ARMv7-A processors supporting NEON engine (i.e., SIMD instruction). Unlike previous SIKE implementations, finite field arithmetic is efficiently implemented in a redundant representation, which avoids carry propagation and pipeline stall. Furthermore, we adopted several state-of-the-art engineering techniques as well as hand-crafted assembly implementation for high performance. Optimized implementations are ported to Microsoft SIKE library written in “a non-redundant representation” and evaluated in high-end 32-bit ARMv7-A processors, such as ARM Cortex-A5, A7, and A15. A full key-exchange execution of SIKEp503 is performed in about 109 million cycles on ARM Cortex-A15 processors (i.e., 54.5 ms @2.0 GHz), which is about 1.58× faster than previous state-of-the-art work presented in CHES’18.;;;https://dl.acm.org/doi/10.1145/3439733;;;Software AND Engineering
CrowdSLR: a tool to support the use of crowdsourcing in systematic literature reviews;;;['Vinicius Santos', 'Anderson Iwazaki', 'Érica Souza', 'Katia Felizardo', 'Nandamudi Vijaykumar'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;Systematic Literature Reviews (SLR) have been used by Software Engineering (SE) community to produce reliable scientific evidence. An SLR process can be exhaustive and time-consuming, therefore, many approaches have been proposed to reduce time and efforts during the SLR conduction process. Although the SLR process is amenable to automation, nowadays full automation is not yet possible. An alternative to reduce time and efforts in SLR conduction is the use of crowdsourcing. However, there is no crowdsourcing tool to support a crowd-based SLR process. In this context, we present CrowdSLR, a tool to support the application of crowdsourcing in SLR during the selection of primary studies. Furthermore, we present its main features, potential users, and the architecture that was implemented to allow researchers to adopt this tool. The results of the CrowdSLR application indicate that the tool is able to provide the use crowdsourcing during the SLR selection process. The results that the proposed tool, indeed, show a significant improvement in the crowdsourcing approach in terms of time and effort to facilitate the SLR selection activity.  Demo Video: https://youtu.be/UoQTC-R-Mv0;;;https://dl.acm.org/doi/10.1145/3474624.3476008;;;Software AND Engineering
How Do Developers Blog?: A Retrospective;;;['Dennis Pagano', 'Walid Maalej'];;;July 2021;;;ACM SIGSOFT Software Engineering Notes;;;A decade ago, the rise of GitHub and StackOverflow as social version control and knowledge sharing environments was about to start. Social media like Twitter were mocked by some software engineering researchers and practitioners as "tools for kids not professionals". At that time, we published one of the first papers [12] on social media in software engineering at MSR 2011, the Mining Software Repositories Conference.;;;https://dl.acm.org/doi/10.1145/3468744.3468753;;;Software AND Engineering
Which abbreviations should be expanded?;;;['Yanjie Jiang', 'Hui Liu', 'Yuxia Zhang', 'Nan Niu', 'Yuhai Zhao', 'Lu Zhang'];;;August 2021;;;ESEC/FSE 2021: Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;;;Abbreviations are common in source code. Properly designed abbreviations may significantly facilitate typing, typesetting, and reading of lengthy source code. However, abbreviations, if used improperly, may also significantly reduce the readability and maintainability of source code. Although a few automated approaches have been proposed to suggest full terms for given abbreviations, to the best of our knowledge, there is no automated approaches to suggest whether abbreviations are used properly, i.e., whether they should be replaced with corresponding full terms. Notably, it is often challenging for inexperienced developers and maintainers to make such decisions. To this end, in this paper, we propose an automated approach to assisting developers and maintainers in making the decisions. The rationale of the approach is that abbreviations should not be expanded if the expansion would result in unacceptably lengthy identifiers or if developers/maintainers can easily figure out the meaning (full terms) of the abbreviations based on their domain knowledge or contexts of the abbreviations. From a corpus of programs, we leverage data mining techniques to discover common abbreviations that are frequently employed by various developers in similar contexts. The key of the data mining is to turn the problem of mining common abbreviations into the maximal clique problem that has been extensively studied. We suggest to not expand given abbreviation if it matches at least one of the discovered common abbreviations. From the same corpus, we also calculate the probability distribution for the length of different types of identifier, e.g., variable names and method names. The probability distribution specifies how likely an identifier of type T is composed of exactly n characters. Our heuristic is to not expand the abbreviation if the probability of its enclosing identifier would be reduced by the expansion. Finally, we also suggest to not expand the abbreviation if its full terms are contained in surrounding contexts of the abbreviation, i.e., tokens on the same source code line. Other abbreviations that do not receive suggestions from the proposed approach are expected to be replaced with their full terms. Our evaluation results on 1,818 abbreviations from five open-source applications suggest that the proposed approach is accurate with a high accuracy of 95%.;;;https://dl.acm.org/doi/10.1145/3468264.3468616;;;Software AND Engineering
TIMEG: Development and Evaluation of an Inspection Checklist Tool for Mobile Educational Games;;;['Kastney Frazão', 'Alexandre Pessoa', 'Anselmo Paiva', 'Davi Viana', 'Luis Rivero'];;;September 2021;;;SBES '21: Proceedings of the XXXV Brazilian Symposium on Software Engineering;;;The software inspection process allows identifying defects during the development cycle. In the context of mobile serious games, specific inspection checklists can be employed to guarantee their quality. However, there are few tools to support the use of these checklists and the existing ones are generic and not specific for the evaluation of digital educational games for mobile devices. To assist software engineers in the evaluation of this type of games, an open-source desktop tool was developed in C#, called TIMEG (Tool for Checklist Inspection of Mobile Educational Games). TIMEG allows to: (1) embed inspection checklists; (2) point out defects based on the items in the checklists; (3) generate inspection reports; and if the game is already available in the Google Play store, (4) present information about the users’ opinions. The tool was evaluated from the point of view of inexperienced software engineers when applied for evaluating a mobile serious game; and through the answers to a questionnaire. The results indicate that the tool was perceived as useful and easy to use, in addition to identifying opportunities for improvement in the tool’s interface and usability, as well as improvements in the presentation of relevant information in the defect reports.  Link para Vídeo: Clique Aqui;;;https://dl.acm.org/doi/10.1145/3474624.3476013;;;Software AND Engineering
Semantic table structure identification in spreadsheets;;;['Yakun Zhang', 'Xiao Lv', 'Haoyu Dong', 'Wensheng Dou', 'Shi Han', 'Dongmei Zhang', 'Jun Wei', 'Dan Ye'];;;July 2021;;;ISSTA 2021: Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis;;;Spreadsheets are widely used in various business tasks, and contain amounts of valuable data. However, spreadsheet tables are usually organized in a semi-structured way, and contain complicated semantic structures, e.g., header types and relations among headers. Lack of documented semantic table structures, existing data analysis and error detection tools can hardly understand spreadsheet tables. Therefore, identifying semantic table structures in spreadsheet tables is of great importance, and can greatly promote various analysis tasks on spreadsheets.  In this paper, we propose Tasi (Table structure identification) to automatically identify semantic table structures in spreadsheets. Based on the contents, styles, and spatial locations in table headers, Tasi adopts a multi-classifier to predict potential header types and relations, and then integrates all header types and relations into consistent semantic table structures. We further propose TasiError, to detect spreadsheet errors based on the identified semantic table structures by Tasi. Our experiments on real-world spreadsheets show that, Tasi can precisely identify semantic table structures in spreadsheets, and TasiError can detect real-world spreadsheet errors with higher precision (75.2%) and recall (82.9%) than existing approaches.;;;https://dl.acm.org/doi/10.1145/3460319.3464812;;;Software AND Engineering
